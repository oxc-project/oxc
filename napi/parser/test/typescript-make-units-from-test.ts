// TypeScript test file parser.
// Port of Rust implementation from oxc/tasks/coverage/src/typescript/meta.rs
// Generated by GitHub Copilot initially and amended since.
//
// This file is duplicated in `oxc-project/estree-conformance` repo in `src/utils` directory.
// Any changes made here also need to be replicated there.

import fs from "fs";
import path from "path";

// Regex patterns equivalent to the Rust version
const META_OPTIONS_REGEX = /^\/\/\s*@(\w+)\s*:\s*([^\r\n]*)/gm;

/**
 * Convert settings value to boolean
 * @param {string|null} value - Setting value
 * @param {boolean} defaultValue - Default value if setting is not present
 * @returns {boolean}
 */
function valueToBoolean(value, defaultValue) {
  if (value === "true") return true;
  if (value === "false") return false;
  return defaultValue;
}

/**
 * Split comma-separated values into array
 * @param {string|null} value - Setting value
 * @returns {string[]}
 */
function splitValueOptions(value) {
  if (!value) return [];
  return value.split(",").map((s) => s.trim().toLowerCase());
}

/**
 * Create compiler settings from options map
 * @param {Map<string, string>} options - Compiler options
 * @returns {Object} CompilerSettings
 */
function createCompilerSettings(options) {
  return {
    modules: splitValueOptions(options.get("module")),
    targets: splitValueOptions(options.get("target")),
    strict: valueToBoolean(options.get("strict"), false),
    jsx: splitValueOptions(options.get("jsx")),
    declaration: valueToBoolean(options.get("declaration"), false),
    emitDeclarationOnly: valueToBoolean(options.get("emitdeclarationonly"), false),
    alwaysStrict: valueToBoolean(options.get("alwaysstrict"), false),
    allowUnreachableCode: valueToBoolean(options.get("allowunreachablecode"), true),
    allowUnusedLabels: valueToBoolean(options.get("allowunusedlabels"), true),
    noFallthroughCasesInSwitch: valueToBoolean(options.get("nofallthroughcasesinswitch"), false),
  };
}

// Mapping from file extension to source type
const EXTENSIONS = {
  ".js": { typescript: false, jsx: false, module: true },
  ".mjs": { typescript: false, jsx: false, module: true },
  ".cjs": { typescript: false, jsx: false, module: false },
  ".jsx": { typescript: false, jsx: true, module: true },
  ".ts": { typescript: true, jsx: false, module: true },
  ".mts": { typescript: true, jsx: false, module: true },
  ".cts": { typescript: true, jsx: false, module: false },
  ".tsx": { typescript: true, jsx: true, module: true },
};

/**
 * Get source type from file path
 * @param {string} filePath - Path to the file
 * @param {Object} options - Compiler options
 * @returns {Object|null} Source type
 */
function getSourceType(filePath, options) {
  const ext = path.extname(filePath).toLowerCase();
  let sourceType = EXTENSIONS[ext];

  if (!sourceType) return null;

  sourceType = {
    ...sourceType,
    module: false, // Will be updated later if needed
  };
  if (options.jsx.length > 0) sourceType.jsx = true;

  return sourceType;
}

/**
 * Get error files for the test
 * @param {string} filePath - Path to the test file
 * @param {Object} options - Compiler options
 * @returns {string[]} Error files content
 */
function getErrorFiles(filePath, options) {
  const fileName = path.basename(filePath, path.extname(filePath));
  const root = path.join(process.cwd(), "typescript/tests/baselines/reference");

  const suffixes = [
    "",
    ...options.modules.map((module) => `(module=${module})`),
    ...options.targets.map((target) => `(target=${target})`),
    ...options.jsx.map((jsx) => `(jsx=${jsx})`),
  ];

  const errorFiles = [];

  for (const suffix of suffixes) {
    const errorPath = path.join(root, `${fileName}${suffix}.errors.txt`);
    try {
      if (fs.existsSync(errorPath)) {
        const errorFile = fs.readFileSync(errorPath, "utf8");
        errorFiles.push(errorFile);
      }
    } catch {
      // Skip if file doesn't exist or can't be read
    }
  }

  return errorFiles;
}

/**
 * Extract individual test units from a TypeScript test file
 * @param {string} filePath - Path to the test file
 * @param {string} code - Content of the test file
 * @returns {Object} TestCaseContent object
 */
export function makeUnitsFromTest(filePath, code) {
  const currentFileOptions = new Map();
  let currentFileName = null;
  const testUnitData = [];
  let currentFileContent = "";

  // Process the file line by line
  const lines = code.split(/\r?\n/);
  if (lines[lines.length - 1] === "") lines.length--;

  for (const line of lines) {
    // Reset regex state
    META_OPTIONS_REGEX.lastIndex = 0;
    const match = META_OPTIONS_REGEX.exec(line);

    if (match) {
      const metaName = match[1].toLowerCase();
      const metaValue = match[2].trim();

      if (metaName === "filename") {
        if (currentFileName !== null) {
          testUnitData.push({
            name: currentFileName,
            content: currentFileContent,
            sourceType: null, // Will be set later
          });
          currentFileContent = "";
        }
        currentFileName = metaValue;
      } else {
        currentFileOptions.set(metaName, metaValue);
      }
    } else {
      if (currentFileContent.length > 0) {
        currentFileContent += "\n";
      }
      currentFileContent += line;
    }
  }

  // Handle the last file (or the only file if no @filename is used)
  const fileName = currentFileName || path.basename(filePath);
  testUnitData.push({
    name: fileName,
    content: currentFileContent,
    sourceType: null, // Will be set later
  });

  const settings = createCompilerSettings(currentFileOptions);

  // Update source types and filter out unsupported files
  const isModule = testUnitData.length > 1;
  const validTestUnits = testUnitData.filter((unit) => {
    const sourceType = getSourceType(unit.name, settings);
    if (!sourceType) return false;
    if (isModule) sourceType.module = true;
    unit.sourceType = sourceType;
    return true;
  });

  const errorFiles = getErrorFiles(filePath, settings);

  return {
    tests: validTestUnits,
    settings,
    errorFiles,
  };
}
