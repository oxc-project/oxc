// TypeScript test file parser.
// Port of Rust implementation from oxc/tasks/coverage/src/typescript/meta.rs
// Generated by GitHub Copilot initially and amended since.
//
// This file is duplicated in `oxc-project/acorn-test262` repo in `src/utils` directory.
// Any changes made here also need to be replicated there.

const path = require('path');
const fs = require('fs');

// Regex patterns equivalent to the Rust version
const META_OPTIONS_REGEX = /^\/\/\s*@(\w+)\s*:\s*([^\r\n]*)/gm;

/**
 * Convert settings value to boolean
 * @param {string|null} value - Setting value
 * @param {boolean} defaultValue - Default value if setting is not present
 * @returns {boolean}
 */
function valueToBoolean(value, defaultValue) {
  if (value === 'true') return true;
  if (value === 'false') return false;
  return defaultValue;
}

/**
 * Split comma-separated values into array
 * @param {string|null} value - Setting value
 * @returns {string[]}
 */
function splitValueOptions(value) {
  if (!value) return [];
  return value.split(',').map(s => s.trim().toLowerCase());
}

/**
 * Create compiler settings from options map
 * @param {Map<string, string>} options - Compiler options
 * @returns {Object} CompilerSettings
 */
function createCompilerSettings(options) {
  return {
    modules: splitValueOptions(options.get('module')),
    targets: splitValueOptions(options.get('target')),
    strict: valueToBoolean(options.get('strict'), false),
    jsx: splitValueOptions(options.get('jsx')),
    declaration: valueToBoolean(options.get('declaration'), false),
    emitDeclarationOnly: valueToBoolean(options.get('emitdeclarationonly'), false),
    alwaysStrict: valueToBoolean(options.get('alwaysstrict'), false),
    allowUnreachableCode: valueToBoolean(options.get('allowunreachablecode'), true),
    allowUnusedLabels: valueToBoolean(options.get('allowunusedlabels'), true),
    noFallthroughCasesInSwitch: valueToBoolean(options.get('nofallthroughcasesinswitch'), false),
  };
}

// Mapping from file extension to source type
const EXTENSIONS = {
  '.js': { typescript: false, jsx: false, module: true },
  '.mjs': { typescript: false, jsx: false, module: true },
  '.cjs': { typescript: false, jsx: false, module: false },
  '.jsx': { typescript: false, jsx: true, module: true },
  '.ts': { typescript: true, jsx: false, module: true },
  '.mts': { typescript: true, jsx: false, module: true },
  '.cts': { typescript: true, jsx: false, module: false },
  '.tsx': { typescript: true, jsx: true, module: true },
};

/**
 * Get source type from file path
 * @param {string} filePath - Path to the file
 * @param {Object} options - Compiler options
 * @returns {Object|null} Source type
 */
function getSourceType(filePath, options) {
  const ext = path.extname(filePath).toLowerCase();
  let sourceType = EXTENSIONS[ext];

  if (!sourceType) return null;

  sourceType = {
    ...sourceType,
    module: false, // Will be updated later if needed
  };
  if (options.jsx.length > 0) sourceType.jsx = true;

  return sourceType;
}

/**
 * Get error files for the test
 * @param {string} filePath - Path to the test file
 * @param {Object} options - Compiler options
 * @returns {string[]} Error files content
 */
function getErrorFiles(filePath, options) {
  const fileName = path.basename(filePath, path.extname(filePath));
  const root = path.join(process.cwd(), 'typescript/tests/baselines/reference');

  const suffixes = [
    '',
    ...options.modules.map(module => `(module=${module})`),
    ...options.targets.map(target => `(target=${target})`),
    ...options.jsx.map(jsx => `(jsx=${jsx})`),
  ];

  const errorFiles = [];

  for (const suffix of suffixes) {
    const errorPath = path.join(root, `${fileName}${suffix}.errors.txt`);
    try {
      if (fs.existsSync(errorPath)) {
        const errorFile = fs.readFileSync(errorPath, 'utf8');
        errorFiles.push(errorFile);
      }
    } catch (e) {
      // Skip if file doesn't exist or can't be read
    }
  }

  return errorFiles;
}

/**
 * Extract individual test units from a TypeScript test file
 * @param {string} filePath - Path to the test file
 * @param {string} code - Content of the test file
 * @returns {Object} TestCaseContent object
 */
function makeUnitsFromTest(filePath, code) {
  const currentFileOptions = new Map();
  let currentFileName = null;
  const testUnitData = [];
  let currentFileContent = '';

  // Process the file line by line
  const lines = code.split(/\r?\n/);
  if (lines[lines.length - 1] === '') lines.length--;

  for (const line of lines) {
    // Reset regex state
    META_OPTIONS_REGEX.lastIndex = 0;
    const match = META_OPTIONS_REGEX.exec(line);

    if (match) {
      const metaName = match[1].toLowerCase();
      const metaValue = match[2].trim();

      if (metaName === 'filename') {
        if (currentFileName !== null) {
          testUnitData.push({
            name: currentFileName,
            content: currentFileContent,
            sourceType: null, // Will be set later
          });
          currentFileContent = '';
        }
        currentFileName = metaValue;
      } else {
        currentFileOptions.set(metaName, metaValue);
      }
    } else {
      if (currentFileContent.length > 0) {
        currentFileContent += '\n';
      }
      currentFileContent += line;
    }
  }

  // Handle the last file (or the only file if no @filename is used)
  const fileName = currentFileName || path.basename(filePath);
  testUnitData.push({
    name: fileName,
    content: currentFileContent,
    sourceType: null, // Will be set later
  });

  const settings = createCompilerSettings(currentFileOptions);

  // Update source types and filter out unsupported files
  const isModule = testUnitData.length > 1;
  const validTestUnits = testUnitData
    .filter(unit => {
      const sourceType = getSourceType(unit.name, settings);
      if (!sourceType) return false;
      if (isModule) sourceType.module = true;
      unit.sourceType = sourceType;
      return true;
    });

  const errorFiles = getErrorFiles(filePath, settings);

  return {
    tests: validTestUnits,
    settings,
    errorFiles,
  };
}

module.exports.makeUnitsFromTest = makeUnitsFromTest;
