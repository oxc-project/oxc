// Auto-generated code, DO NOT EDIT DIRECTLY!
// To edit this generated file you have to edit `tasks/ast_tools/src/generators/estree_visit.rs`.

const { freeze } = Object;

export default freeze({
  // Leaf nodes
  DebuggerStatement: freeze([]),
  EmptyStatement: freeze([]),
  Literal: freeze([]),
  PrivateIdentifier: freeze([]),
  Super: freeze([]),
  TemplateElement: freeze([]),
  ThisExpression: freeze([]),
  JSXClosingFragment: freeze([]),
  JSXEmptyExpression: freeze([]),
  JSXIdentifier: freeze([]),
  JSXOpeningFragment: freeze([]),
  JSXText: freeze([]),
  TSAnyKeyword: freeze([]),
  TSBigIntKeyword: freeze([]),
  TSBooleanKeyword: freeze([]),
  TSIntrinsicKeyword: freeze([]),
  TSJSDocUnknownType: freeze([]),
  TSNeverKeyword: freeze([]),
  TSNullKeyword: freeze([]),
  TSNumberKeyword: freeze([]),
  TSObjectKeyword: freeze([]),
  TSStringKeyword: freeze([]),
  TSSymbolKeyword: freeze([]),
  TSThisType: freeze([]),
  TSUndefinedKeyword: freeze([]),
  TSUnknownKeyword: freeze([]),
  TSVoidKeyword: freeze([]),
  // Non-leaf nodes
  AccessorProperty: freeze(["decorators", "key", "typeAnnotation", "value"]),
  ArrayExpression: freeze(["elements"]),
  ArrayPattern: freeze(["decorators", "elements", "typeAnnotation"]),
  ArrowFunctionExpression: freeze(["typeParameters", "params", "returnType", "body"]),
  AssignmentExpression: freeze(["left", "right"]),
  AssignmentPattern: freeze(["decorators", "left", "right", "typeAnnotation"]),
  AwaitExpression: freeze(["argument"]),
  BinaryExpression: freeze(["left", "right"]),
  BlockStatement: freeze(["body"]),
  BreakStatement: freeze(["label"]),
  CallExpression: freeze(["callee", "typeArguments", "arguments"]),
  CatchClause: freeze(["param", "body"]),
  ChainExpression: freeze(["expression"]),
  ClassBody: freeze(["body"]),
  ClassDeclaration: freeze([
    "decorators",
    "id",
    "typeParameters",
    "superClass",
    "superTypeArguments",
    "implements",
    "body",
  ]),
  ClassExpression: freeze([
    "decorators",
    "id",
    "typeParameters",
    "superClass",
    "superTypeArguments",
    "implements",
    "body",
  ]),
  ConditionalExpression: freeze(["test", "consequent", "alternate"]),
  ContinueStatement: freeze(["label"]),
  Decorator: freeze(["expression"]),
  DoWhileStatement: freeze(["body", "test"]),
  ExportAllDeclaration: freeze(["exported", "source", "attributes"]),
  ExportDefaultDeclaration: freeze(["declaration"]),
  ExportNamedDeclaration: freeze(["declaration", "specifiers", "source", "attributes"]),
  ExportSpecifier: freeze(["local", "exported"]),
  ExpressionStatement: freeze(["expression"]),
  ForInStatement: freeze(["left", "right", "body"]),
  ForOfStatement: freeze(["left", "right", "body"]),
  ForStatement: freeze(["init", "test", "update", "body"]),
  FunctionDeclaration: freeze(["id", "typeParameters", "params", "returnType", "body"]),
  FunctionExpression: freeze(["id", "typeParameters", "params", "returnType", "body"]),
  Identifier: freeze(["decorators", "typeAnnotation"]),
  IfStatement: freeze(["test", "consequent", "alternate"]),
  ImportAttribute: freeze(["key", "value"]),
  ImportDeclaration: freeze(["specifiers", "source", "attributes"]),
  ImportDefaultSpecifier: freeze(["local"]),
  ImportExpression: freeze(["source", "options"]),
  ImportNamespaceSpecifier: freeze(["local"]),
  ImportSpecifier: freeze(["imported", "local"]),
  LabeledStatement: freeze(["label", "body"]),
  LogicalExpression: freeze(["left", "right"]),
  MemberExpression: freeze(["object", "property"]),
  MetaProperty: freeze(["meta", "property"]),
  MethodDefinition: freeze(["decorators", "key", "value"]),
  NewExpression: freeze(["callee", "typeArguments", "arguments"]),
  ObjectExpression: freeze(["properties"]),
  ObjectPattern: freeze(["decorators", "properties", "typeAnnotation"]),
  ParenthesizedExpression: freeze(["expression"]),
  Program: freeze(["body"]),
  Property: freeze(["key", "value"]),
  PropertyDefinition: freeze(["decorators", "key", "typeAnnotation", "value"]),
  RestElement: freeze(["decorators", "argument", "typeAnnotation"]),
  ReturnStatement: freeze(["argument"]),
  SequenceExpression: freeze(["expressions"]),
  SpreadElement: freeze(["argument"]),
  StaticBlock: freeze(["body"]),
  SwitchCase: freeze(["test", "consequent"]),
  SwitchStatement: freeze(["discriminant", "cases"]),
  TaggedTemplateExpression: freeze(["tag", "typeArguments", "quasi"]),
  TemplateLiteral: freeze(["quasis", "expressions"]),
  ThrowStatement: freeze(["argument"]),
  TryStatement: freeze(["block", "handler", "finalizer"]),
  UnaryExpression: freeze(["argument"]),
  UpdateExpression: freeze(["argument"]),
  V8IntrinsicExpression: freeze(["name", "arguments"]),
  VariableDeclaration: freeze(["declarations"]),
  VariableDeclarator: freeze(["id", "init"]),
  WhileStatement: freeze(["test", "body"]),
  WithStatement: freeze(["object", "body"]),
  YieldExpression: freeze(["argument"]),
  JSXAttribute: freeze(["name", "value"]),
  JSXClosingElement: freeze(["name"]),
  JSXElement: freeze(["openingElement", "children", "closingElement"]),
  JSXExpressionContainer: freeze(["expression"]),
  JSXFragment: freeze(["openingFragment", "children", "closingFragment"]),
  JSXMemberExpression: freeze(["object", "property"]),
  JSXNamespacedName: freeze(["namespace", "name"]),
  JSXOpeningElement: freeze(["name", "typeArguments", "attributes"]),
  JSXSpreadAttribute: freeze(["argument"]),
  JSXSpreadChild: freeze(["expression"]),
  TSAbstractAccessorProperty: freeze(["decorators", "key", "typeAnnotation"]),
  TSAbstractMethodDefinition: freeze(["key", "value"]),
  TSAbstractPropertyDefinition: freeze(["decorators", "key", "typeAnnotation"]),
  TSArrayType: freeze(["elementType"]),
  TSAsExpression: freeze(["expression", "typeAnnotation"]),
  TSCallSignatureDeclaration: freeze(["typeParameters", "params", "returnType"]),
  TSClassImplements: freeze(["expression", "typeArguments"]),
  TSConditionalType: freeze(["checkType", "extendsType", "trueType", "falseType"]),
  TSConstructSignatureDeclaration: freeze(["typeParameters", "params", "returnType"]),
  TSConstructorType: freeze(["typeParameters", "params", "returnType"]),
  TSDeclareFunction: freeze(["id", "typeParameters", "params", "returnType", "body"]),
  TSEmptyBodyFunctionExpression: freeze(["id", "typeParameters", "params", "returnType"]),
  TSEnumBody: freeze(["members"]),
  TSEnumDeclaration: freeze(["id", "body"]),
  TSEnumMember: freeze(["id", "initializer"]),
  TSExportAssignment: freeze(["expression"]),
  TSExternalModuleReference: freeze(["expression"]),
  TSFunctionType: freeze(["typeParameters", "params", "returnType"]),
  TSImportEqualsDeclaration: freeze(["id", "moduleReference"]),
  TSImportType: freeze(["argument", "options", "qualifier", "typeArguments"]),
  TSIndexSignature: freeze(["parameters", "typeAnnotation"]),
  TSIndexedAccessType: freeze(["objectType", "indexType"]),
  TSInferType: freeze(["typeParameter"]),
  TSInstantiationExpression: freeze(["expression", "typeArguments"]),
  TSInterfaceBody: freeze(["body"]),
  TSInterfaceDeclaration: freeze(["id", "typeParameters", "extends", "body"]),
  TSInterfaceHeritage: freeze(["expression", "typeArguments"]),
  TSIntersectionType: freeze(["types"]),
  TSJSDocNonNullableType: freeze(["typeAnnotation"]),
  TSJSDocNullableType: freeze(["typeAnnotation"]),
  TSLiteralType: freeze(["literal"]),
  TSMappedType: freeze(["key", "constraint", "nameType", "typeAnnotation"]),
  TSMethodSignature: freeze(["key", "typeParameters", "params", "returnType"]),
  TSModuleBlock: freeze(["body"]),
  TSModuleDeclaration: freeze(["id", "body"]),
  TSNamedTupleMember: freeze(["label", "elementType"]),
  TSNamespaceExportDeclaration: freeze(["id"]),
  TSNonNullExpression: freeze(["expression"]),
  TSOptionalType: freeze(["typeAnnotation"]),
  TSParameterProperty: freeze(["decorators", "parameter"]),
  TSParenthesizedType: freeze(["typeAnnotation"]),
  TSPropertySignature: freeze(["key", "typeAnnotation"]),
  TSQualifiedName: freeze(["left", "right"]),
  TSRestType: freeze(["typeAnnotation"]),
  TSSatisfiesExpression: freeze(["expression", "typeAnnotation"]),
  TSTemplateLiteralType: freeze(["quasis", "types"]),
  TSTupleType: freeze(["elementTypes"]),
  TSTypeAliasDeclaration: freeze(["id", "typeParameters", "typeAnnotation"]),
  TSTypeAnnotation: freeze(["typeAnnotation"]),
  TSTypeAssertion: freeze(["typeAnnotation", "expression"]),
  TSTypeLiteral: freeze(["members"]),
  TSTypeOperator: freeze(["typeAnnotation"]),
  TSTypeParameter: freeze(["name", "constraint", "default"]),
  TSTypeParameterDeclaration: freeze(["params"]),
  TSTypeParameterInstantiation: freeze(["params"]),
  TSTypePredicate: freeze(["parameterName", "typeAnnotation"]),
  TSTypeQuery: freeze(["exprName", "typeArguments"]),
  TSTypeReference: freeze(["typeName", "typeArguments"]),
  TSUnionType: freeze(["types"]),
});
