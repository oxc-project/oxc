//! ESTree deserialization support.
//!
//! This module provides the `FromESTree` trait and error types for deserializing
//! ESTree JSON into oxc AST nodes.
//!
//! The implementations for AST node types are generated by `ast_tools` in
//! `generated/derive_from_estree.rs`.

use std::fmt;

use oxc_allocator::Allocator;

mod primitives;

/// Error type for ESTree deserialization.
#[derive(Debug)]
pub enum DeserError {
    /// Expected an object but got something else
    ExpectedObject,
    /// Expected an array but got something else
    ExpectedArray,
    /// Expected a string but got something else
    ExpectedString,
    /// Expected a number but got something else
    ExpectedNumber,
    /// Expected a boolean but got something else
    ExpectedBool,
    /// Missing required `type` field in object
    MissingTypeField,
    /// Unknown node type encountered
    UnknownNodeType(String),
    /// Missing required field
    MissingField(&'static str),
    /// Invalid field value
    InvalidFieldValue(&'static str, String),
    /// Invalid span value
    InvalidSpan,
    /// The root node is not a recognized JavaScript AST node
    /// (e.g., JSON AST from eslint-plugin-jsonc).
    /// In this case, Rust rules should be skipped silently.
    NonJsAst(String),
    /// Generic parse error with custom message
    Custom(String),
}

impl fmt::Display for DeserError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ExpectedObject => write!(f, "expected object"),
            Self::ExpectedArray => write!(f, "expected array"),
            Self::ExpectedString => write!(f, "expected string"),
            Self::ExpectedNumber => write!(f, "expected number"),
            Self::ExpectedBool => write!(f, "expected boolean"),
            Self::MissingTypeField => write!(f, "missing `type` field"),
            Self::UnknownNodeType(ty) => write!(f, "unknown node type: {ty}"),
            Self::MissingField(field) => write!(f, "missing required field: {field}"),
            Self::InvalidFieldValue(field, msg) => {
                write!(f, "invalid value for field `{field}`: {msg}")
            }
            Self::InvalidSpan => write!(f, "invalid span"),
            Self::NonJsAst(root_type) => {
                write!(f, "non-JavaScript AST (root type: {root_type})")
            }
            Self::Custom(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for DeserError {}

/// Result type for ESTree deserialization.
pub type DeserResult<T> = Result<T, DeserError>;

/// Trait for types that can be deserialized from ESTree JSON.
///
/// This trait is the inverse of the `ESTree` trait (which serializes to ESTree JSON).
/// It's implemented for all AST node types via code generation in `ast_tools`.
pub trait FromESTree<'a>: Sized {
    /// Deserialize from a JSON value.
    ///
    /// # Arguments
    /// * `value` - The JSON value to deserialize
    /// * `allocator` - Arena allocator for AST nodes
    ///
    /// # Errors
    /// Returns `DeserError` if deserialization fails
    fn from_estree(value: &serde_json::Value, allocator: &'a Allocator) -> DeserResult<Self>;
}

/// Helper trait for extracting the ESTree `type` field from a JSON object.
pub trait ESTreeType {
    /// Get the `type` field from a JSON object.
    fn estree_type(&self) -> DeserResult<&str>;
}

impl ESTreeType for serde_json::Value {
    fn estree_type(&self) -> DeserResult<&str> {
        self.get("type").and_then(serde_json::Value::as_str).ok_or(DeserError::MissingTypeField)
    }
}

/// Helper trait for extracting fields from JSON objects.
pub trait ESTreeField {
    /// Get a required field from a JSON object.
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value>;

    /// Get an optional field from a JSON object.
    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value>;
}

impl ESTreeField for serde_json::Value {
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value> {
        self.get(name).ok_or(DeserError::MissingField(name))
    }

    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value> {
        self.get(name)
    }
}

/// Parse a span from ESTree JSON.
///
/// ESTree uses `start` and `end` properties for span information.
pub fn parse_span(value: &serde_json::Value) -> DeserResult<oxc_span::Span> {
    let start =
        value.get("start").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;
    let end =
        value.get("end").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;

    Ok(oxc_span::Span::new(
        u32::try_from(start).map_err(|_| DeserError::InvalidSpan)?,
        u32::try_from(end).map_err(|_| DeserError::InvalidSpan)?,
    ))
}

/// Parse a span from ESTree JSON, with a default of EMPTY if span fields are missing.
///
/// Some parsers may not provide span information for all nodes.
pub fn parse_span_or_empty(value: &serde_json::Value) -> oxc_span::Span {
    parse_span(value).unwrap_or(oxc_span::SPAN)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::literal::{BooleanLiteral, NullLiteral};

    #[test]
    fn test_boolean_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 0,
            "end": 4,
            "value": true
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, true);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 4);
    }

    #[test]
    fn test_null_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 10,
            "end": 14,
            "value": null
        });

        let result: NullLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.span.start, 10);
        assert_eq!(result.span.end, 14);
    }

    #[test]
    fn test_identifier_name() {
        use crate::ast::js::IdentifierName;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 0,
            "end": 3,
            "name": "foo"
        });

        let result: IdentifierName = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "foo");
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 3);
    }

    #[test]
    fn test_identifier_reference() {
        use crate::ast::js::IdentifierReference;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 5,
            "end": 8,
            "name": "bar"
        });

        let result: IdentifierReference = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "bar");
        assert_eq!(result.span.start, 5);
        assert_eq!(result.span.end, 8);
        // reference_id should be initialized to None (Cell::default())
        assert!(result.reference_id.get().is_none());
    }

    #[test]
    fn test_span_missing() {
        // Test that missing span fields default to SPAN (0, 0)
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "value": false
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, false);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 0);
    }
}
