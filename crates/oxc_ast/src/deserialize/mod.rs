//! ESTree deserialization support.
//!
//! This module provides the `FromESTree` trait and error types for deserializing
//! ESTree JSON into oxc AST nodes.
//!
//! The implementations for AST node types are generated by `ast_tools` in
//! `generated/derive_from_estree.rs`.

use std::cell::RefCell;
use std::fmt;

use oxc_allocator::Allocator;
use oxc_span::Span;

mod primitives;

// Thread-local storage for collecting unknown node spans during deserialization.
// When a union type (Expression, Statement, etc.) encounters an unknown node type,
// it records the span here before creating a placeholder node.
thread_local! {
    static UNKNOWN_NODE_SPANS: RefCell<Vec<Span>> = const { RefCell::new(Vec::new()) };
}

/// Record a span as belonging to an unknown node type.
///
/// This is called by generated deserialization code when it encounters a node type
/// that isn't recognized (e.g., `GlimmerTemplate`, `SvelteComponent`) and replaces
/// it with a placeholder node. The span is recorded so that later diagnostic
/// messages falling within these spans can be filtered out.
pub fn record_unknown_span(span: Span) {
    // Only record non-empty spans (span with 0,0 doesn't cover any source)
    if span.start != 0 || span.end != 0 {
        UNKNOWN_NODE_SPANS.with(|spans| {
            spans.borrow_mut().push(span);
        });
    }
}

/// Take all recorded unknown node spans, clearing the thread-local storage.
///
/// Call this after deserialization is complete to retrieve the spans of all
/// unknown nodes that were replaced with placeholders. These spans can be used
/// to filter out diagnostic messages that fall within custom syntax regions.
pub fn take_unknown_spans() -> Vec<Span> {
    UNKNOWN_NODE_SPANS.with(|spans| std::mem::take(&mut *spans.borrow_mut()))
}

/// Clear all recorded unknown node spans without returning them.
///
/// Call this before starting a new deserialization to ensure clean state.
pub fn clear_unknown_spans() {
    UNKNOWN_NODE_SPANS.with(|spans| spans.borrow_mut().clear());
}

/// Error type for ESTree deserialization.
#[derive(Debug)]
pub enum DeserError {
    /// Expected an object but got something else
    ExpectedObject,
    /// Expected an array but got something else
    ExpectedArray,
    /// Expected a string but got something else
    ExpectedString,
    /// Expected a number but got something else
    ExpectedNumber,
    /// Expected a boolean but got something else
    ExpectedBool,
    /// Missing required `type` field in object
    MissingTypeField,
    /// Unknown node type encountered
    UnknownNodeType(String),
    /// Missing required field
    MissingField(&'static str),
    /// Invalid field value
    InvalidFieldValue(&'static str, String),
    /// Invalid span value
    InvalidSpan,
    /// The root node is not a recognized JavaScript AST node
    /// (e.g., JSON AST from eslint-plugin-jsonc).
    /// In this case, Rust rules should be skipped silently.
    NonJsAst(String),
    /// Generic parse error with custom message
    Custom(String),
}

impl fmt::Display for DeserError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ExpectedObject => write!(f, "expected object"),
            Self::ExpectedArray => write!(f, "expected array"),
            Self::ExpectedString => write!(f, "expected string"),
            Self::ExpectedNumber => write!(f, "expected number"),
            Self::ExpectedBool => write!(f, "expected boolean"),
            Self::MissingTypeField => write!(f, "missing `type` field"),
            Self::UnknownNodeType(ty) => write!(f, "unknown node type: {ty}"),
            Self::MissingField(field) => write!(f, "missing required field: {field}"),
            Self::InvalidFieldValue(field, msg) => {
                write!(f, "invalid value for field `{field}`: {msg}")
            }
            Self::InvalidSpan => write!(f, "invalid span"),
            Self::NonJsAst(root_type) => {
                write!(f, "non-JavaScript AST (root type: {root_type})")
            }
            Self::Custom(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for DeserError {}

/// Result type for ESTree deserialization.
pub type DeserResult<T> = Result<T, DeserError>;

/// Trait for types that can be deserialized from ESTree JSON.
///
/// This trait is the inverse of the `ESTree` trait (which serializes to ESTree JSON).
/// It's implemented for all AST node types via code generation in `ast_tools`.
pub trait FromESTree<'a>: Sized {
    /// Deserialize from a JSON value.
    ///
    /// # Arguments
    /// * `value` - The JSON value to deserialize
    /// * `allocator` - Arena allocator for AST nodes
    ///
    /// # Errors
    /// Returns `DeserError` if deserialization fails
    fn from_estree(value: &serde_json::Value, allocator: &'a Allocator) -> DeserResult<Self>;
}

/// Helper trait for extracting the ESTree `type` field from a JSON object.
pub trait ESTreeType {
    /// Get the `type` field from a JSON object.
    fn estree_type(&self) -> DeserResult<&str>;
}

impl ESTreeType for serde_json::Value {
    fn estree_type(&self) -> DeserResult<&str> {
        self.get("type").and_then(serde_json::Value::as_str).ok_or(DeserError::MissingTypeField)
    }
}

/// Helper trait for extracting fields from JSON objects.
pub trait ESTreeField {
    /// Get a required field from a JSON object.
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value>;

    /// Get an optional field from a JSON object.
    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value>;
}

impl ESTreeField for serde_json::Value {
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value> {
        self.get(name).ok_or(DeserError::MissingField(name))
    }

    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value> {
        self.get(name)
    }
}

/// Trait for converter types that can deserialize a field from ESTree JSON.
///
/// This is the inverse of the `ESTree` serialization for `#[estree(via = ...)]` converters.
/// When a struct field has `#[estree(via = SomeConverter)]`, the converter type must implement
/// both `ESTree` (for serialization) and `FromESTreeConverter` (for deserialization).
///
/// The `Output` type is the type of the field being deserialized (e.g., `Option<Box<WithClause>>`).
pub trait FromESTreeConverter<'a> {
    /// The type that this converter produces when deserializing.
    type Output;

    /// Deserialize from a JSON value.
    ///
    /// # Arguments
    /// * `value` - The JSON value to deserialize (the ESTree representation)
    /// * `allocator` - Arena allocator for AST nodes
    ///
    /// # Errors
    /// Returns `DeserError` if deserialization fails
    fn from_estree_converter(
        value: &serde_json::Value,
        allocator: &'a Allocator,
    ) -> DeserResult<Self::Output>;
}

/// Parse a span from ESTree JSON.
///
/// ESTree parsers may use different formats for span information:
/// - `start` and `end` properties (ESLint format)
/// - `range` array with `[start, end]` (TypeScript ESLint format)
///
/// This function supports both formats.
pub fn parse_span(value: &serde_json::Value) -> DeserResult<oxc_span::Span> {
    // Try `range` array first (TypeScript ESLint format: [start, end])
    if let Some(range) = value.get("range").and_then(serde_json::Value::as_array) {
        if range.len() == 2 {
            let start = range[0].as_u64().ok_or(DeserError::InvalidSpan)?;
            let end = range[1].as_u64().ok_or(DeserError::InvalidSpan)?;
            return Ok(oxc_span::Span::new(
                u32::try_from(start).map_err(|_| DeserError::InvalidSpan)?,
                u32::try_from(end).map_err(|_| DeserError::InvalidSpan)?,
            ));
        }
    }

    // Fall back to `start`/`end` properties (ESLint format)
    let start =
        value.get("start").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;
    let end =
        value.get("end").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;

    Ok(oxc_span::Span::new(
        u32::try_from(start).map_err(|_| DeserError::InvalidSpan)?,
        u32::try_from(end).map_err(|_| DeserError::InvalidSpan)?,
    ))
}

/// Parse a span from ESTree JSON, with a default of EMPTY if span fields are missing.
///
/// Some parsers may not provide span information for all nodes.
pub fn parse_span_or_empty(value: &serde_json::Value) -> oxc_span::Span {
    parse_span(value).unwrap_or(oxc_span::SPAN)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::literal::{BooleanLiteral, NullLiteral};

    #[test]
    fn test_boolean_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 0,
            "end": 4,
            "value": true
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, true);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 4);
    }

    #[test]
    fn test_null_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 10,
            "end": 14,
            "value": null
        });

        let result: NullLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.span.start, 10);
        assert_eq!(result.span.end, 14);
    }

    #[test]
    fn test_identifier_name() {
        use crate::ast::js::IdentifierName;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 0,
            "end": 3,
            "name": "foo"
        });

        let result: IdentifierName = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "foo");
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 3);
    }

    #[test]
    fn test_identifier_reference() {
        use crate::ast::js::IdentifierReference;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 5,
            "end": 8,
            "name": "bar"
        });

        let result: IdentifierReference = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "bar");
        assert_eq!(result.span.start, 5);
        assert_eq!(result.span.end, 8);
        // reference_id should be initialized to None (Cell::default())
        assert!(result.reference_id.get().is_none());
    }

    #[test]
    fn test_span_missing() {
        // Test that missing span fields default to SPAN (0, 0)
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "value": false
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, false);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 0);
    }

    #[test]
    fn test_program_with_variable_declaration() {
        use crate::ast::js::Program;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Program",
            "body": [
                {
                    "type": "VariableDeclaration",
                    "kind": "var",
                    "start": 0,
                    "end": 7,
                    "declarations": [{
                        "type": "VariableDeclarator",
                        "start": 4,
                        "end": 7,
                        "id": {
                            "type": "Identifier",
                            "name": "foo",
                            "start": 4,
                            "end": 7
                        },
                        "init": null
                    }]
                }
            ],
            "sourceType": "script",
            "start": 0,
            "end": 8
        });

        let result: Program = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.body.len(), 1);
    }

    #[test]
    fn test_program_with_call_expression() {
        use crate::ast::js::Program;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Program",
            "body": [
                {
                    "type": "ExpressionStatement",
                    "start": 0,
                    "end": 20,
                    "expression": {
                        "type": "CallExpression",
                        "start": 0,
                        "end": 19,
                        "callee": {
                            "type": "Identifier",
                            "name": "console",
                            "start": 0,
                            "end": 7
                        },
                        "arguments": [
                            {
                                "type": "Identifier",
                                "name": "foo",
                                "start": 8,
                                "end": 11
                            }
                        ],
                        "optional": false
                    }
                }
            ],
            "sourceType": "script",
            "start": 0,
            "end": 20
        });

        let result: Program = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.body.len(), 1);
    }

    #[test]
    fn test_unknown_node_uses_placeholder() {
        use crate::ast::js::{Expression, Statement};

        let allocator = Allocator::default();

        // Unknown expression type should become NullLiteral placeholder
        let json = serde_json::json!({
            "type": "GlimmerTemplate",
            "start": 0,
            "end": 10
        });
        let result: Expression = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result, Expression::NullLiteral(_)));

        // Unknown statement type should become EmptyStatement placeholder
        let json = serde_json::json!({
            "type": "SvelteComponent",
            "start": 0,
            "end": 10
        });
        let result: Statement = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result, Statement::EmptyStatement(_)));
    }

    #[test]
    fn test_unknown_node_spans_recorded() {
        use crate::ast::js::{Expression, Statement};

        let allocator = Allocator::default();

        // Clear any previous spans
        clear_unknown_spans();

        // Deserialize an unknown expression - should record its span
        let json = serde_json::json!({
            "type": "GlimmerTemplate",
            "start": 10,
            "end": 50
        });
        let _: Expression = FromESTree::from_estree(&json, &allocator).unwrap();

        // Deserialize another unknown node (statement)
        let json = serde_json::json!({
            "type": "SvelteComponent",
            "start": 100,
            "end": 200
        });
        let _: Statement = FromESTree::from_estree(&json, &allocator).unwrap();

        // Take the recorded spans
        let spans = take_unknown_spans();

        // Should have recorded both spans
        assert_eq!(spans.len(), 2);
        assert_eq!(spans[0], Span::new(10, 50));
        assert_eq!(spans[1], Span::new(100, 200));

        // Taking again should return empty (was cleared)
        let spans = take_unknown_spans();
        assert!(spans.is_empty());
    }

    #[test]
    fn test_unknown_node_empty_span_not_recorded() {
        use crate::ast::js::Expression;

        let allocator = Allocator::default();

        // Clear any previous spans
        clear_unknown_spans();

        // Deserialize an unknown expression with no span info (will get 0,0)
        let json = serde_json::json!({
            "type": "GlimmerTemplate"
        });
        let _: Expression = FromESTree::from_estree(&json, &allocator).unwrap();

        // Take the recorded spans
        let spans = take_unknown_spans();

        // Empty span (0,0) should NOT be recorded
        assert!(spans.is_empty());
    }

    // =====================================================
    // TypeScript-specific deserialization tests
    // =====================================================
    // These test edge cases in TypeScript AST patterns that may fail
    // with custom JS parsers due to complex ESTree â†” oxc conversions.

    #[test]
    fn test_ts_enum_member_identifier() {
        use crate::ast::ts::{TSEnumMember, TSEnumMemberName};

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "TSEnumMember",
            "start": 0,
            "end": 10,
            "id": {
                "type": "Identifier",
                "name": "Foo",
                "start": 0,
                "end": 3
            },
            "initializer": null
        });

        let result: TSEnumMember = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result.id, TSEnumMemberName::Identifier(_)));
        if let TSEnumMemberName::Identifier(id) = &result.id {
            assert_eq!(id.name.as_str(), "Foo");
        }
    }

    #[test]
    fn test_ts_enum_member_computed_string() {
        use crate::ast::ts::{TSEnumMember, TSEnumMemberName};

        let allocator = Allocator::default();
        // Computed string enum member: enum E { ["computed-key"] = 1 }
        // In ESTree, computed string keys are represented as Literal with string value
        let json = serde_json::json!({
            "type": "TSEnumMember",
            "start": 0,
            "end": 20,
            "id": {
                "type": "Literal",
                "value": "computed-key",
                "start": 0,
                "end": 14
            },
            "initializer": {
                "type": "Literal",
                "value": 1,
                "start": 17,
                "end": 18
            }
        });

        let result: TSEnumMember = FromESTree::from_estree(&json, &allocator).unwrap();
        // String value literals in enum member IDs become TSEnumMemberName::ComputedString
        // This is the "computed" variant that raw_deser checks via `DESER[u8](POS_OFFSET.id) > 1`
        assert!(matches!(result.id, TSEnumMemberName::ComputedString(_)));
    }

    #[test]
    fn test_ts_call_signature_declaration_params() {
        use crate::ast::js::FormalParameterKind;
        use crate::ast::ts::TSCallSignatureDeclaration;

        let allocator = Allocator::default();
        // interface Foo { (x: number): void }
        let json = serde_json::json!({
            "type": "TSCallSignatureDeclaration",
            "start": 0,
            "end": 20,
            "params": [
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 1,
                    "end": 2,
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 2,
                        "end": 10,
                        "typeAnnotation": {
                            "type": "TSNumberKeyword",
                            "start": 4,
                            "end": 10
                        }
                    }
                }
            ],
            "returnType": {
                "type": "TSTypeAnnotation",
                "start": 12,
                "end": 18,
                "typeAnnotation": {
                    "type": "TSVoidKeyword",
                    "start": 14,
                    "end": 18
                }
            }
        });

        let result: TSCallSignatureDeclaration =
            FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.params.items.len(), 1);
        // Critical: params should use Signature kind to prevent no-unused-vars false positives
        assert_eq!(result.params.kind, FormalParameterKind::Signature);
    }

    #[test]
    fn test_ts_call_signature_with_this_param() {
        use crate::ast::js::FormalParameterKind;
        use crate::ast::ts::TSCallSignatureDeclaration;

        let allocator = Allocator::default();
        // interface Foo { (this: Window, x: number): void }
        // ESTree includes TSThisParameter in the params array
        let json = serde_json::json!({
            "type": "TSCallSignatureDeclaration",
            "start": 0,
            "end": 30,
            "params": [
                {
                    "type": "TSThisParameter",
                    "start": 1,
                    "end": 13,
                    "this": { "type": "Identifier", "name": "this", "start": 1, "end": 5 },
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 5,
                        "end": 13,
                        "typeAnnotation": {
                            "type": "TSTypeReference",
                            "start": 7,
                            "end": 13,
                            "typeName": { "type": "Identifier", "name": "Window", "start": 7, "end": 13 }
                        }
                    }
                },
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 15,
                    "end": 16,
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 16,
                        "end": 24,
                        "typeAnnotation": {
                            "type": "TSNumberKeyword",
                            "start": 18,
                            "end": 24
                        }
                    }
                }
            ],
            "returnType": null
        });

        let result: TSCallSignatureDeclaration =
            FromESTree::from_estree(&json, &allocator).unwrap();
        // TSThisParameter should be filtered out, leaving only the regular param
        assert_eq!(result.params.items.len(), 1);
        assert_eq!(result.params.kind, FormalParameterKind::Signature);
    }

    #[test]
    fn test_ts_constructor_type_params() {
        use crate::ast::js::FormalParameterKind;
        use crate::ast::ts::TSConstructorType;

        let allocator = Allocator::default();
        // type T = new (x: number) => Foo
        let json = serde_json::json!({
            "type": "TSConstructorType",
            "start": 0,
            "end": 25,
            "abstract": false,
            "params": [
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 5,
                    "end": 6,
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 6,
                        "end": 14,
                        "typeAnnotation": {
                            "type": "TSNumberKeyword",
                            "start": 8,
                            "end": 14
                        }
                    }
                }
            ],
            "returnType": {
                "type": "TSTypeAnnotation",
                "start": 18,
                "end": 25,
                "typeAnnotation": {
                    "type": "TSTypeReference",
                    "start": 21,
                    "end": 24,
                    "typeName": { "type": "Identifier", "name": "Foo", "start": 21, "end": 24 }
                }
            }
        });

        let result: TSConstructorType = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.params.items.len(), 1);
        // Constructor type params should also use Signature kind
        assert_eq!(result.params.kind, FormalParameterKind::Signature);
    }

    #[test]
    fn test_ts_class_implements_simple_identifier() {
        use crate::ast::ts::{TSClassImplements, TSTypeName};

        let allocator = Allocator::default();
        // class Foo implements Bar {}
        // ESTree represents `Bar` as an Identifier in `expression` field
        let json = serde_json::json!({
            "type": "TSClassImplements",
            "start": 0,
            "end": 10,
            "expression": {
                "type": "Identifier",
                "name": "Bar",
                "start": 0,
                "end": 3
            }
        });

        let result: TSClassImplements = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result.expression, TSTypeName::IdentifierReference(_)));
    }

    #[test]
    fn test_ts_class_implements_member_expression() {
        use crate::ast::ts::{TSClassImplements, TSTypeName};

        let allocator = Allocator::default();
        // class Foo implements A.B {}
        // ESTree represents `A.B` as MemberExpression, oxc uses TSQualifiedName
        let json = serde_json::json!({
            "type": "TSClassImplements",
            "start": 0,
            "end": 10,
            "expression": {
                "type": "MemberExpression",
                "start": 0,
                "end": 3,
                "object": {
                    "type": "Identifier",
                    "name": "A",
                    "start": 0,
                    "end": 1
                },
                "property": {
                    "type": "Identifier",
                    "name": "B",
                    "start": 2,
                    "end": 3
                },
                "computed": false,
                "optional": false
            }
        });

        let result: TSClassImplements = FromESTree::from_estree(&json, &allocator).unwrap();
        // Should convert MemberExpression to TSQualifiedName
        assert!(matches!(result.expression, TSTypeName::QualifiedName(_)));
    }

    #[test]
    fn test_ts_class_implements_nested_member_expression() {
        use crate::ast::ts::{TSClassImplements, TSTypeName};

        let allocator = Allocator::default();
        // class Foo implements A.B.C {}
        // Nested MemberExpressions should become nested TSQualifiedNames
        let json = serde_json::json!({
            "type": "TSClassImplements",
            "start": 0,
            "end": 5,
            "expression": {
                "type": "MemberExpression",
                "start": 0,
                "end": 5,
                "object": {
                    "type": "MemberExpression",
                    "start": 0,
                    "end": 3,
                    "object": {
                        "type": "Identifier",
                        "name": "A",
                        "start": 0,
                        "end": 1
                    },
                    "property": {
                        "type": "Identifier",
                        "name": "B",
                        "start": 2,
                        "end": 3
                    },
                    "computed": false,
                    "optional": false
                },
                "property": {
                    "type": "Identifier",
                    "name": "C",
                    "start": 4,
                    "end": 5
                },
                "computed": false,
                "optional": false
            }
        });

        let result: TSClassImplements = FromESTree::from_estree(&json, &allocator).unwrap();
        // Should have nested TSQualifiedName structure
        if let TSTypeName::QualifiedName(qn) = &result.expression {
            assert_eq!(qn.right.name.as_str(), "C");
            assert!(matches!(&qn.left, TSTypeName::QualifiedName(_)));
        } else {
            panic!("Expected TSQualifiedName");
        }
    }

    #[test]
    fn test_ts_module_declaration_simple() {
        use crate::ast::ts::{
            TSModuleDeclaration, TSModuleDeclarationKind, TSModuleDeclarationName,
        };

        let allocator = Allocator::default();
        // namespace Foo {}
        let json = serde_json::json!({
            "type": "TSModuleDeclaration",
            "start": 0,
            "end": 15,
            "id": {
                "type": "Identifier",
                "name": "Foo",
                "start": 10,
                "end": 13
            },
            "body": {
                "type": "TSModuleBlock",
                "start": 14,
                "end": 16,
                "body": []
            },
            "kind": "namespace",
            "declare": false,
            "global": false
        });

        let result: TSModuleDeclaration = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result.id, TSModuleDeclarationName::Identifier(_)));
        assert_eq!(result.kind, TSModuleDeclarationKind::Namespace);
        assert!(result.body.is_some());
    }

    #[test]
    fn test_ts_module_declaration_string_literal() {
        use crate::ast::ts::{
            TSModuleDeclaration, TSModuleDeclarationKind, TSModuleDeclarationName,
        };

        let allocator = Allocator::default();
        // module "foo" {}
        let json = serde_json::json!({
            "type": "TSModuleDeclaration",
            "start": 0,
            "end": 15,
            "id": {
                "type": "Literal",
                "value": "foo",
                "start": 7,
                "end": 12
            },
            "body": {
                "type": "TSModuleBlock",
                "start": 13,
                "end": 15,
                "body": []
            },
            "kind": "module",
            "declare": false,
            "global": false
        });

        let result: TSModuleDeclaration = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result.id, TSModuleDeclarationName::StringLiteral(_)));
        assert_eq!(result.kind, TSModuleDeclarationKind::Module);
    }

    #[test]
    fn test_ts_mapped_type_optional_false() {
        use crate::serialize::ts::TSMappedTypeOptional;

        let allocator = Allocator::default();

        // optional: false means no modifier
        let value = serde_json::json!(false);
        let result: Option<crate::ast::ts::TSMappedTypeModifierOperator> =
            TSMappedTypeOptional::from_estree_converter(&value, &allocator).unwrap();
        assert!(result.is_none());
    }

    #[test]
    fn test_ts_mapped_type_optional_true() {
        use crate::ast::ts::TSMappedTypeModifierOperator;
        use crate::serialize::ts::TSMappedTypeOptional;

        let allocator = Allocator::default();

        // optional: true means the ? modifier exists
        let value = serde_json::json!(true);
        let result: Option<TSMappedTypeModifierOperator> =
            TSMappedTypeOptional::from_estree_converter(&value, &allocator).unwrap();
        assert_eq!(result, Some(TSMappedTypeModifierOperator::True));
    }

    #[test]
    fn test_ts_mapped_type_optional_plus() {
        use crate::ast::ts::TSMappedTypeModifierOperator;
        use crate::serialize::ts::TSMappedTypeOptional;

        let allocator = Allocator::default();

        // optional: "+" means +? modifier
        let value = serde_json::json!("+");
        let result: Option<TSMappedTypeModifierOperator> =
            TSMappedTypeOptional::from_estree_converter(&value, &allocator).unwrap();
        assert_eq!(result, Some(TSMappedTypeModifierOperator::Plus));
    }

    #[test]
    fn test_ts_mapped_type_optional_minus() {
        use crate::ast::ts::TSMappedTypeModifierOperator;
        use crate::serialize::ts::TSMappedTypeOptional;

        let allocator = Allocator::default();

        // optional: "-" means -? modifier
        let value = serde_json::json!("-");
        let result: Option<TSMappedTypeModifierOperator> =
            TSMappedTypeOptional::from_estree_converter(&value, &allocator).unwrap();
        assert_eq!(result, Some(TSMappedTypeModifierOperator::Minus));
    }

    #[test]
    fn test_arrow_function_params_simple() {
        use crate::ast::js::ArrowFunctionExpression;

        let allocator = Allocator::default();
        // (x) => x
        let json = serde_json::json!({
            "type": "ArrowFunctionExpression",
            "start": 0,
            "end": 8,
            "expression": true,
            "async": false,
            "params": [
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 1,
                    "end": 2
                }
            ],
            "body": {
                "type": "Identifier",
                "name": "x",
                "start": 7,
                "end": 8
            }
        });

        let result: ArrowFunctionExpression = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.params.items.len(), 1);
        assert!(result.expression);
    }

    #[test]
    fn test_arrow_function_params_with_rest() {
        use crate::ast::js::ArrowFunctionExpression;

        let allocator = Allocator::default();
        // (...args) => args
        let json = serde_json::json!({
            "type": "ArrowFunctionExpression",
            "start": 0,
            "end": 16,
            "expression": true,
            "async": false,
            "params": [
                {
                    "type": "RestElement",
                    "start": 1,
                    "end": 8,
                    "argument": {
                        "type": "Identifier",
                        "name": "args",
                        "start": 4,
                        "end": 8
                    }
                }
            ],
            "body": {
                "type": "Identifier",
                "name": "args",
                "start": 13,
                "end": 17
            }
        });

        let result: ArrowFunctionExpression = FromESTree::from_estree(&json, &allocator).unwrap();
        // RestElement should be stored in params.rest, not params.items
        assert_eq!(result.params.items.len(), 0);
        assert!(result.params.rest.is_some());
    }

    #[test]
    fn test_arrow_function_params_with_regular_and_rest() {
        use crate::ast::js::ArrowFunctionExpression;

        let allocator = Allocator::default();
        // (a, b, ...rest) => [a, b, ...rest]
        let json = serde_json::json!({
            "type": "ArrowFunctionExpression",
            "start": 0,
            "end": 30,
            "expression": true,
            "async": false,
            "params": [
                {
                    "type": "Identifier",
                    "name": "a",
                    "start": 1,
                    "end": 2
                },
                {
                    "type": "Identifier",
                    "name": "b",
                    "start": 4,
                    "end": 5
                },
                {
                    "type": "RestElement",
                    "start": 7,
                    "end": 14,
                    "argument": {
                        "type": "Identifier",
                        "name": "rest",
                        "start": 10,
                        "end": 14
                    }
                }
            ],
            "body": {
                "type": "ArrayExpression",
                "start": 19,
                "end": 30,
                "elements": []
            }
        });

        let result: ArrowFunctionExpression = FromESTree::from_estree(&json, &allocator).unwrap();
        // Regular params go in items, rest goes in rest field
        assert_eq!(result.params.items.len(), 2);
        assert!(result.params.rest.is_some());
    }

    #[test]
    fn test_arrow_function_block_body() {
        use crate::ast::js::ArrowFunctionExpression;

        let allocator = Allocator::default();
        // (x) => { return x; }
        let json = serde_json::json!({
            "type": "ArrowFunctionExpression",
            "start": 0,
            "end": 20,
            "expression": false,
            "async": false,
            "params": [
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 1,
                    "end": 2
                }
            ],
            "body": {
                "type": "BlockStatement",
                "start": 7,
                "end": 20,
                "body": [
                    {
                        "type": "ReturnStatement",
                        "start": 9,
                        "end": 18,
                        "argument": {
                            "type": "Identifier",
                            "name": "x",
                            "start": 16,
                            "end": 17
                        }
                    }
                ]
            }
        });

        let result: ArrowFunctionExpression = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(!result.expression);
        assert_eq!(result.body.statements.len(), 1);
    }

    #[test]
    fn test_arrow_function_with_typescript_annotations() {
        use crate::ast::js::ArrowFunctionExpression;

        let allocator = Allocator::default();
        // (x: number): number => x
        let json = serde_json::json!({
            "type": "ArrowFunctionExpression",
            "start": 0,
            "end": 24,
            "expression": true,
            "async": false,
            "params": [
                {
                    "type": "Identifier",
                    "name": "x",
                    "start": 1,
                    "end": 2,
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 2,
                        "end": 10,
                        "typeAnnotation": {
                            "type": "TSNumberKeyword",
                            "start": 4,
                            "end": 10
                        }
                    }
                }
            ],
            "returnType": {
                "type": "TSTypeAnnotation",
                "start": 11,
                "end": 19,
                "typeAnnotation": {
                    "type": "TSNumberKeyword",
                    "start": 13,
                    "end": 19
                }
            },
            "body": {
                "type": "Identifier",
                "name": "x",
                "start": 23,
                "end": 24
            }
        });

        let result: ArrowFunctionExpression = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.params.items.len(), 1);
        assert!(result.return_type.is_some());
    }
}

#[test]
fn test_binding_property_shorthand() {
    use crate::ast::js::Program;

    let allocator = Allocator::default();
    // ESTree representation of: const { a } = x;
    let json = serde_json::json!({
        "type": "Program",
        "sourceType": "module",
        "start": 0,
        "end": 17,
        "body": [{
            "type": "VariableDeclaration",
            "kind": "const",
            "start": 0,
            "end": 17,
            "declarations": [{
                "type": "VariableDeclarator",
                "start": 6,
                "end": 16,
                "id": {
                    "type": "ObjectPattern",
                    "start": 6,
                    "end": 11,
                    "properties": [{
                        "type": "Property",
                        "start": 8,
                        "end": 9,
                        "key": {
                            "type": "Identifier",
                            "name": "a",
                            "start": 8,
                            "end": 9
                        },
                        "value": {
                            "type": "Identifier",
                            "name": "a",
                            "start": 8,
                            "end": 9
                        },
                        "kind": "init",
                        "method": false,
                        "shorthand": true,
                        "computed": false
                    }]
                },
                "init": {
                    "type": "Identifier",
                    "name": "x",
                    "start": 14,
                    "end": 15
                }
            }]
        }]
    });

    let result: Result<Program, _> = FromESTree::from_estree(&json, &allocator);
    assert!(result.is_ok(), "Failed to deserialize: {:?}", result.err());
}

#[test]
fn test_binding_property_non_shorthand() {
    use crate::ast::js::Program;

    let allocator = Allocator::default();
    // ESTree representation of: const { b: c } = x;
    let json = serde_json::json!({
        "type": "Program",
        "sourceType": "module",
        "start": 0,
        "end": 20,
        "body": [{
            "type": "VariableDeclaration",
            "kind": "const",
            "start": 0,
            "end": 20,
            "declarations": [{
                "type": "VariableDeclarator",
                "start": 6,
                "end": 19,
                "id": {
                    "type": "ObjectPattern",
                    "start": 6,
                    "end": 14,
                    "properties": [{
                        "type": "Property",
                        "start": 8,
                        "end": 12,
                        "key": {
                            "type": "Identifier",
                            "name": "b",
                            "start": 8,
                            "end": 9
                        },
                        "value": {
                            "type": "Identifier",
                            "name": "c",
                            "start": 11,
                            "end": 12
                        },
                        "kind": "init",
                        "method": false,
                        "shorthand": false,
                        "computed": false
                    }]
                },
                "init": {
                    "type": "Identifier",
                    "name": "x",
                    "start": 17,
                    "end": 18
                }
            }]
        }]
    });

    let result: Result<Program, _> = FromESTree::from_estree(&json, &allocator);
    assert!(result.is_ok(), "Failed to deserialize: {:?}", result.err());
}

#[test]
fn test_ts_property_signature() {
    use crate::ast::js::Program;

    let allocator = Allocator::default();
    // ESTree representation of: type Foo = { bar: string };
    let json = serde_json::json!({
        "type": "Program",
        "sourceType": "module",
        "start": 0,
        "end": 26,
        "body": [{
            "type": "TSTypeAliasDeclaration",
            "start": 0,
            "end": 26,
            "declare": false,
            "id": {
                "type": "Identifier",
                "name": "Foo",
                "start": 5,
                "end": 8
            },
            "typeAnnotation": {
                "type": "TSTypeLiteral",
                "start": 11,
                "end": 26,
                "members": [{
                    "type": "TSPropertySignature",
                    "start": 13,
                    "end": 24,
                    "computed": false,
                    "optional": false,
                    "readonly": false,
                    "key": {
                        "type": "Identifier",
                        "name": "bar",
                        "start": 13,
                        "end": 16
                    },
                    "typeAnnotation": {
                        "type": "TSTypeAnnotation",
                        "start": 16,
                        "end": 24,
                        "typeAnnotation": {
                            "type": "TSStringKeyword",
                            "start": 18,
                            "end": 24
                        }
                    }
                }]
            }
        }]
    });

    let result: Result<Program, _> = FromESTree::from_estree(&json, &allocator);
    assert!(result.is_ok(), "Failed to deserialize: {:?}", result.err());
}

/// Test ObjectPattern with RestElement - the rest element should be extracted
/// from the properties array and placed in the `rest` field.
/// This tests the `#[estree(append_to = properties)]` deserialization.
#[test]
fn test_object_pattern_with_rest_element() {
    use crate::ast::js::Program;

    let allocator = Allocator::default();
    // ESTree representation of: const { a, ...rest } = x;
    // Note: The RestElement is inside the properties array in ESTree,
    // but oxc AST has it in a separate `rest` field.
    let json = serde_json::json!({
        "type": "Program",
        "sourceType": "module",
        "start": 0,
        "end": 25,
        "body": [{
            "type": "VariableDeclaration",
            "kind": "const",
            "start": 0,
            "end": 25,
            "declarations": [{
                "type": "VariableDeclarator",
                "start": 6,
                "end": 24,
                "id": {
                    "type": "ObjectPattern",
                    "start": 6,
                    "end": 19,
                    "properties": [
                        {
                            "type": "Property",
                            "start": 8,
                            "end": 9,
                            "key": {
                                "type": "Identifier",
                                "name": "a",
                                "start": 8,
                                "end": 9
                            },
                            "value": {
                                "type": "Identifier",
                                "name": "a",
                                "start": 8,
                                "end": 9
                            },
                            "kind": "init",
                            "method": false,
                            "shorthand": true,
                            "computed": false
                        },
                        {
                            "type": "RestElement",
                            "start": 11,
                            "end": 18,
                            "argument": {
                                "type": "Identifier",
                                "name": "rest",
                                "start": 14,
                                "end": 18
                            }
                        }
                    ]
                },
                "init": {
                    "type": "Identifier",
                    "name": "x",
                    "start": 22,
                    "end": 23
                }
            }]
        }]
    });

    let result: Result<Program, _> = FromESTree::from_estree(&json, &allocator);
    assert!(
        result.is_ok(),
        "Failed to deserialize ObjectPattern with RestElement: {:?}",
        result.err()
    );

    // Also verify the structure is correct
    let program = result.unwrap();
    let stmt = &program.body[0];
    if let crate::ast::js::Statement::VariableDeclaration(decl) = stmt {
        let declarator = &decl.declarations[0];
        if let crate::ast::js::BindingPattern::ObjectPattern(pattern) = &declarator.id {
            // Should have 1 property (the shorthand 'a')
            assert_eq!(pattern.properties.len(), 1, "Expected 1 property");
            // Should have the rest element
            assert!(pattern.rest.is_some(), "Expected rest element to be set");
        } else {
            panic!("Expected ObjectPattern");
        }
    } else {
        panic!("Expected VariableDeclaration");
    }
}
