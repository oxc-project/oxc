//! ESTree deserialization support.
//!
//! This module provides the `FromESTree` trait and error types for deserializing
//! ESTree JSON into oxc AST nodes.
//!
//! The implementations for AST node types are generated by `ast_tools` in
//! `generated/derive_from_estree.rs`.

use std::cell::RefCell;
use std::fmt;

use oxc_allocator::Allocator;
use oxc_span::Span;

mod primitives;

// Thread-local storage for collecting unknown node spans during deserialization.
// When a union type (Expression, Statement, etc.) encounters an unknown node type,
// it records the span here before creating a placeholder node.
thread_local! {
    static UNKNOWN_NODE_SPANS: RefCell<Vec<Span>> = const { RefCell::new(Vec::new()) };
}

/// Record a span as belonging to an unknown node type.
///
/// This is called by generated deserialization code when it encounters a node type
/// that isn't recognized (e.g., `GlimmerTemplate`, `SvelteComponent`) and replaces
/// it with a placeholder node. The span is recorded so that later diagnostic
/// messages falling within these spans can be filtered out.
pub fn record_unknown_span(span: Span) {
    // Only record non-empty spans (span with 0,0 doesn't cover any source)
    if span.start != 0 || span.end != 0 {
        UNKNOWN_NODE_SPANS.with(|spans| {
            spans.borrow_mut().push(span);
        });
    }
}

/// Take all recorded unknown node spans, clearing the thread-local storage.
///
/// Call this after deserialization is complete to retrieve the spans of all
/// unknown nodes that were replaced with placeholders. These spans can be used
/// to filter out diagnostic messages that fall within custom syntax regions.
pub fn take_unknown_spans() -> Vec<Span> {
    UNKNOWN_NODE_SPANS.with(|spans| std::mem::take(&mut *spans.borrow_mut()))
}

/// Clear all recorded unknown node spans without returning them.
///
/// Call this before starting a new deserialization to ensure clean state.
pub fn clear_unknown_spans() {
    UNKNOWN_NODE_SPANS.with(|spans| spans.borrow_mut().clear());
}

/// Error type for ESTree deserialization.
#[derive(Debug)]
pub enum DeserError {
    /// Expected an object but got something else
    ExpectedObject,
    /// Expected an array but got something else
    ExpectedArray,
    /// Expected a string but got something else
    ExpectedString,
    /// Expected a number but got something else
    ExpectedNumber,
    /// Expected a boolean but got something else
    ExpectedBool,
    /// Missing required `type` field in object
    MissingTypeField,
    /// Unknown node type encountered
    UnknownNodeType(String),
    /// Missing required field
    MissingField(&'static str),
    /// Invalid field value
    InvalidFieldValue(&'static str, String),
    /// Invalid span value
    InvalidSpan,
    /// The root node is not a recognized JavaScript AST node
    /// (e.g., JSON AST from eslint-plugin-jsonc).
    /// In this case, Rust rules should be skipped silently.
    NonJsAst(String),
    /// Generic parse error with custom message
    Custom(String),
}

impl fmt::Display for DeserError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ExpectedObject => write!(f, "expected object"),
            Self::ExpectedArray => write!(f, "expected array"),
            Self::ExpectedString => write!(f, "expected string"),
            Self::ExpectedNumber => write!(f, "expected number"),
            Self::ExpectedBool => write!(f, "expected boolean"),
            Self::MissingTypeField => write!(f, "missing `type` field"),
            Self::UnknownNodeType(ty) => write!(f, "unknown node type: {ty}"),
            Self::MissingField(field) => write!(f, "missing required field: {field}"),
            Self::InvalidFieldValue(field, msg) => {
                write!(f, "invalid value for field `{field}`: {msg}")
            }
            Self::InvalidSpan => write!(f, "invalid span"),
            Self::NonJsAst(root_type) => {
                write!(f, "non-JavaScript AST (root type: {root_type})")
            }
            Self::Custom(msg) => write!(f, "{msg}"),
        }
    }
}

impl std::error::Error for DeserError {}

/// Result type for ESTree deserialization.
pub type DeserResult<T> = Result<T, DeserError>;

/// Trait for types that can be deserialized from ESTree JSON.
///
/// This trait is the inverse of the `ESTree` trait (which serializes to ESTree JSON).
/// It's implemented for all AST node types via code generation in `ast_tools`.
pub trait FromESTree<'a>: Sized {
    /// Deserialize from a JSON value.
    ///
    /// # Arguments
    /// * `value` - The JSON value to deserialize
    /// * `allocator` - Arena allocator for AST nodes
    ///
    /// # Errors
    /// Returns `DeserError` if deserialization fails
    fn from_estree(value: &serde_json::Value, allocator: &'a Allocator) -> DeserResult<Self>;
}

/// Helper trait for extracting the ESTree `type` field from a JSON object.
pub trait ESTreeType {
    /// Get the `type` field from a JSON object.
    fn estree_type(&self) -> DeserResult<&str>;
}

impl ESTreeType for serde_json::Value {
    fn estree_type(&self) -> DeserResult<&str> {
        self.get("type").and_then(serde_json::Value::as_str).ok_or(DeserError::MissingTypeField)
    }
}

/// Helper trait for extracting fields from JSON objects.
pub trait ESTreeField {
    /// Get a required field from a JSON object.
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value>;

    /// Get an optional field from a JSON object.
    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value>;
}

impl ESTreeField for serde_json::Value {
    fn estree_field(&self, name: &'static str) -> DeserResult<&serde_json::Value> {
        self.get(name).ok_or(DeserError::MissingField(name))
    }

    fn estree_field_opt(&self, name: &str) -> Option<&serde_json::Value> {
        self.get(name)
    }
}

/// Trait for converter types that can deserialize a field from ESTree JSON.
///
/// This is the inverse of the `ESTree` serialization for `#[estree(via = ...)]` converters.
/// When a struct field has `#[estree(via = SomeConverter)]`, the converter type must implement
/// both `ESTree` (for serialization) and `FromESTreeConverter` (for deserialization).
///
/// The `Output` type is the type of the field being deserialized (e.g., `Option<Box<WithClause>>`).
pub trait FromESTreeConverter<'a> {
    /// The type that this converter produces when deserializing.
    type Output;

    /// Deserialize from a JSON value.
    ///
    /// # Arguments
    /// * `value` - The JSON value to deserialize (the ESTree representation)
    /// * `allocator` - Arena allocator for AST nodes
    ///
    /// # Errors
    /// Returns `DeserError` if deserialization fails
    fn from_estree_converter(
        value: &serde_json::Value,
        allocator: &'a Allocator,
    ) -> DeserResult<Self::Output>;
}

/// Parse a span from ESTree JSON.
///
/// ESTree parsers may use different formats for span information:
/// - `start` and `end` properties (ESLint format)
/// - `range` array with `[start, end]` (TypeScript ESLint format)
///
/// This function supports both formats.
pub fn parse_span(value: &serde_json::Value) -> DeserResult<oxc_span::Span> {
    // Try `range` array first (TypeScript ESLint format: [start, end])
    if let Some(range) = value.get("range").and_then(serde_json::Value::as_array) {
        if range.len() == 2 {
            let start = range[0].as_u64().ok_or(DeserError::InvalidSpan)?;
            let end = range[1].as_u64().ok_or(DeserError::InvalidSpan)?;
            return Ok(oxc_span::Span::new(
                u32::try_from(start).map_err(|_| DeserError::InvalidSpan)?,
                u32::try_from(end).map_err(|_| DeserError::InvalidSpan)?,
            ));
        }
    }

    // Fall back to `start`/`end` properties (ESLint format)
    let start =
        value.get("start").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;
    let end =
        value.get("end").and_then(serde_json::Value::as_u64).ok_or(DeserError::InvalidSpan)?;

    Ok(oxc_span::Span::new(
        u32::try_from(start).map_err(|_| DeserError::InvalidSpan)?,
        u32::try_from(end).map_err(|_| DeserError::InvalidSpan)?,
    ))
}

/// Parse a span from ESTree JSON, with a default of EMPTY if span fields are missing.
///
/// Some parsers may not provide span information for all nodes.
pub fn parse_span_or_empty(value: &serde_json::Value) -> oxc_span::Span {
    parse_span(value).unwrap_or(oxc_span::SPAN)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ast::literal::{BooleanLiteral, NullLiteral};

    #[test]
    fn test_boolean_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 0,
            "end": 4,
            "value": true
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, true);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 4);
    }

    #[test]
    fn test_null_literal() {
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "start": 10,
            "end": 14,
            "value": null
        });

        let result: NullLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.span.start, 10);
        assert_eq!(result.span.end, 14);
    }

    #[test]
    fn test_identifier_name() {
        use crate::ast::js::IdentifierName;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 0,
            "end": 3,
            "name": "foo"
        });

        let result: IdentifierName = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "foo");
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 3);
    }

    #[test]
    fn test_identifier_reference() {
        use crate::ast::js::IdentifierReference;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Identifier",
            "start": 5,
            "end": 8,
            "name": "bar"
        });

        let result: IdentifierReference = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.name.as_str(), "bar");
        assert_eq!(result.span.start, 5);
        assert_eq!(result.span.end, 8);
        // reference_id should be initialized to None (Cell::default())
        assert!(result.reference_id.get().is_none());
    }

    #[test]
    fn test_span_missing() {
        // Test that missing span fields default to SPAN (0, 0)
        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Literal",
            "value": false
        });

        let result: BooleanLiteral = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.value, false);
        assert_eq!(result.span.start, 0);
        assert_eq!(result.span.end, 0);
    }

    #[test]
    fn test_program_with_variable_declaration() {
        use crate::ast::js::Program;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Program",
            "body": [
                {
                    "type": "VariableDeclaration",
                    "kind": "var",
                    "start": 0,
                    "end": 7,
                    "declarations": [{
                        "type": "VariableDeclarator",
                        "start": 4,
                        "end": 7,
                        "id": {
                            "type": "Identifier",
                            "name": "foo",
                            "start": 4,
                            "end": 7
                        },
                        "init": null
                    }]
                }
            ],
            "sourceType": "script",
            "start": 0,
            "end": 8
        });

        let result: Program = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.body.len(), 1);
    }

    #[test]
    fn test_program_with_call_expression() {
        use crate::ast::js::Program;

        let allocator = Allocator::default();
        let json = serde_json::json!({
            "type": "Program",
            "body": [
                {
                    "type": "ExpressionStatement",
                    "start": 0,
                    "end": 20,
                    "expression": {
                        "type": "CallExpression",
                        "start": 0,
                        "end": 19,
                        "callee": {
                            "type": "Identifier",
                            "name": "console",
                            "start": 0,
                            "end": 7
                        },
                        "arguments": [
                            {
                                "type": "Identifier",
                                "name": "foo",
                                "start": 8,
                                "end": 11
                            }
                        ],
                        "optional": false
                    }
                }
            ],
            "sourceType": "script",
            "start": 0,
            "end": 20
        });

        let result: Program = FromESTree::from_estree(&json, &allocator).unwrap();
        assert_eq!(result.body.len(), 1);
    }

    #[test]
    fn test_unknown_node_uses_placeholder() {
        use crate::ast::js::{Expression, Statement};

        let allocator = Allocator::default();

        // Unknown expression type should become NullLiteral placeholder
        let json = serde_json::json!({
            "type": "GlimmerTemplate",
            "start": 0,
            "end": 10
        });
        let result: Expression = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result, Expression::NullLiteral(_)));

        // Unknown statement type should become EmptyStatement placeholder
        let json = serde_json::json!({
            "type": "SvelteComponent",
            "start": 0,
            "end": 10
        });
        let result: Statement = FromESTree::from_estree(&json, &allocator).unwrap();
        assert!(matches!(result, Statement::EmptyStatement(_)));
    }

    #[test]
    fn test_unknown_node_spans_recorded() {
        use crate::ast::js::{Expression, Statement};

        let allocator = Allocator::default();

        // Clear any previous spans
        clear_unknown_spans();

        // Deserialize an unknown expression - should record its span
        let json = serde_json::json!({
            "type": "GlimmerTemplate",
            "start": 10,
            "end": 50
        });
        let _: Expression = FromESTree::from_estree(&json, &allocator).unwrap();

        // Deserialize another unknown node (statement)
        let json = serde_json::json!({
            "type": "SvelteComponent",
            "start": 100,
            "end": 200
        });
        let _: Statement = FromESTree::from_estree(&json, &allocator).unwrap();

        // Take the recorded spans
        let spans = take_unknown_spans();

        // Should have recorded both spans
        assert_eq!(spans.len(), 2);
        assert_eq!(spans[0], Span::new(10, 50));
        assert_eq!(spans[1], Span::new(100, 200));

        // Taking again should return empty (was cleared)
        let spans = take_unknown_spans();
        assert!(spans.is_empty());
    }

    #[test]
    fn test_unknown_node_empty_span_not_recorded() {
        use crate::ast::js::Expression;

        let allocator = Allocator::default();

        // Clear any previous spans
        clear_unknown_spans();

        // Deserialize an unknown expression with no span info (will get 0,0)
        let json = serde_json::json!({
            "type": "GlimmerTemplate"
        });
        let _: Expression = FromESTree::from_estree(&json, &allocator).unwrap();

        // Take the recorded spans
        let spans = take_unknown_spans();

        // Empty span (0,0) should NOT be recorded
        assert!(spans.is_empty());
    }
}
