---
source: crates/oxc_linter/src/tester.rs
expression: no_accumulating_spread
---
  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ Object.keys(obj).reduce((acc, key) => ({ ...acc, [key]: obj[key] }), {})
   ·                                          ──────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ arr.reduce((acc, x) => ({ ...acc, [x]: x }), {})
   ·                           ──────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ arr.reduce((differentName, x) => ({ ...differentName, [x]: x }), {})
   ·                                     ────────────────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ a.b.arr.reduce((acc, x) => ({ ...acc, [x]: x }), {})
   ·                               ──────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ get_array().reduce((acc, x) => ({ ...acc, [x]: x }), {})
   ·                                   ──────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ arr.reduce(function (acc, x) { return { ...acc, [x]: x } }, {})
   ·                                         ──────
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.

  ⚠ oxc(no-accumulating-spread): Do not spread accumulators in Array.prototype.reduce()
   ╭─[no_accumulating_spread.tsx:1:1]
 1 │ arr.reduce((acc, x) => {
 2 │             let temp = { ...acc, x }
   ·                          ──────
 3 │             return temp
   ╰────
  help: Consider using `Object.assign()` or `Array.prototype.concat()` to mutate the accumulator instead. Using spreads within accumulators leads to `O(n^2)` time complexity.


