// Generated by `scripts/build.mjs`.

#![allow(
    unsafe_code,
    clippy::missing_safety_doc,
    clippy::ptr_as_ptr,
    clippy::undocumented_unsafe_blocks,
    clippy::cast_ptr_alignment
)]

use std::cell::Cell;

use memoffset::offset_of;
use oxc_allocator::{Box, Vec};
#[allow(clippy::wildcard_imports)]
use oxc_ast::ast::*;
use oxc_span::{Atom, SourceType, Span};
use oxc_syntax::{
    operator::{
        AssignmentOperator, BinaryOperator, LogicalOperator, UnaryOperator, UpdateOperator,
    },
    scope::ScopeId,
};

/// Type of [`Ancestor`].
/// Used in [`crate::TraverseCtx::retag_stack`].
#[repr(u16)]
#[derive(Clone, Copy)]
#[allow(dead_code)]
pub(crate) enum AncestorType {
    None = 0,
    ProgramDirectives = 1,
    ProgramHashbang = 2,
    ProgramBody = 3,
    ArrayExpressionElements = 4,
    ObjectExpressionProperties = 5,
    ObjectPropertyKey = 6,
    ObjectPropertyValue = 7,
    ObjectPropertyInit = 8,
    TemplateLiteralQuasis = 9,
    TemplateLiteralExpressions = 10,
    TaggedTemplateExpressionTag = 11,
    TaggedTemplateExpressionQuasi = 12,
    TaggedTemplateExpressionTypeParameters = 13,
    ComputedMemberExpressionObject = 14,
    ComputedMemberExpressionExpression = 15,
    StaticMemberExpressionObject = 16,
    StaticMemberExpressionProperty = 17,
    PrivateFieldExpressionObject = 18,
    PrivateFieldExpressionField = 19,
    CallExpressionCallee = 20,
    CallExpressionArguments = 21,
    CallExpressionTypeParameters = 22,
    NewExpressionCallee = 23,
    NewExpressionArguments = 24,
    NewExpressionTypeParameters = 25,
    MetaPropertyMeta = 26,
    MetaPropertyProperty = 27,
    SpreadElementArgument = 28,
    UpdateExpressionArgument = 29,
    UnaryExpressionArgument = 30,
    BinaryExpressionLeft = 31,
    BinaryExpressionRight = 32,
    PrivateInExpressionLeft = 33,
    PrivateInExpressionRight = 34,
    LogicalExpressionLeft = 35,
    LogicalExpressionRight = 36,
    ConditionalExpressionTest = 37,
    ConditionalExpressionConsequent = 38,
    ConditionalExpressionAlternate = 39,
    AssignmentExpressionLeft = 40,
    AssignmentExpressionRight = 41,
    ArrayAssignmentTargetElements = 42,
    ArrayAssignmentTargetRest = 43,
    ObjectAssignmentTargetProperties = 44,
    ObjectAssignmentTargetRest = 45,
    AssignmentTargetRestTarget = 46,
    AssignmentTargetWithDefaultBinding = 47,
    AssignmentTargetWithDefaultInit = 48,
    AssignmentTargetPropertyIdentifierBinding = 49,
    AssignmentTargetPropertyIdentifierInit = 50,
    AssignmentTargetPropertyPropertyName = 51,
    AssignmentTargetPropertyPropertyBinding = 52,
    SequenceExpressionExpressions = 53,
    AwaitExpressionArgument = 54,
    ChainExpressionExpression = 55,
    ParenthesizedExpressionExpression = 56,
    DirectiveExpression = 57,
    BlockStatementBody = 58,
    VariableDeclarationDeclarations = 59,
    VariableDeclaratorId = 60,
    VariableDeclaratorInit = 61,
    UsingDeclarationDeclarations = 62,
    ExpressionStatementExpression = 63,
    IfStatementTest = 64,
    IfStatementConsequent = 65,
    IfStatementAlternate = 66,
    DoWhileStatementBody = 67,
    DoWhileStatementTest = 68,
    WhileStatementTest = 69,
    WhileStatementBody = 70,
    ForStatementInit = 71,
    ForStatementTest = 72,
    ForStatementUpdate = 73,
    ForStatementBody = 74,
    ForInStatementLeft = 75,
    ForInStatementRight = 76,
    ForInStatementBody = 77,
    ForOfStatementLeft = 78,
    ForOfStatementRight = 79,
    ForOfStatementBody = 80,
    ContinueStatementLabel = 81,
    BreakStatementLabel = 82,
    ReturnStatementArgument = 83,
    WithStatementObject = 84,
    WithStatementBody = 85,
    SwitchStatementDiscriminant = 86,
    SwitchStatementCases = 87,
    SwitchCaseTest = 88,
    SwitchCaseConsequent = 89,
    LabeledStatementLabel = 90,
    LabeledStatementBody = 91,
    ThrowStatementArgument = 92,
    TryStatementBlock = 93,
    TryStatementHandler = 94,
    TryStatementFinalizer = 95,
    CatchClauseParam = 96,
    CatchClauseBody = 97,
    CatchParameterPattern = 98,
    BindingPatternKind = 99,
    BindingPatternTypeAnnotation = 100,
    AssignmentPatternLeft = 101,
    AssignmentPatternRight = 102,
    ObjectPatternProperties = 103,
    ObjectPatternRest = 104,
    BindingPropertyKey = 105,
    BindingPropertyValue = 106,
    ArrayPatternElements = 107,
    ArrayPatternRest = 108,
    BindingRestElementArgument = 109,
    FunctionId = 110,
    FunctionTypeParameters = 111,
    FunctionThisParam = 112,
    FunctionParams = 113,
    FunctionBody = 114,
    FunctionReturnType = 115,
    FormalParametersItems = 116,
    FormalParametersRest = 117,
    FormalParameterPattern = 118,
    FormalParameterDecorators = 119,
    FunctionBodyDirectives = 120,
    FunctionBodyStatements = 121,
    ArrowFunctionExpressionParams = 122,
    ArrowFunctionExpressionBody = 123,
    ArrowFunctionExpressionTypeParameters = 124,
    ArrowFunctionExpressionReturnType = 125,
    YieldExpressionArgument = 126,
    ClassDecorators = 127,
    ClassId = 128,
    ClassSuperClass = 129,
    ClassBody = 130,
    ClassTypeParameters = 131,
    ClassSuperTypeParameters = 132,
    ClassImplements = 133,
    ClassBodyBody = 134,
    MethodDefinitionDecorators = 135,
    MethodDefinitionKey = 136,
    MethodDefinitionValue = 137,
    PropertyDefinitionKey = 138,
    PropertyDefinitionValue = 139,
    PropertyDefinitionTypeAnnotation = 140,
    PropertyDefinitionDecorators = 141,
    StaticBlockBody = 142,
    AccessorPropertyKey = 143,
    AccessorPropertyValue = 144,
    AccessorPropertyDecorators = 145,
    ImportExpressionSource = 146,
    ImportExpressionArguments = 147,
    ImportDeclarationSpecifiers = 148,
    ImportDeclarationSource = 149,
    ImportDeclarationWithClause = 150,
    ImportSpecifierImported = 151,
    ImportSpecifierLocal = 152,
    ImportDefaultSpecifierLocal = 153,
    ImportNamespaceSpecifierLocal = 154,
    WithClauseAttributesKeyword = 155,
    WithClauseWithEntries = 156,
    ImportAttributeKey = 157,
    ImportAttributeValue = 158,
    ExportNamedDeclarationDeclaration = 159,
    ExportNamedDeclarationSpecifiers = 160,
    ExportNamedDeclarationSource = 161,
    ExportNamedDeclarationWithClause = 162,
    ExportDefaultDeclarationDeclaration = 163,
    ExportDefaultDeclarationExported = 164,
    ExportAllDeclarationExported = 165,
    ExportAllDeclarationSource = 166,
    ExportAllDeclarationWithClause = 167,
    ExportSpecifierLocal = 168,
    ExportSpecifierExported = 169,
    JSXElementOpeningElement = 170,
    JSXElementClosingElement = 171,
    JSXElementChildren = 172,
    JSXOpeningElementName = 173,
    JSXOpeningElementAttributes = 174,
    JSXOpeningElementTypeParameters = 175,
    JSXClosingElementName = 176,
    JSXFragmentChildren = 177,
    JSXNamespacedNameNamespace = 178,
    JSXNamespacedNameProperty = 179,
    JSXMemberExpressionObject = 180,
    JSXMemberExpressionProperty = 181,
    JSXExpressionContainerExpression = 182,
    JSXAttributeName = 183,
    JSXAttributeValue = 184,
    JSXSpreadAttributeArgument = 185,
    JSXSpreadChildExpression = 186,
    TSThisParameterThis = 187,
    TSThisParameterTypeAnnotation = 188,
    TSEnumDeclarationId = 189,
    TSEnumDeclarationMembers = 190,
    TSEnumMemberId = 191,
    TSEnumMemberInitializer = 192,
    TSTypeAnnotationTypeAnnotation = 193,
    TSLiteralTypeLiteral = 194,
    TSConditionalTypeCheckType = 195,
    TSConditionalTypeExtendsType = 196,
    TSConditionalTypeTrueType = 197,
    TSConditionalTypeFalseType = 198,
    TSUnionTypeTypes = 199,
    TSIntersectionTypeTypes = 200,
    TSTypeOperatorTypeAnnotation = 201,
    TSArrayTypeElementType = 202,
    TSIndexedAccessTypeObjectType = 203,
    TSIndexedAccessTypeIndexType = 204,
    TSTupleTypeElementTypes = 205,
    TSNamedTupleMemberElementType = 206,
    TSNamedTupleMemberLabel = 207,
    TSOptionalTypeTypeAnnotation = 208,
    TSRestTypeTypeAnnotation = 209,
    TSTypeReferenceTypeName = 210,
    TSTypeReferenceTypeParameters = 211,
    TSQualifiedNameLeft = 212,
    TSQualifiedNameRight = 213,
    TSTypeParameterInstantiationParams = 214,
    TSTypeParameterName = 215,
    TSTypeParameterConstraint = 216,
    TSTypeParameterDefault = 217,
    TSTypeParameterDeclarationParams = 218,
    TSTypeAliasDeclarationId = 219,
    TSTypeAliasDeclarationTypeAnnotation = 220,
    TSTypeAliasDeclarationTypeParameters = 221,
    TSClassImplementsExpression = 222,
    TSClassImplementsTypeParameters = 223,
    TSInterfaceDeclarationId = 224,
    TSInterfaceDeclarationBody = 225,
    TSInterfaceDeclarationTypeParameters = 226,
    TSInterfaceDeclarationExtends = 227,
    TSInterfaceBodyBody = 228,
    TSPropertySignatureKey = 229,
    TSPropertySignatureTypeAnnotation = 230,
    TSIndexSignatureParameters = 231,
    TSIndexSignatureTypeAnnotation = 232,
    TSCallSignatureDeclarationThisParam = 233,
    TSCallSignatureDeclarationParams = 234,
    TSCallSignatureDeclarationReturnType = 235,
    TSCallSignatureDeclarationTypeParameters = 236,
    TSMethodSignatureKey = 237,
    TSMethodSignatureThisParam = 238,
    TSMethodSignatureParams = 239,
    TSMethodSignatureReturnType = 240,
    TSMethodSignatureTypeParameters = 241,
    TSConstructSignatureDeclarationParams = 242,
    TSConstructSignatureDeclarationReturnType = 243,
    TSConstructSignatureDeclarationTypeParameters = 244,
    TSIndexSignatureNameTypeAnnotation = 245,
    TSInterfaceHeritageExpression = 246,
    TSInterfaceHeritageTypeParameters = 247,
    TSTypePredicateParameterName = 248,
    TSTypePredicateTypeAnnotation = 249,
    TSModuleDeclarationId = 250,
    TSModuleDeclarationBody = 251,
    TSModuleBlockBody = 252,
    TSTypeLiteralMembers = 253,
    TSInferTypeTypeParameter = 254,
    TSTypeQueryExprName = 255,
    TSTypeQueryTypeParameters = 256,
    TSImportTypeArgument = 257,
    TSImportTypeQualifier = 258,
    TSImportTypeAttributes = 259,
    TSImportTypeTypeParameters = 260,
    TSImportAttributesElements = 261,
    TSImportAttributeName = 262,
    TSImportAttributeValue = 263,
    TSFunctionTypeThisParam = 264,
    TSFunctionTypeParams = 265,
    TSFunctionTypeReturnType = 266,
    TSFunctionTypeTypeParameters = 267,
    TSConstructorTypeParams = 268,
    TSConstructorTypeReturnType = 269,
    TSConstructorTypeTypeParameters = 270,
    TSMappedTypeTypeParameter = 271,
    TSMappedTypeNameType = 272,
    TSMappedTypeTypeAnnotation = 273,
    TSTemplateLiteralTypeQuasis = 274,
    TSTemplateLiteralTypeTypes = 275,
    TSAsExpressionExpression = 276,
    TSAsExpressionTypeAnnotation = 277,
    TSSatisfiesExpressionExpression = 278,
    TSSatisfiesExpressionTypeAnnotation = 279,
    TSTypeAssertionExpression = 280,
    TSTypeAssertionTypeAnnotation = 281,
    TSImportEqualsDeclarationId = 282,
    TSImportEqualsDeclarationModuleReference = 283,
    TSExternalModuleReferenceExpression = 284,
    TSNonNullExpressionExpression = 285,
    DecoratorExpression = 286,
    TSExportAssignmentExpression = 287,
    TSNamespaceExportDeclarationId = 288,
    TSInstantiationExpressionExpression = 289,
    TSInstantiationExpressionTypeParameters = 290,
    JSDocNullableTypeTypeAnnotation = 291,
}

/// Ancestor type used in AST traversal.
///
/// Encodes both the type of the parent, and child's location in the parent.
/// i.e. variants for `BinaryExpressionLeft` and `BinaryExpressionRight`, not just `BinaryExpression`.
//
// SAFETY:
// * This type must be `#[repr(u16)]`.
// * Variant discriminants must correspond to those in `AncestorType`.
//
// These invariants make it possible to set the discriminant of an `Ancestor` without altering
// the "payload" pointer with:
// `*(ancestor as *mut _ as *mut AncestorType) = AncestorType::Program`.
// `TraverseCtx::retag_stack` uses this technique.
#[repr(C, u16)]
#[derive(Debug)]
pub enum Ancestor<'a> {
    None = AncestorType::None as u16,
    ProgramDirectives(ProgramWithoutDirectives<'a>) = AncestorType::ProgramDirectives as u16,
    ProgramHashbang(ProgramWithoutHashbang<'a>) = AncestorType::ProgramHashbang as u16,
    ProgramBody(ProgramWithoutBody<'a>) = AncestorType::ProgramBody as u16,
    ArrayExpressionElements(ArrayExpressionWithoutElements<'a>) =
        AncestorType::ArrayExpressionElements as u16,
    ObjectExpressionProperties(ObjectExpressionWithoutProperties<'a>) =
        AncestorType::ObjectExpressionProperties as u16,
    ObjectPropertyKey(ObjectPropertyWithoutKey<'a>) = AncestorType::ObjectPropertyKey as u16,
    ObjectPropertyValue(ObjectPropertyWithoutValue<'a>) = AncestorType::ObjectPropertyValue as u16,
    ObjectPropertyInit(ObjectPropertyWithoutInit<'a>) = AncestorType::ObjectPropertyInit as u16,
    TemplateLiteralQuasis(TemplateLiteralWithoutQuasis<'a>) =
        AncestorType::TemplateLiteralQuasis as u16,
    TemplateLiteralExpressions(TemplateLiteralWithoutExpressions<'a>) =
        AncestorType::TemplateLiteralExpressions as u16,
    TaggedTemplateExpressionTag(TaggedTemplateExpressionWithoutTag<'a>) =
        AncestorType::TaggedTemplateExpressionTag as u16,
    TaggedTemplateExpressionQuasi(TaggedTemplateExpressionWithoutQuasi<'a>) =
        AncestorType::TaggedTemplateExpressionQuasi as u16,
    TaggedTemplateExpressionTypeParameters(TaggedTemplateExpressionWithoutTypeParameters<'a>) =
        AncestorType::TaggedTemplateExpressionTypeParameters as u16,
    ComputedMemberExpressionObject(ComputedMemberExpressionWithoutObject<'a>) =
        AncestorType::ComputedMemberExpressionObject as u16,
    ComputedMemberExpressionExpression(ComputedMemberExpressionWithoutExpression<'a>) =
        AncestorType::ComputedMemberExpressionExpression as u16,
    StaticMemberExpressionObject(StaticMemberExpressionWithoutObject<'a>) =
        AncestorType::StaticMemberExpressionObject as u16,
    StaticMemberExpressionProperty(StaticMemberExpressionWithoutProperty<'a>) =
        AncestorType::StaticMemberExpressionProperty as u16,
    PrivateFieldExpressionObject(PrivateFieldExpressionWithoutObject<'a>) =
        AncestorType::PrivateFieldExpressionObject as u16,
    PrivateFieldExpressionField(PrivateFieldExpressionWithoutField<'a>) =
        AncestorType::PrivateFieldExpressionField as u16,
    CallExpressionCallee(CallExpressionWithoutCallee<'a>) =
        AncestorType::CallExpressionCallee as u16,
    CallExpressionArguments(CallExpressionWithoutArguments<'a>) =
        AncestorType::CallExpressionArguments as u16,
    CallExpressionTypeParameters(CallExpressionWithoutTypeParameters<'a>) =
        AncestorType::CallExpressionTypeParameters as u16,
    NewExpressionCallee(NewExpressionWithoutCallee<'a>) = AncestorType::NewExpressionCallee as u16,
    NewExpressionArguments(NewExpressionWithoutArguments<'a>) =
        AncestorType::NewExpressionArguments as u16,
    NewExpressionTypeParameters(NewExpressionWithoutTypeParameters<'a>) =
        AncestorType::NewExpressionTypeParameters as u16,
    MetaPropertyMeta(MetaPropertyWithoutMeta<'a>) = AncestorType::MetaPropertyMeta as u16,
    MetaPropertyProperty(MetaPropertyWithoutProperty<'a>) =
        AncestorType::MetaPropertyProperty as u16,
    SpreadElementArgument(SpreadElementWithoutArgument<'a>) =
        AncestorType::SpreadElementArgument as u16,
    UpdateExpressionArgument(UpdateExpressionWithoutArgument<'a>) =
        AncestorType::UpdateExpressionArgument as u16,
    UnaryExpressionArgument(UnaryExpressionWithoutArgument<'a>) =
        AncestorType::UnaryExpressionArgument as u16,
    BinaryExpressionLeft(BinaryExpressionWithoutLeft<'a>) =
        AncestorType::BinaryExpressionLeft as u16,
    BinaryExpressionRight(BinaryExpressionWithoutRight<'a>) =
        AncestorType::BinaryExpressionRight as u16,
    PrivateInExpressionLeft(PrivateInExpressionWithoutLeft<'a>) =
        AncestorType::PrivateInExpressionLeft as u16,
    PrivateInExpressionRight(PrivateInExpressionWithoutRight<'a>) =
        AncestorType::PrivateInExpressionRight as u16,
    LogicalExpressionLeft(LogicalExpressionWithoutLeft<'a>) =
        AncestorType::LogicalExpressionLeft as u16,
    LogicalExpressionRight(LogicalExpressionWithoutRight<'a>) =
        AncestorType::LogicalExpressionRight as u16,
    ConditionalExpressionTest(ConditionalExpressionWithoutTest<'a>) =
        AncestorType::ConditionalExpressionTest as u16,
    ConditionalExpressionConsequent(ConditionalExpressionWithoutConsequent<'a>) =
        AncestorType::ConditionalExpressionConsequent as u16,
    ConditionalExpressionAlternate(ConditionalExpressionWithoutAlternate<'a>) =
        AncestorType::ConditionalExpressionAlternate as u16,
    AssignmentExpressionLeft(AssignmentExpressionWithoutLeft<'a>) =
        AncestorType::AssignmentExpressionLeft as u16,
    AssignmentExpressionRight(AssignmentExpressionWithoutRight<'a>) =
        AncestorType::AssignmentExpressionRight as u16,
    ArrayAssignmentTargetElements(ArrayAssignmentTargetWithoutElements<'a>) =
        AncestorType::ArrayAssignmentTargetElements as u16,
    ArrayAssignmentTargetRest(ArrayAssignmentTargetWithoutRest<'a>) =
        AncestorType::ArrayAssignmentTargetRest as u16,
    ObjectAssignmentTargetProperties(ObjectAssignmentTargetWithoutProperties<'a>) =
        AncestorType::ObjectAssignmentTargetProperties as u16,
    ObjectAssignmentTargetRest(ObjectAssignmentTargetWithoutRest<'a>) =
        AncestorType::ObjectAssignmentTargetRest as u16,
    AssignmentTargetRestTarget(AssignmentTargetRestWithoutTarget<'a>) =
        AncestorType::AssignmentTargetRestTarget as u16,
    AssignmentTargetWithDefaultBinding(AssignmentTargetWithDefaultWithoutBinding<'a>) =
        AncestorType::AssignmentTargetWithDefaultBinding as u16,
    AssignmentTargetWithDefaultInit(AssignmentTargetWithDefaultWithoutInit<'a>) =
        AncestorType::AssignmentTargetWithDefaultInit as u16,
    AssignmentTargetPropertyIdentifierBinding(AssignmentTargetPropertyIdentifierWithoutBinding<'a>) =
        AncestorType::AssignmentTargetPropertyIdentifierBinding as u16,
    AssignmentTargetPropertyIdentifierInit(AssignmentTargetPropertyIdentifierWithoutInit<'a>) =
        AncestorType::AssignmentTargetPropertyIdentifierInit as u16,
    AssignmentTargetPropertyPropertyName(AssignmentTargetPropertyPropertyWithoutName<'a>) =
        AncestorType::AssignmentTargetPropertyPropertyName as u16,
    AssignmentTargetPropertyPropertyBinding(AssignmentTargetPropertyPropertyWithoutBinding<'a>) =
        AncestorType::AssignmentTargetPropertyPropertyBinding as u16,
    SequenceExpressionExpressions(SequenceExpressionWithoutExpressions<'a>) =
        AncestorType::SequenceExpressionExpressions as u16,
    AwaitExpressionArgument(AwaitExpressionWithoutArgument<'a>) =
        AncestorType::AwaitExpressionArgument as u16,
    ChainExpressionExpression(ChainExpressionWithoutExpression<'a>) =
        AncestorType::ChainExpressionExpression as u16,
    ParenthesizedExpressionExpression(ParenthesizedExpressionWithoutExpression<'a>) =
        AncestorType::ParenthesizedExpressionExpression as u16,
    DirectiveExpression(DirectiveWithoutExpression<'a>) = AncestorType::DirectiveExpression as u16,
    BlockStatementBody(BlockStatementWithoutBody<'a>) = AncestorType::BlockStatementBody as u16,
    VariableDeclarationDeclarations(VariableDeclarationWithoutDeclarations<'a>) =
        AncestorType::VariableDeclarationDeclarations as u16,
    VariableDeclaratorId(VariableDeclaratorWithoutId<'a>) =
        AncestorType::VariableDeclaratorId as u16,
    VariableDeclaratorInit(VariableDeclaratorWithoutInit<'a>) =
        AncestorType::VariableDeclaratorInit as u16,
    UsingDeclarationDeclarations(UsingDeclarationWithoutDeclarations<'a>) =
        AncestorType::UsingDeclarationDeclarations as u16,
    ExpressionStatementExpression(ExpressionStatementWithoutExpression<'a>) =
        AncestorType::ExpressionStatementExpression as u16,
    IfStatementTest(IfStatementWithoutTest<'a>) = AncestorType::IfStatementTest as u16,
    IfStatementConsequent(IfStatementWithoutConsequent<'a>) =
        AncestorType::IfStatementConsequent as u16,
    IfStatementAlternate(IfStatementWithoutAlternate<'a>) =
        AncestorType::IfStatementAlternate as u16,
    DoWhileStatementBody(DoWhileStatementWithoutBody<'a>) =
        AncestorType::DoWhileStatementBody as u16,
    DoWhileStatementTest(DoWhileStatementWithoutTest<'a>) =
        AncestorType::DoWhileStatementTest as u16,
    WhileStatementTest(WhileStatementWithoutTest<'a>) = AncestorType::WhileStatementTest as u16,
    WhileStatementBody(WhileStatementWithoutBody<'a>) = AncestorType::WhileStatementBody as u16,
    ForStatementInit(ForStatementWithoutInit<'a>) = AncestorType::ForStatementInit as u16,
    ForStatementTest(ForStatementWithoutTest<'a>) = AncestorType::ForStatementTest as u16,
    ForStatementUpdate(ForStatementWithoutUpdate<'a>) = AncestorType::ForStatementUpdate as u16,
    ForStatementBody(ForStatementWithoutBody<'a>) = AncestorType::ForStatementBody as u16,
    ForInStatementLeft(ForInStatementWithoutLeft<'a>) = AncestorType::ForInStatementLeft as u16,
    ForInStatementRight(ForInStatementWithoutRight<'a>) = AncestorType::ForInStatementRight as u16,
    ForInStatementBody(ForInStatementWithoutBody<'a>) = AncestorType::ForInStatementBody as u16,
    ForOfStatementLeft(ForOfStatementWithoutLeft<'a>) = AncestorType::ForOfStatementLeft as u16,
    ForOfStatementRight(ForOfStatementWithoutRight<'a>) = AncestorType::ForOfStatementRight as u16,
    ForOfStatementBody(ForOfStatementWithoutBody<'a>) = AncestorType::ForOfStatementBody as u16,
    ContinueStatementLabel(ContinueStatementWithoutLabel<'a>) =
        AncestorType::ContinueStatementLabel as u16,
    BreakStatementLabel(BreakStatementWithoutLabel<'a>) = AncestorType::BreakStatementLabel as u16,
    ReturnStatementArgument(ReturnStatementWithoutArgument<'a>) =
        AncestorType::ReturnStatementArgument as u16,
    WithStatementObject(WithStatementWithoutObject<'a>) = AncestorType::WithStatementObject as u16,
    WithStatementBody(WithStatementWithoutBody<'a>) = AncestorType::WithStatementBody as u16,
    SwitchStatementDiscriminant(SwitchStatementWithoutDiscriminant<'a>) =
        AncestorType::SwitchStatementDiscriminant as u16,
    SwitchStatementCases(SwitchStatementWithoutCases<'a>) =
        AncestorType::SwitchStatementCases as u16,
    SwitchCaseTest(SwitchCaseWithoutTest<'a>) = AncestorType::SwitchCaseTest as u16,
    SwitchCaseConsequent(SwitchCaseWithoutConsequent<'a>) =
        AncestorType::SwitchCaseConsequent as u16,
    LabeledStatementLabel(LabeledStatementWithoutLabel<'a>) =
        AncestorType::LabeledStatementLabel as u16,
    LabeledStatementBody(LabeledStatementWithoutBody<'a>) =
        AncestorType::LabeledStatementBody as u16,
    ThrowStatementArgument(ThrowStatementWithoutArgument<'a>) =
        AncestorType::ThrowStatementArgument as u16,
    TryStatementBlock(TryStatementWithoutBlock<'a>) = AncestorType::TryStatementBlock as u16,
    TryStatementHandler(TryStatementWithoutHandler<'a>) = AncestorType::TryStatementHandler as u16,
    TryStatementFinalizer(TryStatementWithoutFinalizer<'a>) =
        AncestorType::TryStatementFinalizer as u16,
    CatchClauseParam(CatchClauseWithoutParam<'a>) = AncestorType::CatchClauseParam as u16,
    CatchClauseBody(CatchClauseWithoutBody<'a>) = AncestorType::CatchClauseBody as u16,
    CatchParameterPattern(CatchParameterWithoutPattern<'a>) =
        AncestorType::CatchParameterPattern as u16,
    BindingPatternKind(BindingPatternWithoutKind<'a>) = AncestorType::BindingPatternKind as u16,
    BindingPatternTypeAnnotation(BindingPatternWithoutTypeAnnotation<'a>) =
        AncestorType::BindingPatternTypeAnnotation as u16,
    AssignmentPatternLeft(AssignmentPatternWithoutLeft<'a>) =
        AncestorType::AssignmentPatternLeft as u16,
    AssignmentPatternRight(AssignmentPatternWithoutRight<'a>) =
        AncestorType::AssignmentPatternRight as u16,
    ObjectPatternProperties(ObjectPatternWithoutProperties<'a>) =
        AncestorType::ObjectPatternProperties as u16,
    ObjectPatternRest(ObjectPatternWithoutRest<'a>) = AncestorType::ObjectPatternRest as u16,
    BindingPropertyKey(BindingPropertyWithoutKey<'a>) = AncestorType::BindingPropertyKey as u16,
    BindingPropertyValue(BindingPropertyWithoutValue<'a>) =
        AncestorType::BindingPropertyValue as u16,
    ArrayPatternElements(ArrayPatternWithoutElements<'a>) =
        AncestorType::ArrayPatternElements as u16,
    ArrayPatternRest(ArrayPatternWithoutRest<'a>) = AncestorType::ArrayPatternRest as u16,
    BindingRestElementArgument(BindingRestElementWithoutArgument<'a>) =
        AncestorType::BindingRestElementArgument as u16,
    FunctionId(FunctionWithoutId<'a>) = AncestorType::FunctionId as u16,
    FunctionTypeParameters(FunctionWithoutTypeParameters<'a>) =
        AncestorType::FunctionTypeParameters as u16,
    FunctionThisParam(FunctionWithoutThisParam<'a>) = AncestorType::FunctionThisParam as u16,
    FunctionParams(FunctionWithoutParams<'a>) = AncestorType::FunctionParams as u16,
    FunctionBody(FunctionWithoutBody<'a>) = AncestorType::FunctionBody as u16,
    FunctionReturnType(FunctionWithoutReturnType<'a>) = AncestorType::FunctionReturnType as u16,
    FormalParametersItems(FormalParametersWithoutItems<'a>) =
        AncestorType::FormalParametersItems as u16,
    FormalParametersRest(FormalParametersWithoutRest<'a>) =
        AncestorType::FormalParametersRest as u16,
    FormalParameterPattern(FormalParameterWithoutPattern<'a>) =
        AncestorType::FormalParameterPattern as u16,
    FormalParameterDecorators(FormalParameterWithoutDecorators<'a>) =
        AncestorType::FormalParameterDecorators as u16,
    FunctionBodyDirectives(FunctionBodyWithoutDirectives<'a>) =
        AncestorType::FunctionBodyDirectives as u16,
    FunctionBodyStatements(FunctionBodyWithoutStatements<'a>) =
        AncestorType::FunctionBodyStatements as u16,
    ArrowFunctionExpressionParams(ArrowFunctionExpressionWithoutParams<'a>) =
        AncestorType::ArrowFunctionExpressionParams as u16,
    ArrowFunctionExpressionBody(ArrowFunctionExpressionWithoutBody<'a>) =
        AncestorType::ArrowFunctionExpressionBody as u16,
    ArrowFunctionExpressionTypeParameters(ArrowFunctionExpressionWithoutTypeParameters<'a>) =
        AncestorType::ArrowFunctionExpressionTypeParameters as u16,
    ArrowFunctionExpressionReturnType(ArrowFunctionExpressionWithoutReturnType<'a>) =
        AncestorType::ArrowFunctionExpressionReturnType as u16,
    YieldExpressionArgument(YieldExpressionWithoutArgument<'a>) =
        AncestorType::YieldExpressionArgument as u16,
    ClassDecorators(ClassWithoutDecorators<'a>) = AncestorType::ClassDecorators as u16,
    ClassId(ClassWithoutId<'a>) = AncestorType::ClassId as u16,
    ClassSuperClass(ClassWithoutSuperClass<'a>) = AncestorType::ClassSuperClass as u16,
    ClassBody(ClassWithoutBody<'a>) = AncestorType::ClassBody as u16,
    ClassTypeParameters(ClassWithoutTypeParameters<'a>) = AncestorType::ClassTypeParameters as u16,
    ClassSuperTypeParameters(ClassWithoutSuperTypeParameters<'a>) =
        AncestorType::ClassSuperTypeParameters as u16,
    ClassImplements(ClassWithoutImplements<'a>) = AncestorType::ClassImplements as u16,
    ClassBodyBody(ClassBodyWithoutBody<'a>) = AncestorType::ClassBodyBody as u16,
    MethodDefinitionDecorators(MethodDefinitionWithoutDecorators<'a>) =
        AncestorType::MethodDefinitionDecorators as u16,
    MethodDefinitionKey(MethodDefinitionWithoutKey<'a>) = AncestorType::MethodDefinitionKey as u16,
    MethodDefinitionValue(MethodDefinitionWithoutValue<'a>) =
        AncestorType::MethodDefinitionValue as u16,
    PropertyDefinitionKey(PropertyDefinitionWithoutKey<'a>) =
        AncestorType::PropertyDefinitionKey as u16,
    PropertyDefinitionValue(PropertyDefinitionWithoutValue<'a>) =
        AncestorType::PropertyDefinitionValue as u16,
    PropertyDefinitionTypeAnnotation(PropertyDefinitionWithoutTypeAnnotation<'a>) =
        AncestorType::PropertyDefinitionTypeAnnotation as u16,
    PropertyDefinitionDecorators(PropertyDefinitionWithoutDecorators<'a>) =
        AncestorType::PropertyDefinitionDecorators as u16,
    StaticBlockBody(StaticBlockWithoutBody<'a>) = AncestorType::StaticBlockBody as u16,
    AccessorPropertyKey(AccessorPropertyWithoutKey<'a>) = AncestorType::AccessorPropertyKey as u16,
    AccessorPropertyValue(AccessorPropertyWithoutValue<'a>) =
        AncestorType::AccessorPropertyValue as u16,
    AccessorPropertyDecorators(AccessorPropertyWithoutDecorators<'a>) =
        AncestorType::AccessorPropertyDecorators as u16,
    ImportExpressionSource(ImportExpressionWithoutSource<'a>) =
        AncestorType::ImportExpressionSource as u16,
    ImportExpressionArguments(ImportExpressionWithoutArguments<'a>) =
        AncestorType::ImportExpressionArguments as u16,
    ImportDeclarationSpecifiers(ImportDeclarationWithoutSpecifiers<'a>) =
        AncestorType::ImportDeclarationSpecifiers as u16,
    ImportDeclarationSource(ImportDeclarationWithoutSource<'a>) =
        AncestorType::ImportDeclarationSource as u16,
    ImportDeclarationWithClause(ImportDeclarationWithoutWithClause<'a>) =
        AncestorType::ImportDeclarationWithClause as u16,
    ImportSpecifierImported(ImportSpecifierWithoutImported<'a>) =
        AncestorType::ImportSpecifierImported as u16,
    ImportSpecifierLocal(ImportSpecifierWithoutLocal<'a>) =
        AncestorType::ImportSpecifierLocal as u16,
    ImportDefaultSpecifierLocal(ImportDefaultSpecifierWithoutLocal<'a>) =
        AncestorType::ImportDefaultSpecifierLocal as u16,
    ImportNamespaceSpecifierLocal(ImportNamespaceSpecifierWithoutLocal<'a>) =
        AncestorType::ImportNamespaceSpecifierLocal as u16,
    WithClauseAttributesKeyword(WithClauseWithoutAttributesKeyword<'a>) =
        AncestorType::WithClauseAttributesKeyword as u16,
    WithClauseWithEntries(WithClauseWithoutWithEntries<'a>) =
        AncestorType::WithClauseWithEntries as u16,
    ImportAttributeKey(ImportAttributeWithoutKey<'a>) = AncestorType::ImportAttributeKey as u16,
    ImportAttributeValue(ImportAttributeWithoutValue<'a>) =
        AncestorType::ImportAttributeValue as u16,
    ExportNamedDeclarationDeclaration(ExportNamedDeclarationWithoutDeclaration<'a>) =
        AncestorType::ExportNamedDeclarationDeclaration as u16,
    ExportNamedDeclarationSpecifiers(ExportNamedDeclarationWithoutSpecifiers<'a>) =
        AncestorType::ExportNamedDeclarationSpecifiers as u16,
    ExportNamedDeclarationSource(ExportNamedDeclarationWithoutSource<'a>) =
        AncestorType::ExportNamedDeclarationSource as u16,
    ExportNamedDeclarationWithClause(ExportNamedDeclarationWithoutWithClause<'a>) =
        AncestorType::ExportNamedDeclarationWithClause as u16,
    ExportDefaultDeclarationDeclaration(ExportDefaultDeclarationWithoutDeclaration<'a>) =
        AncestorType::ExportDefaultDeclarationDeclaration as u16,
    ExportDefaultDeclarationExported(ExportDefaultDeclarationWithoutExported<'a>) =
        AncestorType::ExportDefaultDeclarationExported as u16,
    ExportAllDeclarationExported(ExportAllDeclarationWithoutExported<'a>) =
        AncestorType::ExportAllDeclarationExported as u16,
    ExportAllDeclarationSource(ExportAllDeclarationWithoutSource<'a>) =
        AncestorType::ExportAllDeclarationSource as u16,
    ExportAllDeclarationWithClause(ExportAllDeclarationWithoutWithClause<'a>) =
        AncestorType::ExportAllDeclarationWithClause as u16,
    ExportSpecifierLocal(ExportSpecifierWithoutLocal<'a>) =
        AncestorType::ExportSpecifierLocal as u16,
    ExportSpecifierExported(ExportSpecifierWithoutExported<'a>) =
        AncestorType::ExportSpecifierExported as u16,
    JSXElementOpeningElement(JSXElementWithoutOpeningElement<'a>) =
        AncestorType::JSXElementOpeningElement as u16,
    JSXElementClosingElement(JSXElementWithoutClosingElement<'a>) =
        AncestorType::JSXElementClosingElement as u16,
    JSXElementChildren(JSXElementWithoutChildren<'a>) = AncestorType::JSXElementChildren as u16,
    JSXOpeningElementName(JSXOpeningElementWithoutName<'a>) =
        AncestorType::JSXOpeningElementName as u16,
    JSXOpeningElementAttributes(JSXOpeningElementWithoutAttributes<'a>) =
        AncestorType::JSXOpeningElementAttributes as u16,
    JSXOpeningElementTypeParameters(JSXOpeningElementWithoutTypeParameters<'a>) =
        AncestorType::JSXOpeningElementTypeParameters as u16,
    JSXClosingElementName(JSXClosingElementWithoutName<'a>) =
        AncestorType::JSXClosingElementName as u16,
    JSXFragmentChildren(JSXFragmentWithoutChildren<'a>) = AncestorType::JSXFragmentChildren as u16,
    JSXNamespacedNameNamespace(JSXNamespacedNameWithoutNamespace<'a>) =
        AncestorType::JSXNamespacedNameNamespace as u16,
    JSXNamespacedNameProperty(JSXNamespacedNameWithoutProperty<'a>) =
        AncestorType::JSXNamespacedNameProperty as u16,
    JSXMemberExpressionObject(JSXMemberExpressionWithoutObject<'a>) =
        AncestorType::JSXMemberExpressionObject as u16,
    JSXMemberExpressionProperty(JSXMemberExpressionWithoutProperty<'a>) =
        AncestorType::JSXMemberExpressionProperty as u16,
    JSXExpressionContainerExpression(JSXExpressionContainerWithoutExpression<'a>) =
        AncestorType::JSXExpressionContainerExpression as u16,
    JSXAttributeName(JSXAttributeWithoutName<'a>) = AncestorType::JSXAttributeName as u16,
    JSXAttributeValue(JSXAttributeWithoutValue<'a>) = AncestorType::JSXAttributeValue as u16,
    JSXSpreadAttributeArgument(JSXSpreadAttributeWithoutArgument<'a>) =
        AncestorType::JSXSpreadAttributeArgument as u16,
    JSXSpreadChildExpression(JSXSpreadChildWithoutExpression<'a>) =
        AncestorType::JSXSpreadChildExpression as u16,
    TSThisParameterThis(TSThisParameterWithoutThis<'a>) = AncestorType::TSThisParameterThis as u16,
    TSThisParameterTypeAnnotation(TSThisParameterWithoutTypeAnnotation<'a>) =
        AncestorType::TSThisParameterTypeAnnotation as u16,
    TSEnumDeclarationId(TSEnumDeclarationWithoutId<'a>) = AncestorType::TSEnumDeclarationId as u16,
    TSEnumDeclarationMembers(TSEnumDeclarationWithoutMembers<'a>) =
        AncestorType::TSEnumDeclarationMembers as u16,
    TSEnumMemberId(TSEnumMemberWithoutId<'a>) = AncestorType::TSEnumMemberId as u16,
    TSEnumMemberInitializer(TSEnumMemberWithoutInitializer<'a>) =
        AncestorType::TSEnumMemberInitializer as u16,
    TSTypeAnnotationTypeAnnotation(TSTypeAnnotationWithoutTypeAnnotation<'a>) =
        AncestorType::TSTypeAnnotationTypeAnnotation as u16,
    TSLiteralTypeLiteral(TSLiteralTypeWithoutLiteral<'a>) =
        AncestorType::TSLiteralTypeLiteral as u16,
    TSConditionalTypeCheckType(TSConditionalTypeWithoutCheckType<'a>) =
        AncestorType::TSConditionalTypeCheckType as u16,
    TSConditionalTypeExtendsType(TSConditionalTypeWithoutExtendsType<'a>) =
        AncestorType::TSConditionalTypeExtendsType as u16,
    TSConditionalTypeTrueType(TSConditionalTypeWithoutTrueType<'a>) =
        AncestorType::TSConditionalTypeTrueType as u16,
    TSConditionalTypeFalseType(TSConditionalTypeWithoutFalseType<'a>) =
        AncestorType::TSConditionalTypeFalseType as u16,
    TSUnionTypeTypes(TSUnionTypeWithoutTypes<'a>) = AncestorType::TSUnionTypeTypes as u16,
    TSIntersectionTypeTypes(TSIntersectionTypeWithoutTypes<'a>) =
        AncestorType::TSIntersectionTypeTypes as u16,
    TSTypeOperatorTypeAnnotation(TSTypeOperatorWithoutTypeAnnotation<'a>) =
        AncestorType::TSTypeOperatorTypeAnnotation as u16,
    TSArrayTypeElementType(TSArrayTypeWithoutElementType<'a>) =
        AncestorType::TSArrayTypeElementType as u16,
    TSIndexedAccessTypeObjectType(TSIndexedAccessTypeWithoutObjectType<'a>) =
        AncestorType::TSIndexedAccessTypeObjectType as u16,
    TSIndexedAccessTypeIndexType(TSIndexedAccessTypeWithoutIndexType<'a>) =
        AncestorType::TSIndexedAccessTypeIndexType as u16,
    TSTupleTypeElementTypes(TSTupleTypeWithoutElementTypes<'a>) =
        AncestorType::TSTupleTypeElementTypes as u16,
    TSNamedTupleMemberElementType(TSNamedTupleMemberWithoutElementType<'a>) =
        AncestorType::TSNamedTupleMemberElementType as u16,
    TSNamedTupleMemberLabel(TSNamedTupleMemberWithoutLabel<'a>) =
        AncestorType::TSNamedTupleMemberLabel as u16,
    TSOptionalTypeTypeAnnotation(TSOptionalTypeWithoutTypeAnnotation<'a>) =
        AncestorType::TSOptionalTypeTypeAnnotation as u16,
    TSRestTypeTypeAnnotation(TSRestTypeWithoutTypeAnnotation<'a>) =
        AncestorType::TSRestTypeTypeAnnotation as u16,
    TSTypeReferenceTypeName(TSTypeReferenceWithoutTypeName<'a>) =
        AncestorType::TSTypeReferenceTypeName as u16,
    TSTypeReferenceTypeParameters(TSTypeReferenceWithoutTypeParameters<'a>) =
        AncestorType::TSTypeReferenceTypeParameters as u16,
    TSQualifiedNameLeft(TSQualifiedNameWithoutLeft<'a>) = AncestorType::TSQualifiedNameLeft as u16,
    TSQualifiedNameRight(TSQualifiedNameWithoutRight<'a>) =
        AncestorType::TSQualifiedNameRight as u16,
    TSTypeParameterInstantiationParams(TSTypeParameterInstantiationWithoutParams<'a>) =
        AncestorType::TSTypeParameterInstantiationParams as u16,
    TSTypeParameterName(TSTypeParameterWithoutName<'a>) = AncestorType::TSTypeParameterName as u16,
    TSTypeParameterConstraint(TSTypeParameterWithoutConstraint<'a>) =
        AncestorType::TSTypeParameterConstraint as u16,
    TSTypeParameterDefault(TSTypeParameterWithoutDefault<'a>) =
        AncestorType::TSTypeParameterDefault as u16,
    TSTypeParameterDeclarationParams(TSTypeParameterDeclarationWithoutParams<'a>) =
        AncestorType::TSTypeParameterDeclarationParams as u16,
    TSTypeAliasDeclarationId(TSTypeAliasDeclarationWithoutId<'a>) =
        AncestorType::TSTypeAliasDeclarationId as u16,
    TSTypeAliasDeclarationTypeAnnotation(TSTypeAliasDeclarationWithoutTypeAnnotation<'a>) =
        AncestorType::TSTypeAliasDeclarationTypeAnnotation as u16,
    TSTypeAliasDeclarationTypeParameters(TSTypeAliasDeclarationWithoutTypeParameters<'a>) =
        AncestorType::TSTypeAliasDeclarationTypeParameters as u16,
    TSClassImplementsExpression(TSClassImplementsWithoutExpression<'a>) =
        AncestorType::TSClassImplementsExpression as u16,
    TSClassImplementsTypeParameters(TSClassImplementsWithoutTypeParameters<'a>) =
        AncestorType::TSClassImplementsTypeParameters as u16,
    TSInterfaceDeclarationId(TSInterfaceDeclarationWithoutId<'a>) =
        AncestorType::TSInterfaceDeclarationId as u16,
    TSInterfaceDeclarationBody(TSInterfaceDeclarationWithoutBody<'a>) =
        AncestorType::TSInterfaceDeclarationBody as u16,
    TSInterfaceDeclarationTypeParameters(TSInterfaceDeclarationWithoutTypeParameters<'a>) =
        AncestorType::TSInterfaceDeclarationTypeParameters as u16,
    TSInterfaceDeclarationExtends(TSInterfaceDeclarationWithoutExtends<'a>) =
        AncestorType::TSInterfaceDeclarationExtends as u16,
    TSInterfaceBodyBody(TSInterfaceBodyWithoutBody<'a>) = AncestorType::TSInterfaceBodyBody as u16,
    TSPropertySignatureKey(TSPropertySignatureWithoutKey<'a>) =
        AncestorType::TSPropertySignatureKey as u16,
    TSPropertySignatureTypeAnnotation(TSPropertySignatureWithoutTypeAnnotation<'a>) =
        AncestorType::TSPropertySignatureTypeAnnotation as u16,
    TSIndexSignatureParameters(TSIndexSignatureWithoutParameters<'a>) =
        AncestorType::TSIndexSignatureParameters as u16,
    TSIndexSignatureTypeAnnotation(TSIndexSignatureWithoutTypeAnnotation<'a>) =
        AncestorType::TSIndexSignatureTypeAnnotation as u16,
    TSCallSignatureDeclarationThisParam(TSCallSignatureDeclarationWithoutThisParam<'a>) =
        AncestorType::TSCallSignatureDeclarationThisParam as u16,
    TSCallSignatureDeclarationParams(TSCallSignatureDeclarationWithoutParams<'a>) =
        AncestorType::TSCallSignatureDeclarationParams as u16,
    TSCallSignatureDeclarationReturnType(TSCallSignatureDeclarationWithoutReturnType<'a>) =
        AncestorType::TSCallSignatureDeclarationReturnType as u16,
    TSCallSignatureDeclarationTypeParameters(TSCallSignatureDeclarationWithoutTypeParameters<'a>) =
        AncestorType::TSCallSignatureDeclarationTypeParameters as u16,
    TSMethodSignatureKey(TSMethodSignatureWithoutKey<'a>) =
        AncestorType::TSMethodSignatureKey as u16,
    TSMethodSignatureThisParam(TSMethodSignatureWithoutThisParam<'a>) =
        AncestorType::TSMethodSignatureThisParam as u16,
    TSMethodSignatureParams(TSMethodSignatureWithoutParams<'a>) =
        AncestorType::TSMethodSignatureParams as u16,
    TSMethodSignatureReturnType(TSMethodSignatureWithoutReturnType<'a>) =
        AncestorType::TSMethodSignatureReturnType as u16,
    TSMethodSignatureTypeParameters(TSMethodSignatureWithoutTypeParameters<'a>) =
        AncestorType::TSMethodSignatureTypeParameters as u16,
    TSConstructSignatureDeclarationParams(TSConstructSignatureDeclarationWithoutParams<'a>) =
        AncestorType::TSConstructSignatureDeclarationParams as u16,
    TSConstructSignatureDeclarationReturnType(TSConstructSignatureDeclarationWithoutReturnType<'a>) =
        AncestorType::TSConstructSignatureDeclarationReturnType as u16,
    TSConstructSignatureDeclarationTypeParameters(
        TSConstructSignatureDeclarationWithoutTypeParameters<'a>,
    ) = AncestorType::TSConstructSignatureDeclarationTypeParameters as u16,
    TSIndexSignatureNameTypeAnnotation(TSIndexSignatureNameWithoutTypeAnnotation<'a>) =
        AncestorType::TSIndexSignatureNameTypeAnnotation as u16,
    TSInterfaceHeritageExpression(TSInterfaceHeritageWithoutExpression<'a>) =
        AncestorType::TSInterfaceHeritageExpression as u16,
    TSInterfaceHeritageTypeParameters(TSInterfaceHeritageWithoutTypeParameters<'a>) =
        AncestorType::TSInterfaceHeritageTypeParameters as u16,
    TSTypePredicateParameterName(TSTypePredicateWithoutParameterName<'a>) =
        AncestorType::TSTypePredicateParameterName as u16,
    TSTypePredicateTypeAnnotation(TSTypePredicateWithoutTypeAnnotation<'a>) =
        AncestorType::TSTypePredicateTypeAnnotation as u16,
    TSModuleDeclarationId(TSModuleDeclarationWithoutId<'a>) =
        AncestorType::TSModuleDeclarationId as u16,
    TSModuleDeclarationBody(TSModuleDeclarationWithoutBody<'a>) =
        AncestorType::TSModuleDeclarationBody as u16,
    TSModuleBlockBody(TSModuleBlockWithoutBody<'a>) = AncestorType::TSModuleBlockBody as u16,
    TSTypeLiteralMembers(TSTypeLiteralWithoutMembers<'a>) =
        AncestorType::TSTypeLiteralMembers as u16,
    TSInferTypeTypeParameter(TSInferTypeWithoutTypeParameter<'a>) =
        AncestorType::TSInferTypeTypeParameter as u16,
    TSTypeQueryExprName(TSTypeQueryWithoutExprName<'a>) = AncestorType::TSTypeQueryExprName as u16,
    TSTypeQueryTypeParameters(TSTypeQueryWithoutTypeParameters<'a>) =
        AncestorType::TSTypeQueryTypeParameters as u16,
    TSImportTypeArgument(TSImportTypeWithoutArgument<'a>) =
        AncestorType::TSImportTypeArgument as u16,
    TSImportTypeQualifier(TSImportTypeWithoutQualifier<'a>) =
        AncestorType::TSImportTypeQualifier as u16,
    TSImportTypeAttributes(TSImportTypeWithoutAttributes<'a>) =
        AncestorType::TSImportTypeAttributes as u16,
    TSImportTypeTypeParameters(TSImportTypeWithoutTypeParameters<'a>) =
        AncestorType::TSImportTypeTypeParameters as u16,
    TSImportAttributesElements(TSImportAttributesWithoutElements<'a>) =
        AncestorType::TSImportAttributesElements as u16,
    TSImportAttributeName(TSImportAttributeWithoutName<'a>) =
        AncestorType::TSImportAttributeName as u16,
    TSImportAttributeValue(TSImportAttributeWithoutValue<'a>) =
        AncestorType::TSImportAttributeValue as u16,
    TSFunctionTypeThisParam(TSFunctionTypeWithoutThisParam<'a>) =
        AncestorType::TSFunctionTypeThisParam as u16,
    TSFunctionTypeParams(TSFunctionTypeWithoutParams<'a>) =
        AncestorType::TSFunctionTypeParams as u16,
    TSFunctionTypeReturnType(TSFunctionTypeWithoutReturnType<'a>) =
        AncestorType::TSFunctionTypeReturnType as u16,
    TSFunctionTypeTypeParameters(TSFunctionTypeWithoutTypeParameters<'a>) =
        AncestorType::TSFunctionTypeTypeParameters as u16,
    TSConstructorTypeParams(TSConstructorTypeWithoutParams<'a>) =
        AncestorType::TSConstructorTypeParams as u16,
    TSConstructorTypeReturnType(TSConstructorTypeWithoutReturnType<'a>) =
        AncestorType::TSConstructorTypeReturnType as u16,
    TSConstructorTypeTypeParameters(TSConstructorTypeWithoutTypeParameters<'a>) =
        AncestorType::TSConstructorTypeTypeParameters as u16,
    TSMappedTypeTypeParameter(TSMappedTypeWithoutTypeParameter<'a>) =
        AncestorType::TSMappedTypeTypeParameter as u16,
    TSMappedTypeNameType(TSMappedTypeWithoutNameType<'a>) =
        AncestorType::TSMappedTypeNameType as u16,
    TSMappedTypeTypeAnnotation(TSMappedTypeWithoutTypeAnnotation<'a>) =
        AncestorType::TSMappedTypeTypeAnnotation as u16,
    TSTemplateLiteralTypeQuasis(TSTemplateLiteralTypeWithoutQuasis<'a>) =
        AncestorType::TSTemplateLiteralTypeQuasis as u16,
    TSTemplateLiteralTypeTypes(TSTemplateLiteralTypeWithoutTypes<'a>) =
        AncestorType::TSTemplateLiteralTypeTypes as u16,
    TSAsExpressionExpression(TSAsExpressionWithoutExpression<'a>) =
        AncestorType::TSAsExpressionExpression as u16,
    TSAsExpressionTypeAnnotation(TSAsExpressionWithoutTypeAnnotation<'a>) =
        AncestorType::TSAsExpressionTypeAnnotation as u16,
    TSSatisfiesExpressionExpression(TSSatisfiesExpressionWithoutExpression<'a>) =
        AncestorType::TSSatisfiesExpressionExpression as u16,
    TSSatisfiesExpressionTypeAnnotation(TSSatisfiesExpressionWithoutTypeAnnotation<'a>) =
        AncestorType::TSSatisfiesExpressionTypeAnnotation as u16,
    TSTypeAssertionExpression(TSTypeAssertionWithoutExpression<'a>) =
        AncestorType::TSTypeAssertionExpression as u16,
    TSTypeAssertionTypeAnnotation(TSTypeAssertionWithoutTypeAnnotation<'a>) =
        AncestorType::TSTypeAssertionTypeAnnotation as u16,
    TSImportEqualsDeclarationId(TSImportEqualsDeclarationWithoutId<'a>) =
        AncestorType::TSImportEqualsDeclarationId as u16,
    TSImportEqualsDeclarationModuleReference(TSImportEqualsDeclarationWithoutModuleReference<'a>) =
        AncestorType::TSImportEqualsDeclarationModuleReference as u16,
    TSExternalModuleReferenceExpression(TSExternalModuleReferenceWithoutExpression<'a>) =
        AncestorType::TSExternalModuleReferenceExpression as u16,
    TSNonNullExpressionExpression(TSNonNullExpressionWithoutExpression<'a>) =
        AncestorType::TSNonNullExpressionExpression as u16,
    DecoratorExpression(DecoratorWithoutExpression<'a>) = AncestorType::DecoratorExpression as u16,
    TSExportAssignmentExpression(TSExportAssignmentWithoutExpression<'a>) =
        AncestorType::TSExportAssignmentExpression as u16,
    TSNamespaceExportDeclarationId(TSNamespaceExportDeclarationWithoutId<'a>) =
        AncestorType::TSNamespaceExportDeclarationId as u16,
    TSInstantiationExpressionExpression(TSInstantiationExpressionWithoutExpression<'a>) =
        AncestorType::TSInstantiationExpressionExpression as u16,
    TSInstantiationExpressionTypeParameters(TSInstantiationExpressionWithoutTypeParameters<'a>) =
        AncestorType::TSInstantiationExpressionTypeParameters as u16,
    JSDocNullableTypeTypeAnnotation(JSDocNullableTypeWithoutTypeAnnotation<'a>) =
        AncestorType::JSDocNullableTypeTypeAnnotation as u16,
}

impl<'a> Ancestor<'a> {
    #[inline]
    pub fn is_program(&self) -> bool {
        matches!(self, Self::ProgramDirectives(_) | Self::ProgramHashbang(_) | Self::ProgramBody(_))
    }

    #[inline]
    pub fn is_array_expression(&self) -> bool {
        matches!(self, Self::ArrayExpressionElements(_))
    }

    #[inline]
    pub fn is_object_expression(&self) -> bool {
        matches!(self, Self::ObjectExpressionProperties(_))
    }

    #[inline]
    pub fn is_object_property(&self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyKey(_) | Self::ObjectPropertyValue(_) | Self::ObjectPropertyInit(_)
        )
    }

    #[inline]
    pub fn is_template_literal(&self) -> bool {
        matches!(self, Self::TemplateLiteralQuasis(_) | Self::TemplateLiteralExpressions(_))
    }

    #[inline]
    pub fn is_tagged_template_expression(&self) -> bool {
        matches!(
            self,
            Self::TaggedTemplateExpressionTag(_)
                | Self::TaggedTemplateExpressionQuasi(_)
                | Self::TaggedTemplateExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_computed_member_expression(&self) -> bool {
        matches!(
            self,
            Self::ComputedMemberExpressionObject(_) | Self::ComputedMemberExpressionExpression(_)
        )
    }

    #[inline]
    pub fn is_static_member_expression(&self) -> bool {
        matches!(
            self,
            Self::StaticMemberExpressionObject(_) | Self::StaticMemberExpressionProperty(_)
        )
    }

    #[inline]
    pub fn is_private_field_expression(&self) -> bool {
        matches!(self, Self::PrivateFieldExpressionObject(_) | Self::PrivateFieldExpressionField(_))
    }

    #[inline]
    pub fn is_call_expression(&self) -> bool {
        matches!(
            self,
            Self::CallExpressionCallee(_)
                | Self::CallExpressionArguments(_)
                | Self::CallExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_new_expression(&self) -> bool {
        matches!(
            self,
            Self::NewExpressionCallee(_)
                | Self::NewExpressionArguments(_)
                | Self::NewExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_meta_property(&self) -> bool {
        matches!(self, Self::MetaPropertyMeta(_) | Self::MetaPropertyProperty(_))
    }

    #[inline]
    pub fn is_spread_element(&self) -> bool {
        matches!(self, Self::SpreadElementArgument(_))
    }

    #[inline]
    pub fn is_update_expression(&self) -> bool {
        matches!(self, Self::UpdateExpressionArgument(_))
    }

    #[inline]
    pub fn is_unary_expression(&self) -> bool {
        matches!(self, Self::UnaryExpressionArgument(_))
    }

    #[inline]
    pub fn is_binary_expression(&self) -> bool {
        matches!(self, Self::BinaryExpressionLeft(_) | Self::BinaryExpressionRight(_))
    }

    #[inline]
    pub fn is_private_in_expression(&self) -> bool {
        matches!(self, Self::PrivateInExpressionLeft(_) | Self::PrivateInExpressionRight(_))
    }

    #[inline]
    pub fn is_logical_expression(&self) -> bool {
        matches!(self, Self::LogicalExpressionLeft(_) | Self::LogicalExpressionRight(_))
    }

    #[inline]
    pub fn is_conditional_expression(&self) -> bool {
        matches!(
            self,
            Self::ConditionalExpressionTest(_)
                | Self::ConditionalExpressionConsequent(_)
                | Self::ConditionalExpressionAlternate(_)
        )
    }

    #[inline]
    pub fn is_assignment_expression(&self) -> bool {
        matches!(self, Self::AssignmentExpressionLeft(_) | Self::AssignmentExpressionRight(_))
    }

    #[inline]
    pub fn is_array_assignment_target(&self) -> bool {
        matches!(self, Self::ArrayAssignmentTargetElements(_) | Self::ArrayAssignmentTargetRest(_))
    }

    #[inline]
    pub fn is_object_assignment_target(&self) -> bool {
        matches!(
            self,
            Self::ObjectAssignmentTargetProperties(_) | Self::ObjectAssignmentTargetRest(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_rest(&self) -> bool {
        matches!(self, Self::AssignmentTargetRestTarget(_))
    }

    #[inline]
    pub fn is_assignment_target_with_default(&self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetWithDefaultBinding(_) | Self::AssignmentTargetWithDefaultInit(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_property_identifier(&self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetPropertyIdentifierBinding(_)
                | Self::AssignmentTargetPropertyIdentifierInit(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_property_property(&self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetPropertyPropertyName(_)
                | Self::AssignmentTargetPropertyPropertyBinding(_)
        )
    }

    #[inline]
    pub fn is_sequence_expression(&self) -> bool {
        matches!(self, Self::SequenceExpressionExpressions(_))
    }

    #[inline]
    pub fn is_await_expression(&self) -> bool {
        matches!(self, Self::AwaitExpressionArgument(_))
    }

    #[inline]
    pub fn is_chain_expression(&self) -> bool {
        matches!(self, Self::ChainExpressionExpression(_))
    }

    #[inline]
    pub fn is_parenthesized_expression(&self) -> bool {
        matches!(self, Self::ParenthesizedExpressionExpression(_))
    }

    #[inline]
    pub fn is_directive(&self) -> bool {
        matches!(self, Self::DirectiveExpression(_))
    }

    #[inline]
    pub fn is_block_statement(&self) -> bool {
        matches!(self, Self::BlockStatementBody(_))
    }

    #[inline]
    pub fn is_variable_declaration(&self) -> bool {
        matches!(self, Self::VariableDeclarationDeclarations(_))
    }

    #[inline]
    pub fn is_variable_declarator(&self) -> bool {
        matches!(self, Self::VariableDeclaratorId(_) | Self::VariableDeclaratorInit(_))
    }

    #[inline]
    pub fn is_using_declaration(&self) -> bool {
        matches!(self, Self::UsingDeclarationDeclarations(_))
    }

    #[inline]
    pub fn is_expression_statement(&self) -> bool {
        matches!(self, Self::ExpressionStatementExpression(_))
    }

    #[inline]
    pub fn is_if_statement(&self) -> bool {
        matches!(
            self,
            Self::IfStatementTest(_)
                | Self::IfStatementConsequent(_)
                | Self::IfStatementAlternate(_)
        )
    }

    #[inline]
    pub fn is_do_while_statement(&self) -> bool {
        matches!(self, Self::DoWhileStatementBody(_) | Self::DoWhileStatementTest(_))
    }

    #[inline]
    pub fn is_while_statement(&self) -> bool {
        matches!(self, Self::WhileStatementTest(_) | Self::WhileStatementBody(_))
    }

    #[inline]
    pub fn is_for_statement(&self) -> bool {
        matches!(
            self,
            Self::ForStatementInit(_)
                | Self::ForStatementTest(_)
                | Self::ForStatementUpdate(_)
                | Self::ForStatementBody(_)
        )
    }

    #[inline]
    pub fn is_for_in_statement(&self) -> bool {
        matches!(
            self,
            Self::ForInStatementLeft(_)
                | Self::ForInStatementRight(_)
                | Self::ForInStatementBody(_)
        )
    }

    #[inline]
    pub fn is_for_of_statement(&self) -> bool {
        matches!(
            self,
            Self::ForOfStatementLeft(_)
                | Self::ForOfStatementRight(_)
                | Self::ForOfStatementBody(_)
        )
    }

    #[inline]
    pub fn is_continue_statement(&self) -> bool {
        matches!(self, Self::ContinueStatementLabel(_))
    }

    #[inline]
    pub fn is_break_statement(&self) -> bool {
        matches!(self, Self::BreakStatementLabel(_))
    }

    #[inline]
    pub fn is_return_statement(&self) -> bool {
        matches!(self, Self::ReturnStatementArgument(_))
    }

    #[inline]
    pub fn is_with_statement(&self) -> bool {
        matches!(self, Self::WithStatementObject(_) | Self::WithStatementBody(_))
    }

    #[inline]
    pub fn is_switch_statement(&self) -> bool {
        matches!(self, Self::SwitchStatementDiscriminant(_) | Self::SwitchStatementCases(_))
    }

    #[inline]
    pub fn is_switch_case(&self) -> bool {
        matches!(self, Self::SwitchCaseTest(_) | Self::SwitchCaseConsequent(_))
    }

    #[inline]
    pub fn is_labeled_statement(&self) -> bool {
        matches!(self, Self::LabeledStatementLabel(_) | Self::LabeledStatementBody(_))
    }

    #[inline]
    pub fn is_throw_statement(&self) -> bool {
        matches!(self, Self::ThrowStatementArgument(_))
    }

    #[inline]
    pub fn is_try_statement(&self) -> bool {
        matches!(
            self,
            Self::TryStatementBlock(_)
                | Self::TryStatementHandler(_)
                | Self::TryStatementFinalizer(_)
        )
    }

    #[inline]
    pub fn is_catch_clause(&self) -> bool {
        matches!(self, Self::CatchClauseParam(_) | Self::CatchClauseBody(_))
    }

    #[inline]
    pub fn is_catch_parameter(&self) -> bool {
        matches!(self, Self::CatchParameterPattern(_))
    }

    #[inline]
    pub fn is_binding_pattern(&self) -> bool {
        matches!(self, Self::BindingPatternKind(_) | Self::BindingPatternTypeAnnotation(_))
    }

    #[inline]
    pub fn is_assignment_pattern(&self) -> bool {
        matches!(self, Self::AssignmentPatternLeft(_) | Self::AssignmentPatternRight(_))
    }

    #[inline]
    pub fn is_object_pattern(&self) -> bool {
        matches!(self, Self::ObjectPatternProperties(_) | Self::ObjectPatternRest(_))
    }

    #[inline]
    pub fn is_binding_property(&self) -> bool {
        matches!(self, Self::BindingPropertyKey(_) | Self::BindingPropertyValue(_))
    }

    #[inline]
    pub fn is_array_pattern(&self) -> bool {
        matches!(self, Self::ArrayPatternElements(_) | Self::ArrayPatternRest(_))
    }

    #[inline]
    pub fn is_binding_rest_element(&self) -> bool {
        matches!(self, Self::BindingRestElementArgument(_))
    }

    #[inline]
    pub fn is_function(&self) -> bool {
        matches!(
            self,
            Self::FunctionId(_)
                | Self::FunctionTypeParameters(_)
                | Self::FunctionThisParam(_)
                | Self::FunctionParams(_)
                | Self::FunctionBody(_)
                | Self::FunctionReturnType(_)
        )
    }

    #[inline]
    pub fn is_formal_parameters(&self) -> bool {
        matches!(self, Self::FormalParametersItems(_) | Self::FormalParametersRest(_))
    }

    #[inline]
    pub fn is_formal_parameter(&self) -> bool {
        matches!(self, Self::FormalParameterPattern(_) | Self::FormalParameterDecorators(_))
    }

    #[inline]
    pub fn is_function_body(&self) -> bool {
        matches!(self, Self::FunctionBodyDirectives(_) | Self::FunctionBodyStatements(_))
    }

    #[inline]
    pub fn is_arrow_function_expression(&self) -> bool {
        matches!(
            self,
            Self::ArrowFunctionExpressionParams(_)
                | Self::ArrowFunctionExpressionBody(_)
                | Self::ArrowFunctionExpressionTypeParameters(_)
                | Self::ArrowFunctionExpressionReturnType(_)
        )
    }

    #[inline]
    pub fn is_yield_expression(&self) -> bool {
        matches!(self, Self::YieldExpressionArgument(_))
    }

    #[inline]
    pub fn is_class(&self) -> bool {
        matches!(
            self,
            Self::ClassDecorators(_)
                | Self::ClassId(_)
                | Self::ClassSuperClass(_)
                | Self::ClassBody(_)
                | Self::ClassTypeParameters(_)
                | Self::ClassSuperTypeParameters(_)
                | Self::ClassImplements(_)
        )
    }

    #[inline]
    pub fn is_class_body(&self) -> bool {
        matches!(self, Self::ClassBodyBody(_))
    }

    #[inline]
    pub fn is_method_definition(&self) -> bool {
        matches!(
            self,
            Self::MethodDefinitionDecorators(_)
                | Self::MethodDefinitionKey(_)
                | Self::MethodDefinitionValue(_)
        )
    }

    #[inline]
    pub fn is_property_definition(&self) -> bool {
        matches!(
            self,
            Self::PropertyDefinitionKey(_)
                | Self::PropertyDefinitionValue(_)
                | Self::PropertyDefinitionTypeAnnotation(_)
                | Self::PropertyDefinitionDecorators(_)
        )
    }

    #[inline]
    pub fn is_static_block(&self) -> bool {
        matches!(self, Self::StaticBlockBody(_))
    }

    #[inline]
    pub fn is_accessor_property(&self) -> bool {
        matches!(
            self,
            Self::AccessorPropertyKey(_)
                | Self::AccessorPropertyValue(_)
                | Self::AccessorPropertyDecorators(_)
        )
    }

    #[inline]
    pub fn is_import_expression(&self) -> bool {
        matches!(self, Self::ImportExpressionSource(_) | Self::ImportExpressionArguments(_))
    }

    #[inline]
    pub fn is_import_declaration(&self) -> bool {
        matches!(
            self,
            Self::ImportDeclarationSpecifiers(_)
                | Self::ImportDeclarationSource(_)
                | Self::ImportDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_import_specifier(&self) -> bool {
        matches!(self, Self::ImportSpecifierImported(_) | Self::ImportSpecifierLocal(_))
    }

    #[inline]
    pub fn is_import_default_specifier(&self) -> bool {
        matches!(self, Self::ImportDefaultSpecifierLocal(_))
    }

    #[inline]
    pub fn is_import_namespace_specifier(&self) -> bool {
        matches!(self, Self::ImportNamespaceSpecifierLocal(_))
    }

    #[inline]
    pub fn is_with_clause(&self) -> bool {
        matches!(self, Self::WithClauseAttributesKeyword(_) | Self::WithClauseWithEntries(_))
    }

    #[inline]
    pub fn is_import_attribute(&self) -> bool {
        matches!(self, Self::ImportAttributeKey(_) | Self::ImportAttributeValue(_))
    }

    #[inline]
    pub fn is_export_named_declaration(&self) -> bool {
        matches!(
            self,
            Self::ExportNamedDeclarationDeclaration(_)
                | Self::ExportNamedDeclarationSpecifiers(_)
                | Self::ExportNamedDeclarationSource(_)
                | Self::ExportNamedDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_export_default_declaration(&self) -> bool {
        matches!(
            self,
            Self::ExportDefaultDeclarationDeclaration(_)
                | Self::ExportDefaultDeclarationExported(_)
        )
    }

    #[inline]
    pub fn is_export_all_declaration(&self) -> bool {
        matches!(
            self,
            Self::ExportAllDeclarationExported(_)
                | Self::ExportAllDeclarationSource(_)
                | Self::ExportAllDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_export_specifier(&self) -> bool {
        matches!(self, Self::ExportSpecifierLocal(_) | Self::ExportSpecifierExported(_))
    }

    #[inline]
    pub fn is_jsx_element(&self) -> bool {
        matches!(
            self,
            Self::JSXElementOpeningElement(_)
                | Self::JSXElementClosingElement(_)
                | Self::JSXElementChildren(_)
        )
    }

    #[inline]
    pub fn is_jsx_opening_element(&self) -> bool {
        matches!(
            self,
            Self::JSXOpeningElementName(_)
                | Self::JSXOpeningElementAttributes(_)
                | Self::JSXOpeningElementTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_jsx_closing_element(&self) -> bool {
        matches!(self, Self::JSXClosingElementName(_))
    }

    #[inline]
    pub fn is_jsx_fragment(&self) -> bool {
        matches!(self, Self::JSXFragmentChildren(_))
    }

    #[inline]
    pub fn is_jsx_namespaced_name(&self) -> bool {
        matches!(self, Self::JSXNamespacedNameNamespace(_) | Self::JSXNamespacedNameProperty(_))
    }

    #[inline]
    pub fn is_jsx_member_expression(&self) -> bool {
        matches!(self, Self::JSXMemberExpressionObject(_) | Self::JSXMemberExpressionProperty(_))
    }

    #[inline]
    pub fn is_jsx_expression_container(&self) -> bool {
        matches!(self, Self::JSXExpressionContainerExpression(_))
    }

    #[inline]
    pub fn is_jsx_attribute(&self) -> bool {
        matches!(self, Self::JSXAttributeName(_) | Self::JSXAttributeValue(_))
    }

    #[inline]
    pub fn is_jsx_spread_attribute(&self) -> bool {
        matches!(self, Self::JSXSpreadAttributeArgument(_))
    }

    #[inline]
    pub fn is_jsx_spread_child(&self) -> bool {
        matches!(self, Self::JSXSpreadChildExpression(_))
    }

    #[inline]
    pub fn is_ts_this_parameter(&self) -> bool {
        matches!(self, Self::TSThisParameterThis(_) | Self::TSThisParameterTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_enum_declaration(&self) -> bool {
        matches!(self, Self::TSEnumDeclarationId(_) | Self::TSEnumDeclarationMembers(_))
    }

    #[inline]
    pub fn is_ts_enum_member(&self) -> bool {
        matches!(self, Self::TSEnumMemberId(_) | Self::TSEnumMemberInitializer(_))
    }

    #[inline]
    pub fn is_ts_type_annotation(&self) -> bool {
        matches!(self, Self::TSTypeAnnotationTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_literal_type(&self) -> bool {
        matches!(self, Self::TSLiteralTypeLiteral(_))
    }

    #[inline]
    pub fn is_ts_conditional_type(&self) -> bool {
        matches!(
            self,
            Self::TSConditionalTypeCheckType(_)
                | Self::TSConditionalTypeExtendsType(_)
                | Self::TSConditionalTypeTrueType(_)
                | Self::TSConditionalTypeFalseType(_)
        )
    }

    #[inline]
    pub fn is_ts_union_type(&self) -> bool {
        matches!(self, Self::TSUnionTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_intersection_type(&self) -> bool {
        matches!(self, Self::TSIntersectionTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_type_operator(&self) -> bool {
        matches!(self, Self::TSTypeOperatorTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_array_type(&self) -> bool {
        matches!(self, Self::TSArrayTypeElementType(_))
    }

    #[inline]
    pub fn is_ts_indexed_access_type(&self) -> bool {
        matches!(
            self,
            Self::TSIndexedAccessTypeObjectType(_) | Self::TSIndexedAccessTypeIndexType(_)
        )
    }

    #[inline]
    pub fn is_ts_tuple_type(&self) -> bool {
        matches!(self, Self::TSTupleTypeElementTypes(_))
    }

    #[inline]
    pub fn is_ts_named_tuple_member(&self) -> bool {
        matches!(self, Self::TSNamedTupleMemberElementType(_) | Self::TSNamedTupleMemberLabel(_))
    }

    #[inline]
    pub fn is_ts_optional_type(&self) -> bool {
        matches!(self, Self::TSOptionalTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_rest_type(&self) -> bool {
        matches!(self, Self::TSRestTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_type_reference(&self) -> bool {
        matches!(self, Self::TSTypeReferenceTypeName(_) | Self::TSTypeReferenceTypeParameters(_))
    }

    #[inline]
    pub fn is_ts_qualified_name(&self) -> bool {
        matches!(self, Self::TSQualifiedNameLeft(_) | Self::TSQualifiedNameRight(_))
    }

    #[inline]
    pub fn is_ts_type_parameter_instantiation(&self) -> bool {
        matches!(self, Self::TSTypeParameterInstantiationParams(_))
    }

    #[inline]
    pub fn is_ts_type_parameter(&self) -> bool {
        matches!(
            self,
            Self::TSTypeParameterName(_)
                | Self::TSTypeParameterConstraint(_)
                | Self::TSTypeParameterDefault(_)
        )
    }

    #[inline]
    pub fn is_ts_type_parameter_declaration(&self) -> bool {
        matches!(self, Self::TSTypeParameterDeclarationParams(_))
    }

    #[inline]
    pub fn is_ts_type_alias_declaration(&self) -> bool {
        matches!(
            self,
            Self::TSTypeAliasDeclarationId(_)
                | Self::TSTypeAliasDeclarationTypeAnnotation(_)
                | Self::TSTypeAliasDeclarationTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_class_implements(&self) -> bool {
        matches!(
            self,
            Self::TSClassImplementsExpression(_) | Self::TSClassImplementsTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_interface_declaration(&self) -> bool {
        matches!(
            self,
            Self::TSInterfaceDeclarationId(_)
                | Self::TSInterfaceDeclarationBody(_)
                | Self::TSInterfaceDeclarationTypeParameters(_)
                | Self::TSInterfaceDeclarationExtends(_)
        )
    }

    #[inline]
    pub fn is_ts_interface_body(&self) -> bool {
        matches!(self, Self::TSInterfaceBodyBody(_))
    }

    #[inline]
    pub fn is_ts_property_signature(&self) -> bool {
        matches!(self, Self::TSPropertySignatureKey(_) | Self::TSPropertySignatureTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_index_signature(&self) -> bool {
        matches!(
            self,
            Self::TSIndexSignatureParameters(_) | Self::TSIndexSignatureTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_call_signature_declaration(&self) -> bool {
        matches!(
            self,
            Self::TSCallSignatureDeclarationThisParam(_)
                | Self::TSCallSignatureDeclarationParams(_)
                | Self::TSCallSignatureDeclarationReturnType(_)
                | Self::TSCallSignatureDeclarationTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_method_signature(&self) -> bool {
        matches!(
            self,
            Self::TSMethodSignatureKey(_)
                | Self::TSMethodSignatureThisParam(_)
                | Self::TSMethodSignatureParams(_)
                | Self::TSMethodSignatureReturnType(_)
                | Self::TSMethodSignatureTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_construct_signature_declaration(&self) -> bool {
        matches!(
            self,
            Self::TSConstructSignatureDeclarationParams(_)
                | Self::TSConstructSignatureDeclarationReturnType(_)
                | Self::TSConstructSignatureDeclarationTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_index_signature_name(&self) -> bool {
        matches!(self, Self::TSIndexSignatureNameTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_interface_heritage(&self) -> bool {
        matches!(
            self,
            Self::TSInterfaceHeritageExpression(_) | Self::TSInterfaceHeritageTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_type_predicate(&self) -> bool {
        matches!(
            self,
            Self::TSTypePredicateParameterName(_) | Self::TSTypePredicateTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_module_declaration(&self) -> bool {
        matches!(self, Self::TSModuleDeclarationId(_) | Self::TSModuleDeclarationBody(_))
    }

    #[inline]
    pub fn is_ts_module_block(&self) -> bool {
        matches!(self, Self::TSModuleBlockBody(_))
    }

    #[inline]
    pub fn is_ts_type_literal(&self) -> bool {
        matches!(self, Self::TSTypeLiteralMembers(_))
    }

    #[inline]
    pub fn is_ts_infer_type(&self) -> bool {
        matches!(self, Self::TSInferTypeTypeParameter(_))
    }

    #[inline]
    pub fn is_ts_type_query(&self) -> bool {
        matches!(self, Self::TSTypeQueryExprName(_) | Self::TSTypeQueryTypeParameters(_))
    }

    #[inline]
    pub fn is_ts_import_type(&self) -> bool {
        matches!(
            self,
            Self::TSImportTypeArgument(_)
                | Self::TSImportTypeQualifier(_)
                | Self::TSImportTypeAttributes(_)
                | Self::TSImportTypeTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_import_attributes(&self) -> bool {
        matches!(self, Self::TSImportAttributesElements(_))
    }

    #[inline]
    pub fn is_ts_import_attribute(&self) -> bool {
        matches!(self, Self::TSImportAttributeName(_) | Self::TSImportAttributeValue(_))
    }

    #[inline]
    pub fn is_ts_function_type(&self) -> bool {
        matches!(
            self,
            Self::TSFunctionTypeThisParam(_)
                | Self::TSFunctionTypeParams(_)
                | Self::TSFunctionTypeReturnType(_)
                | Self::TSFunctionTypeTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_constructor_type(&self) -> bool {
        matches!(
            self,
            Self::TSConstructorTypeParams(_)
                | Self::TSConstructorTypeReturnType(_)
                | Self::TSConstructorTypeTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_mapped_type(&self) -> bool {
        matches!(
            self,
            Self::TSMappedTypeTypeParameter(_)
                | Self::TSMappedTypeNameType(_)
                | Self::TSMappedTypeTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_template_literal_type(&self) -> bool {
        matches!(self, Self::TSTemplateLiteralTypeQuasis(_) | Self::TSTemplateLiteralTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_as_expression(&self) -> bool {
        matches!(self, Self::TSAsExpressionExpression(_) | Self::TSAsExpressionTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_satisfies_expression(&self) -> bool {
        matches!(
            self,
            Self::TSSatisfiesExpressionExpression(_) | Self::TSSatisfiesExpressionTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_type_assertion(&self) -> bool {
        matches!(self, Self::TSTypeAssertionExpression(_) | Self::TSTypeAssertionTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_import_equals_declaration(&self) -> bool {
        matches!(
            self,
            Self::TSImportEqualsDeclarationId(_)
                | Self::TSImportEqualsDeclarationModuleReference(_)
        )
    }

    #[inline]
    pub fn is_ts_external_module_reference(&self) -> bool {
        matches!(self, Self::TSExternalModuleReferenceExpression(_))
    }

    #[inline]
    pub fn is_ts_non_null_expression(&self) -> bool {
        matches!(self, Self::TSNonNullExpressionExpression(_))
    }

    #[inline]
    pub fn is_decorator(&self) -> bool {
        matches!(self, Self::DecoratorExpression(_))
    }

    #[inline]
    pub fn is_ts_export_assignment(&self) -> bool {
        matches!(self, Self::TSExportAssignmentExpression(_))
    }

    #[inline]
    pub fn is_ts_namespace_export_declaration(&self) -> bool {
        matches!(self, Self::TSNamespaceExportDeclarationId(_))
    }

    #[inline]
    pub fn is_ts_instantiation_expression(&self) -> bool {
        matches!(
            self,
            Self::TSInstantiationExpressionExpression(_)
                | Self::TSInstantiationExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_js_doc_nullable_type(&self) -> bool {
        matches!(self, Self::JSDocNullableTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_via_statement(&self) -> bool {
        matches!(
            self,
            Self::ProgramBody(_)
                | Self::BlockStatementBody(_)
                | Self::IfStatementConsequent(_)
                | Self::IfStatementAlternate(_)
                | Self::DoWhileStatementBody(_)
                | Self::WhileStatementBody(_)
                | Self::ForStatementBody(_)
                | Self::ForInStatementBody(_)
                | Self::ForOfStatementBody(_)
                | Self::WithStatementBody(_)
                | Self::SwitchCaseConsequent(_)
                | Self::LabeledStatementBody(_)
                | Self::FunctionBodyStatements(_)
                | Self::StaticBlockBody(_)
                | Self::TSModuleBlockBody(_)
        )
    }

    #[inline]
    pub fn is_via_array_expression_element(&self) -> bool {
        matches!(self, Self::ArrayExpressionElements(_))
    }

    #[inline]
    pub fn is_via_object_property_kind(&self) -> bool {
        matches!(self, Self::ObjectExpressionProperties(_))
    }

    #[inline]
    pub fn is_via_property_key(&self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyKey(_)
                | Self::AssignmentTargetPropertyPropertyName(_)
                | Self::BindingPropertyKey(_)
                | Self::MethodDefinitionKey(_)
                | Self::PropertyDefinitionKey(_)
                | Self::AccessorPropertyKey(_)
                | Self::TSPropertySignatureKey(_)
                | Self::TSMethodSignatureKey(_)
        )
    }

    #[inline]
    pub fn is_via_expression(&self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyValue(_)
                | Self::ObjectPropertyInit(_)
                | Self::TemplateLiteralExpressions(_)
                | Self::TaggedTemplateExpressionTag(_)
                | Self::ComputedMemberExpressionObject(_)
                | Self::ComputedMemberExpressionExpression(_)
                | Self::StaticMemberExpressionObject(_)
                | Self::PrivateFieldExpressionObject(_)
                | Self::CallExpressionCallee(_)
                | Self::NewExpressionCallee(_)
                | Self::SpreadElementArgument(_)
                | Self::UnaryExpressionArgument(_)
                | Self::BinaryExpressionLeft(_)
                | Self::BinaryExpressionRight(_)
                | Self::PrivateInExpressionRight(_)
                | Self::LogicalExpressionLeft(_)
                | Self::LogicalExpressionRight(_)
                | Self::ConditionalExpressionTest(_)
                | Self::ConditionalExpressionConsequent(_)
                | Self::ConditionalExpressionAlternate(_)
                | Self::AssignmentExpressionRight(_)
                | Self::AssignmentTargetWithDefaultInit(_)
                | Self::AssignmentTargetPropertyIdentifierInit(_)
                | Self::SequenceExpressionExpressions(_)
                | Self::AwaitExpressionArgument(_)
                | Self::ParenthesizedExpressionExpression(_)
                | Self::VariableDeclaratorInit(_)
                | Self::ExpressionStatementExpression(_)
                | Self::IfStatementTest(_)
                | Self::DoWhileStatementTest(_)
                | Self::WhileStatementTest(_)
                | Self::ForStatementTest(_)
                | Self::ForStatementUpdate(_)
                | Self::ForInStatementRight(_)
                | Self::ForOfStatementRight(_)
                | Self::ReturnStatementArgument(_)
                | Self::WithStatementObject(_)
                | Self::SwitchStatementDiscriminant(_)
                | Self::SwitchCaseTest(_)
                | Self::ThrowStatementArgument(_)
                | Self::AssignmentPatternRight(_)
                | Self::YieldExpressionArgument(_)
                | Self::ClassSuperClass(_)
                | Self::PropertyDefinitionValue(_)
                | Self::AccessorPropertyValue(_)
                | Self::ImportExpressionSource(_)
                | Self::ImportExpressionArguments(_)
                | Self::JSXSpreadAttributeArgument(_)
                | Self::JSXSpreadChildExpression(_)
                | Self::TSEnumMemberInitializer(_)
                | Self::TSInterfaceHeritageExpression(_)
                | Self::TSImportAttributeValue(_)
                | Self::TSAsExpressionExpression(_)
                | Self::TSSatisfiesExpressionExpression(_)
                | Self::TSTypeAssertionExpression(_)
                | Self::TSNonNullExpressionExpression(_)
                | Self::DecoratorExpression(_)
                | Self::TSExportAssignmentExpression(_)
                | Self::TSInstantiationExpressionExpression(_)
        )
    }

    #[inline]
    pub fn is_via_argument(&self) -> bool {
        matches!(self, Self::CallExpressionArguments(_) | Self::NewExpressionArguments(_))
    }

    #[inline]
    pub fn is_via_simple_assignment_target(&self) -> bool {
        matches!(self, Self::UpdateExpressionArgument(_))
    }

    #[inline]
    pub fn is_via_assignment_target(&self) -> bool {
        matches!(
            self,
            Self::AssignmentExpressionLeft(_)
                | Self::AssignmentTargetRestTarget(_)
                | Self::AssignmentTargetWithDefaultBinding(_)
        )
    }

    #[inline]
    pub fn is_via_assignment_target_maybe_default(&self) -> bool {
        matches!(
            self,
            Self::ArrayAssignmentTargetElements(_)
                | Self::AssignmentTargetPropertyPropertyBinding(_)
        )
    }

    #[inline]
    pub fn is_via_assignment_target_property(&self) -> bool {
        matches!(self, Self::ObjectAssignmentTargetProperties(_))
    }

    #[inline]
    pub fn is_via_chain_element(&self) -> bool {
        matches!(self, Self::ChainExpressionExpression(_))
    }

    #[inline]
    pub fn is_via_for_statement_init(&self) -> bool {
        matches!(self, Self::ForStatementInit(_))
    }

    #[inline]
    pub fn is_via_for_statement_left(&self) -> bool {
        matches!(self, Self::ForInStatementLeft(_) | Self::ForOfStatementLeft(_))
    }

    #[inline]
    pub fn is_via_binding_pattern_kind(&self) -> bool {
        matches!(self, Self::BindingPatternKind(_))
    }

    #[inline]
    pub fn is_via_class_element(&self) -> bool {
        matches!(self, Self::ClassBodyBody(_))
    }

    #[inline]
    pub fn is_via_import_declaration_specifier(&self) -> bool {
        matches!(self, Self::ImportDeclarationSpecifiers(_))
    }

    #[inline]
    pub fn is_via_module_export_name(&self) -> bool {
        matches!(
            self,
            Self::ImportSpecifierImported(_)
                | Self::ExportDefaultDeclarationExported(_)
                | Self::ExportAllDeclarationExported(_)
                | Self::ExportSpecifierLocal(_)
                | Self::ExportSpecifierExported(_)
        )
    }

    #[inline]
    pub fn is_via_import_attribute_key(&self) -> bool {
        matches!(self, Self::ImportAttributeKey(_))
    }

    #[inline]
    pub fn is_via_declaration(&self) -> bool {
        matches!(self, Self::ExportNamedDeclarationDeclaration(_))
    }

    #[inline]
    pub fn is_via_export_default_declaration_kind(&self) -> bool {
        matches!(self, Self::ExportDefaultDeclarationDeclaration(_))
    }

    #[inline]
    pub fn is_via_jsx_child(&self) -> bool {
        matches!(self, Self::JSXElementChildren(_) | Self::JSXFragmentChildren(_))
    }

    #[inline]
    pub fn is_via_jsx_element_name(&self) -> bool {
        matches!(self, Self::JSXOpeningElementName(_) | Self::JSXClosingElementName(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_item(&self) -> bool {
        matches!(self, Self::JSXOpeningElementAttributes(_))
    }

    #[inline]
    pub fn is_via_jsx_member_expression_object(&self) -> bool {
        matches!(self, Self::JSXMemberExpressionObject(_))
    }

    #[inline]
    pub fn is_via_jsx_expression(&self) -> bool {
        matches!(self, Self::JSXExpressionContainerExpression(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_name(&self) -> bool {
        matches!(self, Self::JSXAttributeName(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_value(&self) -> bool {
        matches!(self, Self::JSXAttributeValue(_))
    }

    #[inline]
    pub fn is_via_ts_enum_member_name(&self) -> bool {
        matches!(self, Self::TSEnumMemberId(_))
    }

    #[inline]
    pub fn is_via_ts_type(&self) -> bool {
        matches!(
            self,
            Self::TSTypeAnnotationTypeAnnotation(_)
                | Self::TSConditionalTypeCheckType(_)
                | Self::TSConditionalTypeExtendsType(_)
                | Self::TSConditionalTypeTrueType(_)
                | Self::TSConditionalTypeFalseType(_)
                | Self::TSUnionTypeTypes(_)
                | Self::TSIntersectionTypeTypes(_)
                | Self::TSTypeOperatorTypeAnnotation(_)
                | Self::TSArrayTypeElementType(_)
                | Self::TSIndexedAccessTypeObjectType(_)
                | Self::TSIndexedAccessTypeIndexType(_)
                | Self::TSNamedTupleMemberElementType(_)
                | Self::TSOptionalTypeTypeAnnotation(_)
                | Self::TSRestTypeTypeAnnotation(_)
                | Self::TSTypeParameterInstantiationParams(_)
                | Self::TSTypeParameterConstraint(_)
                | Self::TSTypeParameterDefault(_)
                | Self::TSTypeAliasDeclarationTypeAnnotation(_)
                | Self::TSImportTypeArgument(_)
                | Self::TSMappedTypeNameType(_)
                | Self::TSMappedTypeTypeAnnotation(_)
                | Self::TSTemplateLiteralTypeTypes(_)
                | Self::TSAsExpressionTypeAnnotation(_)
                | Self::TSSatisfiesExpressionTypeAnnotation(_)
                | Self::TSTypeAssertionTypeAnnotation(_)
                | Self::JSDocNullableTypeTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_via_ts_literal(&self) -> bool {
        matches!(self, Self::TSLiteralTypeLiteral(_))
    }

    #[inline]
    pub fn is_via_ts_tuple_element(&self) -> bool {
        matches!(self, Self::TSTupleTypeElementTypes(_))
    }

    #[inline]
    pub fn is_via_ts_type_name(&self) -> bool {
        matches!(
            self,
            Self::TSTypeReferenceTypeName(_)
                | Self::TSQualifiedNameLeft(_)
                | Self::TSClassImplementsExpression(_)
                | Self::TSImportTypeQualifier(_)
        )
    }

    #[inline]
    pub fn is_via_ts_signature(&self) -> bool {
        matches!(self, Self::TSInterfaceBodyBody(_) | Self::TSTypeLiteralMembers(_))
    }

    #[inline]
    pub fn is_via_ts_type_predicate_name(&self) -> bool {
        matches!(self, Self::TSTypePredicateParameterName(_))
    }

    #[inline]
    pub fn is_via_ts_module_declaration_name(&self) -> bool {
        matches!(self, Self::TSModuleDeclarationId(_))
    }

    #[inline]
    pub fn is_via_ts_module_declaration_body(&self) -> bool {
        matches!(self, Self::TSModuleDeclarationBody(_))
    }

    #[inline]
    pub fn is_via_ts_type_query_expr_name(&self) -> bool {
        matches!(self, Self::TSTypeQueryExprName(_))
    }

    #[inline]
    pub fn is_via_ts_import_attribute_name(&self) -> bool {
        matches!(self, Self::TSImportAttributeName(_))
    }

    #[inline]
    pub fn is_via_ts_module_reference(&self) -> bool {
        matches!(self, Self::TSImportEqualsDeclarationModuleReference(_))
    }
}

pub(crate) const OFFSET_PROGRAM_SPAN: usize = offset_of!(Program, span);
pub(crate) const OFFSET_PROGRAM_SOURCE_TYPE: usize = offset_of!(Program, source_type);
pub(crate) const OFFSET_PROGRAM_DIRECTIVES: usize = offset_of!(Program, directives);
pub(crate) const OFFSET_PROGRAM_HASHBANG: usize = offset_of!(Program, hashbang);
pub(crate) const OFFSET_PROGRAM_BODY: usize = offset_of!(Program, body);
pub(crate) const OFFSET_PROGRAM_SCOPE_ID: usize = offset_of!(Program, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ProgramWithoutDirectives<'a>(pub(crate) *const Program<'a>);

impl<'a> ProgramWithoutDirectives<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(&self) -> &SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn hashbang(&self) -> &Option<Hashbang<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_HASHBANG) as *const Option<Hashbang<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_BODY) as *const Vec<'a, Statement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ProgramWithoutHashbang<'a>(pub(crate) *const Program<'a>);

impl<'a> ProgramWithoutHashbang<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(&self) -> &SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn directives(&self) -> &Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_BODY) as *const Vec<'a, Statement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ProgramWithoutBody<'a>(pub(crate) *const Program<'a>);

impl<'a> ProgramWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(&self) -> &SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn directives(&self) -> &Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }

    #[inline]
    pub fn hashbang(&self) -> &Option<Hashbang<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_HASHBANG) as *const Option<Hashbang<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_ARRAY_EXPRESSION_SPAN: usize = offset_of!(ArrayExpression, span);
pub(crate) const OFFSET_ARRAY_EXPRESSION_ELEMENTS: usize = offset_of!(ArrayExpression, elements);
pub(crate) const OFFSET_ARRAY_EXPRESSION_TRAILING_COMMA: usize =
    offset_of!(ArrayExpression, trailing_comma);

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrayExpressionWithoutElements<'a>(pub(crate) *const ArrayExpression<'a>);

impl<'a> ArrayExpressionWithoutElements<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn trailing_comma(&self) -> &Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_EXPRESSION_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_EXPRESSION_SPAN: usize = offset_of!(ObjectExpression, span);
pub(crate) const OFFSET_OBJECT_EXPRESSION_PROPERTIES: usize =
    offset_of!(ObjectExpression, properties);
pub(crate) const OFFSET_OBJECT_EXPRESSION_TRAILING_COMMA: usize =
    offset_of!(ObjectExpression, trailing_comma);

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectExpressionWithoutProperties<'a>(pub(crate) *const ObjectExpression<'a>);

impl<'a> ObjectExpressionWithoutProperties<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn trailing_comma(&self) -> &Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_EXPRESSION_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_PROPERTY_SPAN: usize = offset_of!(ObjectProperty, span);
pub(crate) const OFFSET_OBJECT_PROPERTY_KIND: usize = offset_of!(ObjectProperty, kind);
pub(crate) const OFFSET_OBJECT_PROPERTY_KEY: usize = offset_of!(ObjectProperty, key);
pub(crate) const OFFSET_OBJECT_PROPERTY_VALUE: usize = offset_of!(ObjectProperty, value);
pub(crate) const OFFSET_OBJECT_PROPERTY_INIT: usize = offset_of!(ObjectProperty, init);
pub(crate) const OFFSET_OBJECT_PROPERTY_METHOD: usize = offset_of!(ObjectProperty, method);
pub(crate) const OFFSET_OBJECT_PROPERTY_SHORTHAND: usize = offset_of!(ObjectProperty, shorthand);
pub(crate) const OFFSET_OBJECT_PROPERTY_COMPUTED: usize = offset_of!(ObjectProperty, computed);

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectPropertyWithoutKey<'a>(pub(crate) *const ObjectProperty<'a>);

impl<'a> ObjectPropertyWithoutKey<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn value(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_VALUE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn init(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn method(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectPropertyWithoutValue<'a>(pub(crate) *const ObjectProperty<'a>);

impl<'a> ObjectPropertyWithoutValue<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn init(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn method(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectPropertyWithoutInit<'a>(pub(crate) *const ObjectProperty<'a>);

impl<'a> ObjectPropertyWithoutInit<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_VALUE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn method(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

pub(crate) const OFFSET_TEMPLATE_LITERAL_SPAN: usize = offset_of!(TemplateLiteral, span);
pub(crate) const OFFSET_TEMPLATE_LITERAL_QUASIS: usize = offset_of!(TemplateLiteral, quasis);
pub(crate) const OFFSET_TEMPLATE_LITERAL_EXPRESSIONS: usize =
    offset_of!(TemplateLiteral, expressions);

#[repr(transparent)]
#[derive(Debug)]
pub struct TemplateLiteralWithoutQuasis<'a>(pub(crate) *const TemplateLiteral<'a>);

impl<'a> TemplateLiteralWithoutQuasis<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expressions(&self) -> &Vec<'a, Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_EXPRESSIONS)
                as *const Vec<'a, Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TemplateLiteralWithoutExpressions<'a>(pub(crate) *const TemplateLiteral<'a>);

impl<'a> TemplateLiteralWithoutExpressions<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_SPAN) as *const Span) }
    }

    #[inline]
    pub fn quasis(&self) -> &Vec<'a, TemplateElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_QUASIS)
                as *const Vec<'a, TemplateElement<'a>>)
        }
    }
}

pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN: usize =
    offset_of!(TaggedTemplateExpression, span);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG: usize =
    offset_of!(TaggedTemplateExpression, tag);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI: usize =
    offset_of!(TaggedTemplateExpression, quasi);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(TaggedTemplateExpression, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TaggedTemplateExpressionWithoutTag<'a>(pub(crate) *const TaggedTemplateExpression<'a>);

impl<'a> TaggedTemplateExpressionWithoutTag<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn quasi(&self) -> &TemplateLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI)
                as *const TemplateLiteral<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TaggedTemplateExpressionWithoutQuasi<'a>(pub(crate) *const TaggedTemplateExpression<'a>);

impl<'a> TaggedTemplateExpressionWithoutQuasi<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn tag(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TaggedTemplateExpressionWithoutTypeParameters<'a>(
    pub(crate) *const TaggedTemplateExpression<'a>,
);

impl<'a> TaggedTemplateExpressionWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn tag(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn quasi(&self) -> &TemplateLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI)
                as *const TemplateLiteral<'a>)
        }
    }
}

pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN: usize =
    offset_of!(ComputedMemberExpression, span);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(ComputedMemberExpression, object);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_EXPRESSION: usize =
    offset_of!(ComputedMemberExpression, expression);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL: usize =
    offset_of!(ComputedMemberExpression, optional);

#[repr(transparent)]
#[derive(Debug)]
pub struct ComputedMemberExpressionWithoutObject<'a>(
    pub(crate) *const ComputedMemberExpression<'a>,
);

impl<'a> ComputedMemberExpressionWithoutObject<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ComputedMemberExpressionWithoutExpression<'a>(
    pub(crate) *const ComputedMemberExpression<'a>,
);

impl<'a> ComputedMemberExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_SPAN: usize =
    offset_of!(StaticMemberExpression, span);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(StaticMemberExpression, object);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_PROPERTY: usize =
    offset_of!(StaticMemberExpression, property);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL: usize =
    offset_of!(StaticMemberExpression, optional);

#[repr(transparent)]
#[derive(Debug)]
pub struct StaticMemberExpressionWithoutObject<'a>(pub(crate) *const StaticMemberExpression<'a>);

impl<'a> StaticMemberExpressionWithoutObject<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn property(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_PROPERTY)
                as *const IdentifierName<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct StaticMemberExpressionWithoutProperty<'a>(pub(crate) *const StaticMemberExpression<'a>);

impl<'a> StaticMemberExpressionWithoutProperty<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN: usize =
    offset_of!(PrivateFieldExpression, span);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_OBJECT: usize =
    offset_of!(PrivateFieldExpression, object);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_FIELD: usize =
    offset_of!(PrivateFieldExpression, field);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL: usize =
    offset_of!(PrivateFieldExpression, optional);

#[repr(transparent)]
#[derive(Debug)]
pub struct PrivateFieldExpressionWithoutObject<'a>(pub(crate) *const PrivateFieldExpression<'a>);

impl<'a> PrivateFieldExpressionWithoutObject<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn field(&self) -> &PrivateIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_FIELD)
                as *const PrivateIdentifier<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct PrivateFieldExpressionWithoutField<'a>(pub(crate) *const PrivateFieldExpression<'a>);

impl<'a> PrivateFieldExpressionWithoutField<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_CALL_EXPRESSION_SPAN: usize = offset_of!(CallExpression, span);
pub(crate) const OFFSET_CALL_EXPRESSION_CALLEE: usize = offset_of!(CallExpression, callee);
pub(crate) const OFFSET_CALL_EXPRESSION_ARGUMENTS: usize = offset_of!(CallExpression, arguments);
pub(crate) const OFFSET_CALL_EXPRESSION_OPTIONAL: usize = offset_of!(CallExpression, optional);
pub(crate) const OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(CallExpression, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct CallExpressionWithoutCallee<'a>(pub(crate) *const CallExpression<'a>);

impl<'a> CallExpressionWithoutCallee<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn arguments(&self) -> &Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct CallExpressionWithoutArguments<'a>(pub(crate) *const CallExpression<'a>);

impl<'a> CallExpressionWithoutArguments<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct CallExpressionWithoutTypeParameters<'a>(pub(crate) *const CallExpression<'a>);

impl<'a> CallExpressionWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn arguments(&self) -> &Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }
}

pub(crate) const OFFSET_NEW_EXPRESSION_SPAN: usize = offset_of!(NewExpression, span);
pub(crate) const OFFSET_NEW_EXPRESSION_CALLEE: usize = offset_of!(NewExpression, callee);
pub(crate) const OFFSET_NEW_EXPRESSION_ARGUMENTS: usize = offset_of!(NewExpression, arguments);
pub(crate) const OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(NewExpression, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct NewExpressionWithoutCallee<'a>(pub(crate) *const NewExpression<'a>);

impl<'a> NewExpressionWithoutCallee<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn arguments(&self) -> &Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct NewExpressionWithoutArguments<'a>(pub(crate) *const NewExpression<'a>);

impl<'a> NewExpressionWithoutArguments<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct NewExpressionWithoutTypeParameters<'a>(pub(crate) *const NewExpression<'a>);

impl<'a> NewExpressionWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn arguments(&self) -> &Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }
}

pub(crate) const OFFSET_META_PROPERTY_SPAN: usize = offset_of!(MetaProperty, span);
pub(crate) const OFFSET_META_PROPERTY_META: usize = offset_of!(MetaProperty, meta);
pub(crate) const OFFSET_META_PROPERTY_PROPERTY: usize = offset_of!(MetaProperty, property);

#[repr(transparent)]
#[derive(Debug)]
pub struct MetaPropertyWithoutMeta<'a>(pub(crate) *const MetaProperty<'a>);

impl<'a> MetaPropertyWithoutMeta<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_PROPERTY)
                as *const IdentifierName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct MetaPropertyWithoutProperty<'a>(pub(crate) *const MetaProperty<'a>);

impl<'a> MetaPropertyWithoutProperty<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn meta(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_META) as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_SPREAD_ELEMENT_SPAN: usize = offset_of!(SpreadElement, span);
pub(crate) const OFFSET_SPREAD_ELEMENT_ARGUMENT: usize = offset_of!(SpreadElement, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct SpreadElementWithoutArgument<'a>(pub(crate) *const SpreadElement<'a>);

impl<'a> SpreadElementWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SPREAD_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_UPDATE_EXPRESSION_SPAN: usize = offset_of!(UpdateExpression, span);
pub(crate) const OFFSET_UPDATE_EXPRESSION_OPERATOR: usize = offset_of!(UpdateExpression, operator);
pub(crate) const OFFSET_UPDATE_EXPRESSION_PREFIX: usize = offset_of!(UpdateExpression, prefix);
pub(crate) const OFFSET_UPDATE_EXPRESSION_ARGUMENT: usize = offset_of!(UpdateExpression, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct UpdateExpressionWithoutArgument<'a>(pub(crate) *const UpdateExpression<'a>);

impl<'a> UpdateExpressionWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &UpdateOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_OPERATOR)
                as *const UpdateOperator)
        }
    }

    #[inline]
    pub fn prefix(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_PREFIX) as *const bool) }
    }
}

pub(crate) const OFFSET_UNARY_EXPRESSION_SPAN: usize = offset_of!(UnaryExpression, span);
pub(crate) const OFFSET_UNARY_EXPRESSION_OPERATOR: usize = offset_of!(UnaryExpression, operator);
pub(crate) const OFFSET_UNARY_EXPRESSION_ARGUMENT: usize = offset_of!(UnaryExpression, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct UnaryExpressionWithoutArgument<'a>(pub(crate) *const UnaryExpression<'a>);

impl<'a> UnaryExpressionWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UNARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &UnaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_UNARY_EXPRESSION_OPERATOR) as *const UnaryOperator)
        }
    }
}

pub(crate) const OFFSET_BINARY_EXPRESSION_SPAN: usize = offset_of!(BinaryExpression, span);
pub(crate) const OFFSET_BINARY_EXPRESSION_LEFT: usize = offset_of!(BinaryExpression, left);
pub(crate) const OFFSET_BINARY_EXPRESSION_OPERATOR: usize = offset_of!(BinaryExpression, operator);
pub(crate) const OFFSET_BINARY_EXPRESSION_RIGHT: usize = offset_of!(BinaryExpression, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct BinaryExpressionWithoutLeft<'a>(pub(crate) *const BinaryExpression<'a>);

impl<'a> BinaryExpressionWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct BinaryExpressionWithoutRight<'a>(pub(crate) *const BinaryExpression<'a>);

impl<'a> BinaryExpressionWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_LEFT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn operator(&self) -> &BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }
}

pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_SPAN: usize = offset_of!(PrivateInExpression, span);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_LEFT: usize = offset_of!(PrivateInExpression, left);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR: usize =
    offset_of!(PrivateInExpression, operator);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_RIGHT: usize = offset_of!(PrivateInExpression, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct PrivateInExpressionWithoutLeft<'a>(pub(crate) *const PrivateInExpression<'a>);

impl<'a> PrivateInExpressionWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_RIGHT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct PrivateInExpressionWithoutRight<'a>(pub(crate) *const PrivateInExpression<'a>);

impl<'a> PrivateInExpressionWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &PrivateIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_LEFT)
                as *const PrivateIdentifier<'a>)
        }
    }

    #[inline]
    pub fn operator(&self) -> &BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }
}

pub(crate) const OFFSET_LOGICAL_EXPRESSION_SPAN: usize = offset_of!(LogicalExpression, span);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_LEFT: usize = offset_of!(LogicalExpression, left);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_OPERATOR: usize =
    offset_of!(LogicalExpression, operator);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_RIGHT: usize = offset_of!(LogicalExpression, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct LogicalExpressionWithoutLeft<'a>(pub(crate) *const LogicalExpression<'a>);

impl<'a> LogicalExpressionWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &LogicalOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_OPERATOR)
                as *const LogicalOperator)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct LogicalExpressionWithoutRight<'a>(pub(crate) *const LogicalExpression<'a>);

impl<'a> LogicalExpressionWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_LEFT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn operator(&self) -> &LogicalOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_OPERATOR)
                as *const LogicalOperator)
        }
    }
}

pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_SPAN: usize =
    offset_of!(ConditionalExpression, span);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_TEST: usize =
    offset_of!(ConditionalExpression, test);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT: usize =
    offset_of!(ConditionalExpression, consequent);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE: usize =
    offset_of!(ConditionalExpression, alternate);

#[repr(transparent)]
#[derive(Debug)]
pub struct ConditionalExpressionWithoutTest<'a>(pub(crate) *const ConditionalExpression<'a>);

impl<'a> ConditionalExpressionWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn alternate(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ConditionalExpressionWithoutConsequent<'a>(pub(crate) *const ConditionalExpression<'a>);

impl<'a> ConditionalExpressionWithoutConsequent<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_TEST)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn alternate(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ConditionalExpressionWithoutAlternate<'a>(pub(crate) *const ConditionalExpression<'a>);

impl<'a> ConditionalExpressionWithoutAlternate<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_TEST)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn consequent(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_SPAN: usize = offset_of!(AssignmentExpression, span);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR: usize =
    offset_of!(AssignmentExpression, operator);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_LEFT: usize = offset_of!(AssignmentExpression, left);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_RIGHT: usize =
    offset_of!(AssignmentExpression, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentExpressionWithoutLeft<'a>(pub(crate) *const AssignmentExpression<'a>);

impl<'a> AssignmentExpressionWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &AssignmentOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR)
                as *const AssignmentOperator)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_RIGHT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentExpressionWithoutRight<'a>(pub(crate) *const AssignmentExpression<'a>);

impl<'a> AssignmentExpressionWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &AssignmentOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR)
                as *const AssignmentOperator)
        }
    }

    #[inline]
    pub fn left(&self) -> &AssignmentTarget<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_LEFT)
                as *const AssignmentTarget<'a>)
        }
    }
}

pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN: usize =
    offset_of!(ArrayAssignmentTarget, span);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_ELEMENTS: usize =
    offset_of!(ArrayAssignmentTarget, elements);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_REST: usize =
    offset_of!(ArrayAssignmentTarget, rest);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA: usize =
    offset_of!(ArrayAssignmentTarget, trailing_comma);

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrayAssignmentTargetWithoutElements<'a>(pub(crate) *const ArrayAssignmentTarget<'a>);

impl<'a> ArrayAssignmentTargetWithoutElements<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(&self) -> &Option<AssignmentTargetRest<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_REST)
                as *const Option<AssignmentTargetRest<'a>>)
        }
    }

    #[inline]
    pub fn trailing_comma(&self) -> &Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrayAssignmentTargetWithoutRest<'a>(pub(crate) *const ArrayAssignmentTarget<'a>);

impl<'a> ArrayAssignmentTargetWithoutRest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN) as *const Span) }
    }

    #[inline]
    pub fn elements(&self) -> &Vec<'a, Option<AssignmentTargetMaybeDefault<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_ELEMENTS)
                as *const Vec<'a, Option<AssignmentTargetMaybeDefault<'a>>>)
        }
    }

    #[inline]
    pub fn trailing_comma(&self) -> &Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN: usize =
    offset_of!(ObjectAssignmentTarget, span);
pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_PROPERTIES: usize =
    offset_of!(ObjectAssignmentTarget, properties);
pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_REST: usize =
    offset_of!(ObjectAssignmentTarget, rest);

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectAssignmentTargetWithoutProperties<'a>(
    pub(crate) *const ObjectAssignmentTarget<'a>,
);

impl<'a> ObjectAssignmentTargetWithoutProperties<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn rest(&self) -> &Option<AssignmentTargetRest<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_REST)
                as *const Option<AssignmentTargetRest<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectAssignmentTargetWithoutRest<'a>(pub(crate) *const ObjectAssignmentTarget<'a>);

impl<'a> ObjectAssignmentTargetWithoutRest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn properties(&self) -> &Vec<'a, AssignmentTargetProperty<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_PROPERTIES)
                as *const Vec<'a, AssignmentTargetProperty<'a>>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_REST_SPAN: usize = offset_of!(AssignmentTargetRest, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_REST_TARGET: usize =
    offset_of!(AssignmentTargetRest, target);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetRestWithoutTarget<'a>(pub(crate) *const AssignmentTargetRest<'a>);

impl<'a> AssignmentTargetRestWithoutTarget<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_REST_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN: usize =
    offset_of!(AssignmentTargetWithDefault, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_BINDING: usize =
    offset_of!(AssignmentTargetWithDefault, binding);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_INIT: usize =
    offset_of!(AssignmentTargetWithDefault, init);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetWithDefaultWithoutBinding<'a>(
    pub(crate) *const AssignmentTargetWithDefault<'a>,
);

impl<'a> AssignmentTargetWithDefaultWithoutBinding<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn init(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_INIT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetWithDefaultWithoutInit<'a>(
    pub(crate) *const AssignmentTargetWithDefault<'a>,
);

impl<'a> AssignmentTargetWithDefaultWithoutInit<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn binding(&self) -> &AssignmentTarget<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_BINDING)
                as *const AssignmentTarget<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_BINDING: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, binding);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_INIT: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, init);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetPropertyIdentifierWithoutBinding<'a>(
    pub(crate) *const AssignmentTargetPropertyIdentifier<'a>,
);

impl<'a> AssignmentTargetPropertyIdentifierWithoutBinding<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn init(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_INIT)
                as *const Option<Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetPropertyIdentifierWithoutInit<'a>(
    pub(crate) *const AssignmentTargetPropertyIdentifier<'a>,
);

impl<'a> AssignmentTargetPropertyIdentifierWithoutInit<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn binding(&self) -> &IdentifierReference<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_BINDING)
                as *const IdentifierReference<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN: usize =
    offset_of!(AssignmentTargetPropertyProperty, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_NAME: usize =
    offset_of!(AssignmentTargetPropertyProperty, name);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_BINDING: usize =
    offset_of!(AssignmentTargetPropertyProperty, binding);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetPropertyPropertyWithoutName<'a>(
    pub(crate) *const AssignmentTargetPropertyProperty<'a>,
);

impl<'a> AssignmentTargetPropertyPropertyWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn binding(&self) -> &AssignmentTargetMaybeDefault<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_BINDING)
                as *const AssignmentTargetMaybeDefault<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentTargetPropertyPropertyWithoutBinding<'a>(
    pub(crate) *const AssignmentTargetPropertyProperty<'a>,
);

impl<'a> AssignmentTargetPropertyPropertyWithoutBinding<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn name(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_NAME)
                as *const PropertyKey<'a>)
        }
    }
}

pub(crate) const OFFSET_SEQUENCE_EXPRESSION_SPAN: usize = offset_of!(SequenceExpression, span);
pub(crate) const OFFSET_SEQUENCE_EXPRESSION_EXPRESSIONS: usize =
    offset_of!(SequenceExpression, expressions);

#[repr(transparent)]
#[derive(Debug)]
pub struct SequenceExpressionWithoutExpressions<'a>(pub(crate) *const SequenceExpression<'a>);

impl<'a> SequenceExpressionWithoutExpressions<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SEQUENCE_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_AWAIT_EXPRESSION_SPAN: usize = offset_of!(AwaitExpression, span);
pub(crate) const OFFSET_AWAIT_EXPRESSION_ARGUMENT: usize = offset_of!(AwaitExpression, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct AwaitExpressionWithoutArgument<'a>(pub(crate) *const AwaitExpression<'a>);

impl<'a> AwaitExpressionWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_AWAIT_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_CHAIN_EXPRESSION_SPAN: usize = offset_of!(ChainExpression, span);
pub(crate) const OFFSET_CHAIN_EXPRESSION_EXPRESSION: usize =
    offset_of!(ChainExpression, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct ChainExpressionWithoutExpression<'a>(pub(crate) *const ChainExpression<'a>);

impl<'a> ChainExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CHAIN_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_PARENTHESIZED_EXPRESSION_SPAN: usize =
    offset_of!(ParenthesizedExpression, span);
pub(crate) const OFFSET_PARENTHESIZED_EXPRESSION_EXPRESSION: usize =
    offset_of!(ParenthesizedExpression, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct ParenthesizedExpressionWithoutExpression<'a>(
    pub(crate) *const ParenthesizedExpression<'a>,
);

impl<'a> ParenthesizedExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PARENTHESIZED_EXPRESSION_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_DIRECTIVE_SPAN: usize = offset_of!(Directive, span);
pub(crate) const OFFSET_DIRECTIVE_EXPRESSION: usize = offset_of!(Directive, expression);
pub(crate) const OFFSET_DIRECTIVE_DIRECTIVE: usize = offset_of!(Directive, directive);

#[repr(transparent)]
#[derive(Debug)]
pub struct DirectiveWithoutExpression<'a>(pub(crate) *const Directive<'a>);

impl<'a> DirectiveWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DIRECTIVE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn directive(&self) -> &Atom<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DIRECTIVE_DIRECTIVE) as *const Atom<'a>) }
    }
}

pub(crate) const OFFSET_BLOCK_STATEMENT_SPAN: usize = offset_of!(BlockStatement, span);
pub(crate) const OFFSET_BLOCK_STATEMENT_BODY: usize = offset_of!(BlockStatement, body);
pub(crate) const OFFSET_BLOCK_STATEMENT_SCOPE_ID: usize = offset_of!(BlockStatement, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct BlockStatementWithoutBody<'a>(pub(crate) *const BlockStatement<'a>);

impl<'a> BlockStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BLOCK_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BLOCK_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_VARIABLE_DECLARATION_SPAN: usize = offset_of!(VariableDeclaration, span);
pub(crate) const OFFSET_VARIABLE_DECLARATION_KIND: usize = offset_of!(VariableDeclaration, kind);
pub(crate) const OFFSET_VARIABLE_DECLARATION_DECLARATIONS: usize =
    offset_of!(VariableDeclaration, declarations);
pub(crate) const OFFSET_VARIABLE_DECLARATION_MODIFIERS: usize =
    offset_of!(VariableDeclaration, modifiers);

#[repr(transparent)]
#[derive(Debug)]
pub struct VariableDeclarationWithoutDeclarations<'a>(pub(crate) *const VariableDeclaration<'a>);

impl<'a> VariableDeclarationWithoutDeclarations<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

pub(crate) const OFFSET_VARIABLE_DECLARATOR_SPAN: usize = offset_of!(VariableDeclarator, span);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_KIND: usize = offset_of!(VariableDeclarator, kind);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_ID: usize = offset_of!(VariableDeclarator, id);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_INIT: usize = offset_of!(VariableDeclarator, init);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_DEFINITE: usize =
    offset_of!(VariableDeclarator, definite);

#[repr(transparent)]
#[derive(Debug)]
pub struct VariableDeclaratorWithoutId<'a>(pub(crate) *const VariableDeclarator<'a>);

impl<'a> VariableDeclaratorWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn init(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_DEFINITE) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct VariableDeclaratorWithoutInit<'a>(pub(crate) *const VariableDeclarator<'a>);

impl<'a> VariableDeclaratorWithoutInit<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_ID)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_DEFINITE) as *const bool) }
    }
}

pub(crate) const OFFSET_USING_DECLARATION_SPAN: usize = offset_of!(UsingDeclaration, span);
pub(crate) const OFFSET_USING_DECLARATION_IS_AWAIT: usize = offset_of!(UsingDeclaration, is_await);
pub(crate) const OFFSET_USING_DECLARATION_DECLARATIONS: usize =
    offset_of!(UsingDeclaration, declarations);

#[repr(transparent)]
#[derive(Debug)]
pub struct UsingDeclarationWithoutDeclarations<'a>(pub(crate) *const UsingDeclaration<'a>);

impl<'a> UsingDeclarationWithoutDeclarations<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_USING_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn is_await(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_USING_DECLARATION_IS_AWAIT) as *const bool) }
    }
}

pub(crate) const OFFSET_EXPRESSION_STATEMENT_SPAN: usize = offset_of!(ExpressionStatement, span);
pub(crate) const OFFSET_EXPRESSION_STATEMENT_EXPRESSION: usize =
    offset_of!(ExpressionStatement, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct ExpressionStatementWithoutExpression<'a>(pub(crate) *const ExpressionStatement<'a>);

impl<'a> ExpressionStatementWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPRESSION_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_IF_STATEMENT_SPAN: usize = offset_of!(IfStatement, span);
pub(crate) const OFFSET_IF_STATEMENT_TEST: usize = offset_of!(IfStatement, test);
pub(crate) const OFFSET_IF_STATEMENT_CONSEQUENT: usize = offset_of!(IfStatement, consequent);
pub(crate) const OFFSET_IF_STATEMENT_ALTERNATE: usize = offset_of!(IfStatement, alternate);

#[repr(transparent)]
#[derive(Debug)]
pub struct IfStatementWithoutTest<'a>(pub(crate) *const IfStatement<'a>);

impl<'a> IfStatementWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_CONSEQUENT) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn alternate(&self) -> &Option<Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_ALTERNATE)
                as *const Option<Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct IfStatementWithoutConsequent<'a>(pub(crate) *const IfStatement<'a>);

impl<'a> IfStatementWithoutConsequent<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_TEST) as *const Expression<'a>) }
    }

    #[inline]
    pub fn alternate(&self) -> &Option<Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_ALTERNATE)
                as *const Option<Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct IfStatementWithoutAlternate<'a>(pub(crate) *const IfStatement<'a>);

impl<'a> IfStatementWithoutAlternate<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_TEST) as *const Expression<'a>) }
    }

    #[inline]
    pub fn consequent(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_CONSEQUENT) as *const Statement<'a>)
        }
    }
}

pub(crate) const OFFSET_DO_WHILE_STATEMENT_SPAN: usize = offset_of!(DoWhileStatement, span);
pub(crate) const OFFSET_DO_WHILE_STATEMENT_BODY: usize = offset_of!(DoWhileStatement, body);
pub(crate) const OFFSET_DO_WHILE_STATEMENT_TEST: usize = offset_of!(DoWhileStatement, test);

#[repr(transparent)]
#[derive(Debug)]
pub struct DoWhileStatementWithoutBody<'a>(pub(crate) *const DoWhileStatement<'a>);

impl<'a> DoWhileStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_TEST) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct DoWhileStatementWithoutTest<'a>(pub(crate) *const DoWhileStatement<'a>);

impl<'a> DoWhileStatementWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

pub(crate) const OFFSET_WHILE_STATEMENT_SPAN: usize = offset_of!(WhileStatement, span);
pub(crate) const OFFSET_WHILE_STATEMENT_TEST: usize = offset_of!(WhileStatement, test);
pub(crate) const OFFSET_WHILE_STATEMENT_BODY: usize = offset_of!(WhileStatement, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct WhileStatementWithoutTest<'a>(pub(crate) *const WhileStatement<'a>);

impl<'a> WhileStatementWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct WhileStatementWithoutBody<'a>(pub(crate) *const WhileStatement<'a>);

impl<'a> WhileStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_TEST) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_FOR_STATEMENT_SPAN: usize = offset_of!(ForStatement, span);
pub(crate) const OFFSET_FOR_STATEMENT_INIT: usize = offset_of!(ForStatement, init);
pub(crate) const OFFSET_FOR_STATEMENT_TEST: usize = offset_of!(ForStatement, test);
pub(crate) const OFFSET_FOR_STATEMENT_UPDATE: usize = offset_of!(ForStatement, update);
pub(crate) const OFFSET_FOR_STATEMENT_BODY: usize = offset_of!(ForStatement, body);
pub(crate) const OFFSET_FOR_STATEMENT_SCOPE_ID: usize = offset_of!(ForStatement, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ForStatementWithoutInit<'a>(pub(crate) *const ForStatement<'a>);

impl<'a> ForStatementWithoutInit<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn update(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForStatementWithoutTest<'a>(pub(crate) *const ForStatement<'a>);

impl<'a> ForStatementWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(&self) -> &Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn update(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForStatementWithoutUpdate<'a>(pub(crate) *const ForStatement<'a>);

impl<'a> ForStatementWithoutUpdate<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(&self) -> &Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn test(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForStatementWithoutBody<'a>(pub(crate) *const ForStatement<'a>);

impl<'a> ForStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(&self) -> &Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn test(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn update(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FOR_IN_STATEMENT_SPAN: usize = offset_of!(ForInStatement, span);
pub(crate) const OFFSET_FOR_IN_STATEMENT_LEFT: usize = offset_of!(ForInStatement, left);
pub(crate) const OFFSET_FOR_IN_STATEMENT_RIGHT: usize = offset_of!(ForInStatement, right);
pub(crate) const OFFSET_FOR_IN_STATEMENT_BODY: usize = offset_of!(ForInStatement, body);
pub(crate) const OFFSET_FOR_IN_STATEMENT_SCOPE_ID: usize = offset_of!(ForInStatement, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ForInStatementWithoutLeft<'a>(pub(crate) *const ForInStatement<'a>);

impl<'a> ForInStatementWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForInStatementWithoutRight<'a>(pub(crate) *const ForInStatement<'a>);

impl<'a> ForInStatementWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForInStatementWithoutBody<'a>(pub(crate) *const ForInStatement<'a>);

impl<'a> ForInStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FOR_OF_STATEMENT_SPAN: usize = offset_of!(ForOfStatement, span);
pub(crate) const OFFSET_FOR_OF_STATEMENT_AWAIT: usize = offset_of!(ForOfStatement, r#await);
pub(crate) const OFFSET_FOR_OF_STATEMENT_LEFT: usize = offset_of!(ForOfStatement, left);
pub(crate) const OFFSET_FOR_OF_STATEMENT_RIGHT: usize = offset_of!(ForOfStatement, right);
pub(crate) const OFFSET_FOR_OF_STATEMENT_BODY: usize = offset_of!(ForOfStatement, body);
pub(crate) const OFFSET_FOR_OF_STATEMENT_SCOPE_ID: usize = offset_of!(ForOfStatement, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ForOfStatementWithoutLeft<'a>(pub(crate) *const ForOfStatement<'a>);

impl<'a> ForOfStatementWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForOfStatementWithoutRight<'a>(pub(crate) *const ForOfStatement<'a>);

impl<'a> ForOfStatementWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn left(&self) -> &ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ForOfStatementWithoutBody<'a>(pub(crate) *const ForOfStatement<'a>);

impl<'a> ForOfStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn left(&self) -> &ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CONTINUE_STATEMENT_SPAN: usize = offset_of!(ContinueStatement, span);
pub(crate) const OFFSET_CONTINUE_STATEMENT_LABEL: usize = offset_of!(ContinueStatement, label);

#[repr(transparent)]
#[derive(Debug)]
pub struct ContinueStatementWithoutLabel<'a>(pub(crate) *const ContinueStatement<'a>);

impl<'a> ContinueStatementWithoutLabel<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONTINUE_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_BREAK_STATEMENT_SPAN: usize = offset_of!(BreakStatement, span);
pub(crate) const OFFSET_BREAK_STATEMENT_LABEL: usize = offset_of!(BreakStatement, label);

#[repr(transparent)]
#[derive(Debug)]
pub struct BreakStatementWithoutLabel<'a>(pub(crate) *const BreakStatement<'a>);

impl<'a> BreakStatementWithoutLabel<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BREAK_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_RETURN_STATEMENT_SPAN: usize = offset_of!(ReturnStatement, span);
pub(crate) const OFFSET_RETURN_STATEMENT_ARGUMENT: usize = offset_of!(ReturnStatement, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct ReturnStatementWithoutArgument<'a>(pub(crate) *const ReturnStatement<'a>);

impl<'a> ReturnStatementWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_RETURN_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_WITH_STATEMENT_SPAN: usize = offset_of!(WithStatement, span);
pub(crate) const OFFSET_WITH_STATEMENT_OBJECT: usize = offset_of!(WithStatement, object);
pub(crate) const OFFSET_WITH_STATEMENT_BODY: usize = offset_of!(WithStatement, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct WithStatementWithoutObject<'a>(pub(crate) *const WithStatement<'a>);

impl<'a> WithStatementWithoutObject<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_BODY) as *const Statement<'a>) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct WithStatementWithoutBody<'a>(pub(crate) *const WithStatement<'a>);

impl<'a> WithStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_OBJECT) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_SWITCH_STATEMENT_SPAN: usize = offset_of!(SwitchStatement, span);
pub(crate) const OFFSET_SWITCH_STATEMENT_DISCRIMINANT: usize =
    offset_of!(SwitchStatement, discriminant);
pub(crate) const OFFSET_SWITCH_STATEMENT_CASES: usize = offset_of!(SwitchStatement, cases);
pub(crate) const OFFSET_SWITCH_STATEMENT_SCOPE_ID: usize = offset_of!(SwitchStatement, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct SwitchStatementWithoutDiscriminant<'a>(pub(crate) *const SwitchStatement<'a>);

impl<'a> SwitchStatementWithoutDiscriminant<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn cases(&self) -> &Vec<'a, SwitchCase<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_CASES)
                as *const Vec<'a, SwitchCase<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct SwitchStatementWithoutCases<'a>(pub(crate) *const SwitchStatement<'a>);

impl<'a> SwitchStatementWithoutCases<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn discriminant(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_DISCRIMINANT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_SWITCH_CASE_SPAN: usize = offset_of!(SwitchCase, span);
pub(crate) const OFFSET_SWITCH_CASE_TEST: usize = offset_of!(SwitchCase, test);
pub(crate) const OFFSET_SWITCH_CASE_CONSEQUENT: usize = offset_of!(SwitchCase, consequent);

#[repr(transparent)]
#[derive(Debug)]
pub struct SwitchCaseWithoutTest<'a>(pub(crate) *const SwitchCase<'a>);

impl<'a> SwitchCaseWithoutTest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(&self) -> &Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_CONSEQUENT)
                as *const Vec<'a, Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct SwitchCaseWithoutConsequent<'a>(pub(crate) *const SwitchCase<'a>);

impl<'a> SwitchCaseWithoutConsequent<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_TEST) as *const Option<Expression<'a>>)
        }
    }
}

pub(crate) const OFFSET_LABELED_STATEMENT_SPAN: usize = offset_of!(LabeledStatement, span);
pub(crate) const OFFSET_LABELED_STATEMENT_LABEL: usize = offset_of!(LabeledStatement, label);
pub(crate) const OFFSET_LABELED_STATEMENT_BODY: usize = offset_of!(LabeledStatement, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct LabeledStatementWithoutLabel<'a>(pub(crate) *const LabeledStatement<'a>);

impl<'a> LabeledStatementWithoutLabel<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct LabeledStatementWithoutBody<'a>(pub(crate) *const LabeledStatement<'a>);

impl<'a> LabeledStatementWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn label(&self) -> &LabelIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_LABEL)
                as *const LabelIdentifier<'a>)
        }
    }
}

pub(crate) const OFFSET_THROW_STATEMENT_SPAN: usize = offset_of!(ThrowStatement, span);
pub(crate) const OFFSET_THROW_STATEMENT_ARGUMENT: usize = offset_of!(ThrowStatement, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct ThrowStatementWithoutArgument<'a>(pub(crate) *const ThrowStatement<'a>);

impl<'a> ThrowStatementWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_THROW_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TRY_STATEMENT_SPAN: usize = offset_of!(TryStatement, span);
pub(crate) const OFFSET_TRY_STATEMENT_BLOCK: usize = offset_of!(TryStatement, block);
pub(crate) const OFFSET_TRY_STATEMENT_HANDLER: usize = offset_of!(TryStatement, handler);
pub(crate) const OFFSET_TRY_STATEMENT_FINALIZER: usize = offset_of!(TryStatement, finalizer);

#[repr(transparent)]
#[derive(Debug)]
pub struct TryStatementWithoutBlock<'a>(pub(crate) *const TryStatement<'a>);

impl<'a> TryStatementWithoutBlock<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn handler(&self) -> &Option<Box<'a, CatchClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_HANDLER)
                as *const Option<Box<'a, CatchClause<'a>>>)
        }
    }

    #[inline]
    pub fn finalizer(&self) -> &Option<Box<'a, BlockStatement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_FINALIZER)
                as *const Option<Box<'a, BlockStatement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TryStatementWithoutHandler<'a>(pub(crate) *const TryStatement<'a>);

impl<'a> TryStatementWithoutHandler<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn block(&self) -> &Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_BLOCK)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn finalizer(&self) -> &Option<Box<'a, BlockStatement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_FINALIZER)
                as *const Option<Box<'a, BlockStatement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TryStatementWithoutFinalizer<'a>(pub(crate) *const TryStatement<'a>);

impl<'a> TryStatementWithoutFinalizer<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn block(&self) -> &Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_BLOCK)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn handler(&self) -> &Option<Box<'a, CatchClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_HANDLER)
                as *const Option<Box<'a, CatchClause<'a>>>)
        }
    }
}

pub(crate) const OFFSET_CATCH_CLAUSE_SPAN: usize = offset_of!(CatchClause, span);
pub(crate) const OFFSET_CATCH_CLAUSE_PARAM: usize = offset_of!(CatchClause, param);
pub(crate) const OFFSET_CATCH_CLAUSE_BODY: usize = offset_of!(CatchClause, body);
pub(crate) const OFFSET_CATCH_CLAUSE_SCOPE_ID: usize = offset_of!(CatchClause, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct CatchClauseWithoutParam<'a>(pub(crate) *const CatchClause<'a>);

impl<'a> CatchClauseWithoutParam<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_BODY)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct CatchClauseWithoutBody<'a>(pub(crate) *const CatchClause<'a>);

impl<'a> CatchClauseWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn param(&self) -> &Option<CatchParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_PARAM)
                as *const Option<CatchParameter<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CATCH_PARAMETER_SPAN: usize = offset_of!(CatchParameter, span);
pub(crate) const OFFSET_CATCH_PARAMETER_PATTERN: usize = offset_of!(CatchParameter, pattern);

#[repr(transparent)]
#[derive(Debug)]
pub struct CatchParameterWithoutPattern<'a>(pub(crate) *const CatchParameter<'a>);

impl<'a> CatchParameterWithoutPattern<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_PARAMETER_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_BINDING_PATTERN_KIND: usize = offset_of!(BindingPattern, kind);
pub(crate) const OFFSET_BINDING_PATTERN_TYPE_ANNOTATION: usize =
    offset_of!(BindingPattern, type_annotation);
pub(crate) const OFFSET_BINDING_PATTERN_OPTIONAL: usize = offset_of!(BindingPattern, optional);

#[repr(transparent)]
#[derive(Debug)]
pub struct BindingPatternWithoutKind<'a>(pub(crate) *const BindingPattern<'a>);

impl<'a> BindingPatternWithoutKind<'a> {
    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_OPTIONAL) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct BindingPatternWithoutTypeAnnotation<'a>(pub(crate) *const BindingPattern<'a>);

impl<'a> BindingPatternWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn kind(&self) -> &BindingPatternKind<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_KIND)
                as *const BindingPatternKind<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_OPTIONAL) as *const bool) }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_PATTERN_SPAN: usize = offset_of!(AssignmentPattern, span);
pub(crate) const OFFSET_ASSIGNMENT_PATTERN_LEFT: usize = offset_of!(AssignmentPattern, left);
pub(crate) const OFFSET_ASSIGNMENT_PATTERN_RIGHT: usize = offset_of!(AssignmentPattern, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentPatternWithoutLeft<'a>(pub(crate) *const AssignmentPattern<'a>);

impl<'a> AssignmentPatternWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AssignmentPatternWithoutRight<'a>(pub(crate) *const AssignmentPattern<'a>);

impl<'a> AssignmentPatternWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_LEFT)
                as *const BindingPattern<'a>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_PATTERN_SPAN: usize = offset_of!(ObjectPattern, span);
pub(crate) const OFFSET_OBJECT_PATTERN_PROPERTIES: usize = offset_of!(ObjectPattern, properties);
pub(crate) const OFFSET_OBJECT_PATTERN_REST: usize = offset_of!(ObjectPattern, rest);

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectPatternWithoutProperties<'a>(pub(crate) *const ObjectPattern<'a>);

impl<'a> ObjectPatternWithoutProperties<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(&self) -> &Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ObjectPatternWithoutRest<'a>(pub(crate) *const ObjectPattern<'a>);

impl<'a> ObjectPatternWithoutRest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn properties(&self) -> &Vec<'a, BindingProperty<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_PROPERTIES)
                as *const Vec<'a, BindingProperty<'a>>)
        }
    }
}

pub(crate) const OFFSET_BINDING_PROPERTY_SPAN: usize = offset_of!(BindingProperty, span);
pub(crate) const OFFSET_BINDING_PROPERTY_KEY: usize = offset_of!(BindingProperty, key);
pub(crate) const OFFSET_BINDING_PROPERTY_VALUE: usize = offset_of!(BindingProperty, value);
pub(crate) const OFFSET_BINDING_PROPERTY_SHORTHAND: usize = offset_of!(BindingProperty, shorthand);
pub(crate) const OFFSET_BINDING_PROPERTY_COMPUTED: usize = offset_of!(BindingProperty, computed);

#[repr(transparent)]
#[derive(Debug)]
pub struct BindingPropertyWithoutKey<'a>(pub(crate) *const BindingProperty<'a>);

impl<'a> BindingPropertyWithoutKey<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_VALUE)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn shorthand(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct BindingPropertyWithoutValue<'a>(pub(crate) *const BindingProperty<'a>);

impl<'a> BindingPropertyWithoutValue<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn shorthand(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_COMPUTED) as *const bool) }
    }
}

pub(crate) const OFFSET_ARRAY_PATTERN_SPAN: usize = offset_of!(ArrayPattern, span);
pub(crate) const OFFSET_ARRAY_PATTERN_ELEMENTS: usize = offset_of!(ArrayPattern, elements);
pub(crate) const OFFSET_ARRAY_PATTERN_REST: usize = offset_of!(ArrayPattern, rest);

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrayPatternWithoutElements<'a>(pub(crate) *const ArrayPattern<'a>);

impl<'a> ArrayPatternWithoutElements<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(&self) -> &Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrayPatternWithoutRest<'a>(pub(crate) *const ArrayPattern<'a>);

impl<'a> ArrayPatternWithoutRest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn elements(&self) -> &Vec<'a, Option<BindingPattern<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_ELEMENTS)
                as *const Vec<'a, Option<BindingPattern<'a>>>)
        }
    }
}

pub(crate) const OFFSET_BINDING_REST_ELEMENT_SPAN: usize = offset_of!(BindingRestElement, span);
pub(crate) const OFFSET_BINDING_REST_ELEMENT_ARGUMENT: usize =
    offset_of!(BindingRestElement, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct BindingRestElementWithoutArgument<'a>(pub(crate) *const BindingRestElement<'a>);

impl<'a> BindingRestElementWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_REST_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_FUNCTION_TYPE: usize = offset_of!(Function, r#type);
pub(crate) const OFFSET_FUNCTION_SPAN: usize = offset_of!(Function, span);
pub(crate) const OFFSET_FUNCTION_ID: usize = offset_of!(Function, id);
pub(crate) const OFFSET_FUNCTION_GENERATOR: usize = offset_of!(Function, generator);
pub(crate) const OFFSET_FUNCTION_ASYNC: usize = offset_of!(Function, r#async);
pub(crate) const OFFSET_FUNCTION_TYPE_PARAMETERS: usize = offset_of!(Function, type_parameters);
pub(crate) const OFFSET_FUNCTION_THIS_PARAM: usize = offset_of!(Function, this_param);
pub(crate) const OFFSET_FUNCTION_PARAMS: usize = offset_of!(Function, params);
pub(crate) const OFFSET_FUNCTION_BODY: usize = offset_of!(Function, body);
pub(crate) const OFFSET_FUNCTION_RETURN_TYPE: usize = offset_of!(Function, return_type);
pub(crate) const OFFSET_FUNCTION_MODIFIERS: usize = offset_of!(Function, modifiers);
pub(crate) const OFFSET_FUNCTION_SCOPE_ID: usize = offset_of!(Function, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutId<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutId<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutTypeParameters<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutTypeParameters<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutThisParam<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutThisParam<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutParams<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutParams<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutBody<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutBody<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionWithoutReturnType<'a>(pub(crate) *const Function<'a>);

impl<'a> FunctionWithoutReturnType<'a> {
    #[inline]
    pub fn r#type(&self) -> &FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FORMAL_PARAMETERS_SPAN: usize = offset_of!(FormalParameters, span);
pub(crate) const OFFSET_FORMAL_PARAMETERS_KIND: usize = offset_of!(FormalParameters, kind);
pub(crate) const OFFSET_FORMAL_PARAMETERS_ITEMS: usize = offset_of!(FormalParameters, items);
pub(crate) const OFFSET_FORMAL_PARAMETERS_REST: usize = offset_of!(FormalParameters, rest);

#[repr(transparent)]
#[derive(Debug)]
pub struct FormalParametersWithoutItems<'a>(pub(crate) *const FormalParameters<'a>);

impl<'a> FormalParametersWithoutItems<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &FormalParameterKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_KIND)
                as *const FormalParameterKind)
        }
    }

    #[inline]
    pub fn rest(&self) -> &Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FormalParametersWithoutRest<'a>(pub(crate) *const FormalParameters<'a>);

impl<'a> FormalParametersWithoutRest<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(&self) -> &FormalParameterKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_KIND)
                as *const FormalParameterKind)
        }
    }

    #[inline]
    pub fn items(&self) -> &Vec<'a, FormalParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_ITEMS)
                as *const Vec<'a, FormalParameter<'a>>)
        }
    }
}

pub(crate) const OFFSET_FORMAL_PARAMETER_SPAN: usize = offset_of!(FormalParameter, span);
pub(crate) const OFFSET_FORMAL_PARAMETER_PATTERN: usize = offset_of!(FormalParameter, pattern);
pub(crate) const OFFSET_FORMAL_PARAMETER_ACCESSIBILITY: usize =
    offset_of!(FormalParameter, accessibility);
pub(crate) const OFFSET_FORMAL_PARAMETER_READONLY: usize = offset_of!(FormalParameter, readonly);
pub(crate) const OFFSET_FORMAL_PARAMETER_OVERRIDE: usize = offset_of!(FormalParameter, r#override);
pub(crate) const OFFSET_FORMAL_PARAMETER_DECORATORS: usize =
    offset_of!(FormalParameter, decorators);

#[repr(transparent)]
#[derive(Debug)]
pub struct FormalParameterWithoutPattern<'a>(pub(crate) *const FormalParameter<'a>);

impl<'a> FormalParameterWithoutPattern<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_READONLY) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FormalParameterWithoutDecorators<'a>(pub(crate) *const FormalParameter<'a>);

impl<'a> FormalParameterWithoutDecorators<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn pattern(&self) -> &BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_PATTERN)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_READONLY) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_OVERRIDE) as *const bool) }
    }
}

pub(crate) const OFFSET_FUNCTION_BODY_SPAN: usize = offset_of!(FunctionBody, span);
pub(crate) const OFFSET_FUNCTION_BODY_DIRECTIVES: usize = offset_of!(FunctionBody, directives);
pub(crate) const OFFSET_FUNCTION_BODY_STATEMENTS: usize = offset_of!(FunctionBody, statements);

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionBodyWithoutDirectives<'a>(pub(crate) *const FunctionBody<'a>);

impl<'a> FunctionBodyWithoutDirectives<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn statements(&self) -> &Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_STATEMENTS)
                as *const Vec<'a, Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct FunctionBodyWithoutStatements<'a>(pub(crate) *const FunctionBody<'a>);

impl<'a> FunctionBodyWithoutStatements<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn directives(&self) -> &Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }
}

pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN: usize =
    offset_of!(ArrowFunctionExpression, span);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION: usize =
    offset_of!(ArrowFunctionExpression, expression);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC: usize =
    offset_of!(ArrowFunctionExpression, r#async);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS: usize =
    offset_of!(ArrowFunctionExpression, params);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_BODY: usize =
    offset_of!(ArrowFunctionExpression, body);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(ArrowFunctionExpression, type_parameters);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE: usize =
    offset_of!(ArrowFunctionExpression, return_type);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID: usize =
    offset_of!(ArrowFunctionExpression, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrowFunctionExpressionWithoutParams<'a>(pub(crate) *const ArrowFunctionExpression<'a>);

impl<'a> ArrowFunctionExpressionWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrowFunctionExpressionWithoutBody<'a>(pub(crate) *const ArrowFunctionExpression<'a>);

impl<'a> ArrowFunctionExpressionWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrowFunctionExpressionWithoutTypeParameters<'a>(
    pub(crate) *const ArrowFunctionExpression<'a>,
);

impl<'a> ArrowFunctionExpressionWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ArrowFunctionExpressionWithoutReturnType<'a>(
    pub(crate) *const ArrowFunctionExpression<'a>,
);

impl<'a> ArrowFunctionExpressionWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_YIELD_EXPRESSION_SPAN: usize = offset_of!(YieldExpression, span);
pub(crate) const OFFSET_YIELD_EXPRESSION_DELEGATE: usize = offset_of!(YieldExpression, delegate);
pub(crate) const OFFSET_YIELD_EXPRESSION_ARGUMENT: usize = offset_of!(YieldExpression, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct YieldExpressionWithoutArgument<'a>(pub(crate) *const YieldExpression<'a>);

impl<'a> YieldExpressionWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_YIELD_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn delegate(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_YIELD_EXPRESSION_DELEGATE) as *const bool) }
    }
}

pub(crate) const OFFSET_CLASS_TYPE: usize = offset_of!(Class, r#type);
pub(crate) const OFFSET_CLASS_SPAN: usize = offset_of!(Class, span);
pub(crate) const OFFSET_CLASS_DECORATORS: usize = offset_of!(Class, decorators);
pub(crate) const OFFSET_CLASS_ID: usize = offset_of!(Class, id);
pub(crate) const OFFSET_CLASS_SUPER_CLASS: usize = offset_of!(Class, super_class);
pub(crate) const OFFSET_CLASS_BODY: usize = offset_of!(Class, body);
pub(crate) const OFFSET_CLASS_TYPE_PARAMETERS: usize = offset_of!(Class, type_parameters);
pub(crate) const OFFSET_CLASS_SUPER_TYPE_PARAMETERS: usize =
    offset_of!(Class, super_type_parameters);
pub(crate) const OFFSET_CLASS_IMPLEMENTS: usize = offset_of!(Class, implements);
pub(crate) const OFFSET_CLASS_MODIFIERS: usize = offset_of!(Class, modifiers);
pub(crate) const OFFSET_CLASS_SCOPE_ID: usize = offset_of!(Class, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutDecorators<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutDecorators<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutId<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutId<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutSuperClass<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutSuperClass<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutBody<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutBody<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutTypeParameters<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutTypeParameters<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutSuperTypeParameters<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutSuperTypeParameters<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn implements(&self) -> &Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassWithoutImplements<'a>(pub(crate) *const Class<'a>);

impl<'a> ClassWithoutImplements<'a> {
    #[inline]
    pub fn r#type(&self) -> &ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(&self) -> &Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_MODIFIERS) as *const Modifiers<'a>) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CLASS_BODY_SPAN: usize = offset_of!(ClassBody, span);
pub(crate) const OFFSET_CLASS_BODY_BODY: usize = offset_of!(ClassBody, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct ClassBodyWithoutBody<'a>(pub(crate) *const ClassBody<'a>);

impl<'a> ClassBodyWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_METHOD_DEFINITION_TYPE: usize = offset_of!(MethodDefinition, r#type);
pub(crate) const OFFSET_METHOD_DEFINITION_SPAN: usize = offset_of!(MethodDefinition, span);
pub(crate) const OFFSET_METHOD_DEFINITION_DECORATORS: usize =
    offset_of!(MethodDefinition, decorators);
pub(crate) const OFFSET_METHOD_DEFINITION_KEY: usize = offset_of!(MethodDefinition, key);
pub(crate) const OFFSET_METHOD_DEFINITION_VALUE: usize = offset_of!(MethodDefinition, value);
pub(crate) const OFFSET_METHOD_DEFINITION_KIND: usize = offset_of!(MethodDefinition, kind);
pub(crate) const OFFSET_METHOD_DEFINITION_COMPUTED: usize = offset_of!(MethodDefinition, computed);
pub(crate) const OFFSET_METHOD_DEFINITION_STATIC: usize = offset_of!(MethodDefinition, r#static);
pub(crate) const OFFSET_METHOD_DEFINITION_OVERRIDE: usize =
    offset_of!(MethodDefinition, r#override);
pub(crate) const OFFSET_METHOD_DEFINITION_OPTIONAL: usize = offset_of!(MethodDefinition, optional);
pub(crate) const OFFSET_METHOD_DEFINITION_ACCESSIBILITY: usize =
    offset_of!(MethodDefinition, accessibility);

#[repr(transparent)]
#[derive(Debug)]
pub struct MethodDefinitionWithoutDecorators<'a>(pub(crate) *const MethodDefinition<'a>);

impl<'a> MethodDefinitionWithoutDecorators<'a> {
    #[inline]
    pub fn r#type(&self) -> &MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Box<'a, Function<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_VALUE)
                as *const Box<'a, Function<'a>>)
        }
    }

    #[inline]
    pub fn kind(&self) -> &MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct MethodDefinitionWithoutKey<'a>(pub(crate) *const MethodDefinition<'a>);

impl<'a> MethodDefinitionWithoutKey<'a> {
    #[inline]
    pub fn r#type(&self) -> &MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Box<'a, Function<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_VALUE)
                as *const Box<'a, Function<'a>>)
        }
    }

    #[inline]
    pub fn kind(&self) -> &MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct MethodDefinitionWithoutValue<'a>(pub(crate) *const MethodDefinition<'a>);

impl<'a> MethodDefinitionWithoutValue<'a> {
    #[inline]
    pub fn r#type(&self) -> &MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn kind(&self) -> &MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

pub(crate) const OFFSET_PROPERTY_DEFINITION_TYPE: usize = offset_of!(PropertyDefinition, r#type);
pub(crate) const OFFSET_PROPERTY_DEFINITION_SPAN: usize = offset_of!(PropertyDefinition, span);
pub(crate) const OFFSET_PROPERTY_DEFINITION_KEY: usize = offset_of!(PropertyDefinition, key);
pub(crate) const OFFSET_PROPERTY_DEFINITION_VALUE: usize = offset_of!(PropertyDefinition, value);
pub(crate) const OFFSET_PROPERTY_DEFINITION_COMPUTED: usize =
    offset_of!(PropertyDefinition, computed);
pub(crate) const OFFSET_PROPERTY_DEFINITION_STATIC: usize =
    offset_of!(PropertyDefinition, r#static);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DECLARE: usize =
    offset_of!(PropertyDefinition, declare);
pub(crate) const OFFSET_PROPERTY_DEFINITION_OVERRIDE: usize =
    offset_of!(PropertyDefinition, r#override);
pub(crate) const OFFSET_PROPERTY_DEFINITION_OPTIONAL: usize =
    offset_of!(PropertyDefinition, optional);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DEFINITE: usize =
    offset_of!(PropertyDefinition, definite);
pub(crate) const OFFSET_PROPERTY_DEFINITION_READONLY: usize =
    offset_of!(PropertyDefinition, readonly);
pub(crate) const OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION: usize =
    offset_of!(PropertyDefinition, type_annotation);
pub(crate) const OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY: usize =
    offset_of!(PropertyDefinition, accessibility);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DECORATORS: usize =
    offset_of!(PropertyDefinition, decorators);

#[repr(transparent)]
#[derive(Debug)]
pub struct PropertyDefinitionWithoutKey<'a>(pub(crate) *const PropertyDefinition<'a>);

impl<'a> PropertyDefinitionWithoutKey<'a> {
    #[inline]
    pub fn r#type(&self) -> &PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct PropertyDefinitionWithoutValue<'a>(pub(crate) *const PropertyDefinition<'a>);

impl<'a> PropertyDefinitionWithoutValue<'a> {
    #[inline]
    pub fn r#type(&self) -> &PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct PropertyDefinitionWithoutTypeAnnotation<'a>(pub(crate) *const PropertyDefinition<'a>);

impl<'a> PropertyDefinitionWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn r#type(&self) -> &PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct PropertyDefinitionWithoutDecorators<'a>(pub(crate) *const PropertyDefinition<'a>);

impl<'a> PropertyDefinitionWithoutDecorators<'a> {
    #[inline]
    pub fn r#type(&self) -> &PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(&self) -> &Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

pub(crate) const OFFSET_STATIC_BLOCK_SPAN: usize = offset_of!(StaticBlock, span);
pub(crate) const OFFSET_STATIC_BLOCK_BODY: usize = offset_of!(StaticBlock, body);
pub(crate) const OFFSET_STATIC_BLOCK_SCOPE_ID: usize = offset_of!(StaticBlock, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct StaticBlockWithoutBody<'a>(pub(crate) *const StaticBlock<'a>);

impl<'a> StaticBlockWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_STATIC_BLOCK_SPAN) as *const Span) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_BLOCK_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_ACCESSOR_PROPERTY_TYPE: usize = offset_of!(AccessorProperty, r#type);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_SPAN: usize = offset_of!(AccessorProperty, span);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_KEY: usize = offset_of!(AccessorProperty, key);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_VALUE: usize = offset_of!(AccessorProperty, value);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_COMPUTED: usize = offset_of!(AccessorProperty, computed);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_STATIC: usize = offset_of!(AccessorProperty, r#static);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_DECORATORS: usize =
    offset_of!(AccessorProperty, decorators);

#[repr(transparent)]
#[derive(Debug)]
pub struct AccessorPropertyWithoutKey<'a>(pub(crate) *const AccessorProperty<'a>);

impl<'a> AccessorPropertyWithoutKey<'a> {
    #[inline]
    pub fn r#type(&self) -> &AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AccessorPropertyWithoutValue<'a>(pub(crate) *const AccessorProperty<'a>);

impl<'a> AccessorPropertyWithoutValue<'a> {
    #[inline]
    pub fn r#type(&self) -> &AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn decorators(&self) -> &Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct AccessorPropertyWithoutDecorators<'a>(pub(crate) *const AccessorProperty<'a>);

impl<'a> AccessorPropertyWithoutDecorators<'a> {
    #[inline]
    pub fn r#type(&self) -> &AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }
}

pub(crate) const OFFSET_IMPORT_EXPRESSION_SPAN: usize = offset_of!(ImportExpression, span);
pub(crate) const OFFSET_IMPORT_EXPRESSION_SOURCE: usize = offset_of!(ImportExpression, source);
pub(crate) const OFFSET_IMPORT_EXPRESSION_ARGUMENTS: usize =
    offset_of!(ImportExpression, arguments);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportExpressionWithoutSource<'a>(pub(crate) *const ImportExpression<'a>);

impl<'a> ImportExpressionWithoutSource<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn arguments(&self) -> &Vec<'a, Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportExpressionWithoutArguments<'a>(pub(crate) *const ImportExpression<'a>);

impl<'a> ImportExpressionWithoutArguments<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SOURCE) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_IMPORT_DECLARATION_SPAN: usize = offset_of!(ImportDeclaration, span);
pub(crate) const OFFSET_IMPORT_DECLARATION_SPECIFIERS: usize =
    offset_of!(ImportDeclaration, specifiers);
pub(crate) const OFFSET_IMPORT_DECLARATION_SOURCE: usize = offset_of!(ImportDeclaration, source);
pub(crate) const OFFSET_IMPORT_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ImportDeclaration, with_clause);
pub(crate) const OFFSET_IMPORT_DECLARATION_IMPORT_KIND: usize =
    offset_of!(ImportDeclaration, import_kind);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportDeclarationWithoutSpecifiers<'a>(pub(crate) *const ImportDeclaration<'a>);

impl<'a> ImportDeclarationWithoutSpecifiers<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(&self) -> &StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportDeclarationWithoutSource<'a>(pub(crate) *const ImportDeclaration<'a>);

impl<'a> ImportDeclarationWithoutSource<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn specifiers(&self) -> &Option<Vec<'a, ImportDeclarationSpecifier<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPECIFIERS)
                as *const Option<Vec<'a, ImportDeclarationSpecifier<'a>>>)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportDeclarationWithoutWithClause<'a>(pub(crate) *const ImportDeclaration<'a>);

impl<'a> ImportDeclarationWithoutWithClause<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn specifiers(&self) -> &Option<Vec<'a, ImportDeclarationSpecifier<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPECIFIERS)
                as *const Option<Vec<'a, ImportDeclarationSpecifier<'a>>>)
        }
    }

    #[inline]
    pub fn source(&self) -> &StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_IMPORT_SPECIFIER_SPAN: usize = offset_of!(ImportSpecifier, span);
pub(crate) const OFFSET_IMPORT_SPECIFIER_IMPORTED: usize = offset_of!(ImportSpecifier, imported);
pub(crate) const OFFSET_IMPORT_SPECIFIER_LOCAL: usize = offset_of!(ImportSpecifier, local);
pub(crate) const OFFSET_IMPORT_SPECIFIER_IMPORT_KIND: usize =
    offset_of!(ImportSpecifier, import_kind);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportSpecifierWithoutImported<'a>(pub(crate) *const ImportSpecifier<'a>);

impl<'a> ImportSpecifierWithoutImported<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn local(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_LOCAL)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportSpecifierWithoutLocal<'a>(pub(crate) *const ImportSpecifier<'a>);

impl<'a> ImportSpecifierWithoutLocal<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn imported(&self) -> &ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORTED)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_IMPORT_DEFAULT_SPECIFIER_SPAN: usize =
    offset_of!(ImportDefaultSpecifier, span);
pub(crate) const OFFSET_IMPORT_DEFAULT_SPECIFIER_LOCAL: usize =
    offset_of!(ImportDefaultSpecifier, local);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportDefaultSpecifierWithoutLocal<'a>(pub(crate) *const ImportDefaultSpecifier<'a>);

impl<'a> ImportDefaultSpecifierWithoutLocal<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DEFAULT_SPECIFIER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_IMPORT_NAMESPACE_SPECIFIER_SPAN: usize =
    offset_of!(ImportNamespaceSpecifier, span);
pub(crate) const OFFSET_IMPORT_NAMESPACE_SPECIFIER_LOCAL: usize =
    offset_of!(ImportNamespaceSpecifier, local);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportNamespaceSpecifierWithoutLocal<'a>(pub(crate) *const ImportNamespaceSpecifier<'a>);

impl<'a> ImportNamespaceSpecifierWithoutLocal<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_NAMESPACE_SPECIFIER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_WITH_CLAUSE_SPAN: usize = offset_of!(WithClause, span);
pub(crate) const OFFSET_WITH_CLAUSE_ATTRIBUTES_KEYWORD: usize =
    offset_of!(WithClause, attributes_keyword);
pub(crate) const OFFSET_WITH_CLAUSE_WITH_ENTRIES: usize = offset_of!(WithClause, with_entries);

#[repr(transparent)]
#[derive(Debug)]
pub struct WithClauseWithoutAttributesKeyword<'a>(pub(crate) *const WithClause<'a>);

impl<'a> WithClauseWithoutAttributesKeyword<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn with_entries(&self) -> &Vec<'a, ImportAttribute<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_WITH_ENTRIES)
                as *const Vec<'a, ImportAttribute<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct WithClauseWithoutWithEntries<'a>(pub(crate) *const WithClause<'a>);

impl<'a> WithClauseWithoutWithEntries<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn attributes_keyword(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_ATTRIBUTES_KEYWORD)
                as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_IMPORT_ATTRIBUTE_SPAN: usize = offset_of!(ImportAttribute, span);
pub(crate) const OFFSET_IMPORT_ATTRIBUTE_KEY: usize = offset_of!(ImportAttribute, key);
pub(crate) const OFFSET_IMPORT_ATTRIBUTE_VALUE: usize = offset_of!(ImportAttribute, value);

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportAttributeWithoutKey<'a>(pub(crate) *const ImportAttribute<'a>);

impl<'a> ImportAttributeWithoutKey<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_VALUE) as *const StringLiteral<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ImportAttributeWithoutValue<'a>(pub(crate) *const ImportAttribute<'a>);

impl<'a> ImportAttributeWithoutValue<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &ImportAttributeKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_KEY)
                as *const ImportAttributeKey<'a>)
        }
    }
}

pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SPAN: usize =
    offset_of!(ExportNamedDeclaration, span);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION: usize =
    offset_of!(ExportNamedDeclaration, declaration);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS: usize =
    offset_of!(ExportNamedDeclaration, specifiers);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SOURCE: usize =
    offset_of!(ExportNamedDeclaration, source);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND: usize =
    offset_of!(ExportNamedDeclaration, export_kind);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ExportNamedDeclaration, with_clause);

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportNamedDeclarationWithoutDeclaration<'a>(
    pub(crate) *const ExportNamedDeclaration<'a>,
);

impl<'a> ExportNamedDeclarationWithoutDeclaration<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn specifiers(&self) -> &Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn source(&self) -> &Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportNamedDeclarationWithoutSpecifiers<'a>(
    pub(crate) *const ExportNamedDeclaration<'a>,
);

impl<'a> ExportNamedDeclarationWithoutSpecifiers<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(&self) -> &Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn source(&self) -> &Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportNamedDeclarationWithoutSource<'a>(pub(crate) *const ExportNamedDeclaration<'a>);

impl<'a> ExportNamedDeclarationWithoutSource<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(&self) -> &Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn specifiers(&self) -> &Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportNamedDeclarationWithoutWithClause<'a>(
    pub(crate) *const ExportNamedDeclaration<'a>,
);

impl<'a> ExportNamedDeclarationWithoutWithClause<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(&self) -> &Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn specifiers(&self) -> &Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn source(&self) -> &Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN: usize =
    offset_of!(ExportDefaultDeclaration, span);
pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_DECLARATION: usize =
    offset_of!(ExportDefaultDeclaration, declaration);
pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_EXPORTED: usize =
    offset_of!(ExportDefaultDeclaration, exported);

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportDefaultDeclarationWithoutDeclaration<'a>(
    pub(crate) *const ExportDefaultDeclaration<'a>,
);

impl<'a> ExportDefaultDeclarationWithoutDeclaration<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn exported(&self) -> &ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_EXPORTED)
                as *const ModuleExportName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportDefaultDeclarationWithoutExported<'a>(
    pub(crate) *const ExportDefaultDeclaration<'a>,
);

impl<'a> ExportDefaultDeclarationWithoutExported<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(&self) -> &ExportDefaultDeclarationKind<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_DECLARATION)
                as *const ExportDefaultDeclarationKind<'a>)
        }
    }
}

pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_SPAN: usize = offset_of!(ExportAllDeclaration, span);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_EXPORTED: usize =
    offset_of!(ExportAllDeclaration, exported);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_SOURCE: usize =
    offset_of!(ExportAllDeclaration, source);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ExportAllDeclaration, with_clause);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND: usize =
    offset_of!(ExportAllDeclaration, export_kind);

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportAllDeclarationWithoutExported<'a>(pub(crate) *const ExportAllDeclaration<'a>);

impl<'a> ExportAllDeclarationWithoutExported<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(&self) -> &StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportAllDeclarationWithoutSource<'a>(pub(crate) *const ExportAllDeclaration<'a>);

impl<'a> ExportAllDeclarationWithoutSource<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(&self) -> &Option<ModuleExportName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORTED)
                as *const Option<ModuleExportName<'a>>)
        }
    }

    #[inline]
    pub fn with_clause(&self) -> &Option<WithClause<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE)
                as *const Option<WithClause<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportAllDeclarationWithoutWithClause<'a>(pub(crate) *const ExportAllDeclaration<'a>);

impl<'a> ExportAllDeclarationWithoutWithClause<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(&self) -> &Option<ModuleExportName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORTED)
                as *const Option<ModuleExportName<'a>>)
        }
    }

    #[inline]
    pub fn source(&self) -> &StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_EXPORT_SPECIFIER_SPAN: usize = offset_of!(ExportSpecifier, span);
pub(crate) const OFFSET_EXPORT_SPECIFIER_LOCAL: usize = offset_of!(ExportSpecifier, local);
pub(crate) const OFFSET_EXPORT_SPECIFIER_EXPORTED: usize = offset_of!(ExportSpecifier, exported);
pub(crate) const OFFSET_EXPORT_SPECIFIER_EXPORT_KIND: usize =
    offset_of!(ExportSpecifier, export_kind);

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportSpecifierWithoutLocal<'a>(pub(crate) *const ExportSpecifier<'a>);

impl<'a> ExportSpecifierWithoutLocal<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(&self) -> &ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORTED)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct ExportSpecifierWithoutExported<'a>(pub(crate) *const ExportSpecifier<'a>);

impl<'a> ExportSpecifierWithoutExported<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn local(&self) -> &ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_LOCAL)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn export_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_JSX_ELEMENT_SPAN: usize = offset_of!(JSXElement, span);
pub(crate) const OFFSET_JSX_ELEMENT_OPENING_ELEMENT: usize =
    offset_of!(JSXElement, opening_element);
pub(crate) const OFFSET_JSX_ELEMENT_CLOSING_ELEMENT: usize =
    offset_of!(JSXElement, closing_element);
pub(crate) const OFFSET_JSX_ELEMENT_CHILDREN: usize = offset_of!(JSXElement, children);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXElementWithoutOpeningElement<'a>(pub(crate) *const JSXElement<'a>);

impl<'a> JSXElementWithoutOpeningElement<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn closing_element(&self) -> &Option<Box<'a, JSXClosingElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CLOSING_ELEMENT)
                as *const Option<Box<'a, JSXClosingElement<'a>>>)
        }
    }

    #[inline]
    pub fn children(&self) -> &Vec<'a, JSXChild<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CHILDREN)
                as *const Vec<'a, JSXChild<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXElementWithoutClosingElement<'a>(pub(crate) *const JSXElement<'a>);

impl<'a> JSXElementWithoutClosingElement<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_element(&self) -> &Box<'a, JSXOpeningElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_OPENING_ELEMENT)
                as *const Box<'a, JSXOpeningElement<'a>>)
        }
    }

    #[inline]
    pub fn children(&self) -> &Vec<'a, JSXChild<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CHILDREN)
                as *const Vec<'a, JSXChild<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXElementWithoutChildren<'a>(pub(crate) *const JSXElement<'a>);

impl<'a> JSXElementWithoutChildren<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_element(&self) -> &Box<'a, JSXOpeningElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_OPENING_ELEMENT)
                as *const Box<'a, JSXOpeningElement<'a>>)
        }
    }

    #[inline]
    pub fn closing_element(&self) -> &Option<Box<'a, JSXClosingElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CLOSING_ELEMENT)
                as *const Option<Box<'a, JSXClosingElement<'a>>>)
        }
    }
}

pub(crate) const OFFSET_JSX_OPENING_ELEMENT_SPAN: usize = offset_of!(JSXOpeningElement, span);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING: usize =
    offset_of!(JSXOpeningElement, self_closing);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_NAME: usize = offset_of!(JSXOpeningElement, name);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES: usize =
    offset_of!(JSXOpeningElement, attributes);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS: usize =
    offset_of!(JSXOpeningElement, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXOpeningElementWithoutName<'a>(pub(crate) *const JSXOpeningElement<'a>);

impl<'a> JSXOpeningElementWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn attributes(&self) -> &Vec<'a, JSXAttributeItem<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES)
                as *const Vec<'a, JSXAttributeItem<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXOpeningElementWithoutAttributes<'a>(pub(crate) *const JSXOpeningElement<'a>);

impl<'a> JSXOpeningElementWithoutAttributes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn name(&self) -> &JSXElementName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_NAME)
                as *const JSXElementName<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXOpeningElementWithoutTypeParameters<'a>(pub(crate) *const JSXOpeningElement<'a>);

impl<'a> JSXOpeningElementWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn name(&self) -> &JSXElementName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_NAME)
                as *const JSXElementName<'a>)
        }
    }

    #[inline]
    pub fn attributes(&self) -> &Vec<'a, JSXAttributeItem<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES)
                as *const Vec<'a, JSXAttributeItem<'a>>)
        }
    }
}

pub(crate) const OFFSET_JSX_CLOSING_ELEMENT_SPAN: usize = offset_of!(JSXClosingElement, span);
pub(crate) const OFFSET_JSX_CLOSING_ELEMENT_NAME: usize = offset_of!(JSXClosingElement, name);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXClosingElementWithoutName<'a>(pub(crate) *const JSXClosingElement<'a>);

impl<'a> JSXClosingElementWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_CLOSING_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_JSX_FRAGMENT_SPAN: usize = offset_of!(JSXFragment, span);
pub(crate) const OFFSET_JSX_FRAGMENT_OPENING_FRAGMENT: usize =
    offset_of!(JSXFragment, opening_fragment);
pub(crate) const OFFSET_JSX_FRAGMENT_CLOSING_FRAGMENT: usize =
    offset_of!(JSXFragment, closing_fragment);
pub(crate) const OFFSET_JSX_FRAGMENT_CHILDREN: usize = offset_of!(JSXFragment, children);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXFragmentWithoutChildren<'a>(pub(crate) *const JSXFragment<'a>);

impl<'a> JSXFragmentWithoutChildren<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_fragment(&self) -> &JSXOpeningFragment {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_OPENING_FRAGMENT)
                as *const JSXOpeningFragment)
        }
    }

    #[inline]
    pub fn closing_fragment(&self) -> &JSXClosingFragment {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_CLOSING_FRAGMENT)
                as *const JSXClosingFragment)
        }
    }
}

pub(crate) const OFFSET_JSX_NAMESPACED_NAME_SPAN: usize = offset_of!(JSXNamespacedName, span);
pub(crate) const OFFSET_JSX_NAMESPACED_NAME_NAMESPACE: usize =
    offset_of!(JSXNamespacedName, namespace);
pub(crate) const OFFSET_JSX_NAMESPACED_NAME_PROPERTY: usize =
    offset_of!(JSXNamespacedName, property);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXNamespacedNameWithoutNamespace<'a>(pub(crate) *const JSXNamespacedName<'a>);

impl<'a> JSXNamespacedNameWithoutNamespace<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(&self) -> &JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_PROPERTY)
                as *const JSXIdentifier<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXNamespacedNameWithoutProperty<'a>(pub(crate) *const JSXNamespacedName<'a>);

impl<'a> JSXNamespacedNameWithoutProperty<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn namespace(&self) -> &JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_NAMESPACE)
                as *const JSXIdentifier<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_SPAN: usize = offset_of!(JSXMemberExpression, span);
pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(JSXMemberExpression, object);
pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_PROPERTY: usize =
    offset_of!(JSXMemberExpression, property);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXMemberExpressionWithoutObject<'a>(pub(crate) *const JSXMemberExpression<'a>);

impl<'a> JSXMemberExpressionWithoutObject<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(&self) -> &JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_PROPERTY)
                as *const JSXIdentifier<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXMemberExpressionWithoutProperty<'a>(pub(crate) *const JSXMemberExpression<'a>);

impl<'a> JSXMemberExpressionWithoutProperty<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object(&self) -> &JSXMemberExpressionObject<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_OBJECT)
                as *const JSXMemberExpressionObject<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_EXPRESSION_CONTAINER_SPAN: usize =
    offset_of!(JSXExpressionContainer, span);
pub(crate) const OFFSET_JSX_EXPRESSION_CONTAINER_EXPRESSION: usize =
    offset_of!(JSXExpressionContainer, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXExpressionContainerWithoutExpression<'a>(
    pub(crate) *const JSXExpressionContainer<'a>,
);

impl<'a> JSXExpressionContainerWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_EXPRESSION_CONTAINER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_JSX_ATTRIBUTE_SPAN: usize = offset_of!(JSXAttribute, span);
pub(crate) const OFFSET_JSX_ATTRIBUTE_NAME: usize = offset_of!(JSXAttribute, name);
pub(crate) const OFFSET_JSX_ATTRIBUTE_VALUE: usize = offset_of!(JSXAttribute, value);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXAttributeWithoutName<'a>(pub(crate) *const JSXAttribute<'a>);

impl<'a> JSXAttributeWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &Option<JSXAttributeValue<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_VALUE)
                as *const Option<JSXAttributeValue<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXAttributeWithoutValue<'a>(pub(crate) *const JSXAttribute<'a>);

impl<'a> JSXAttributeWithoutValue<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(&self) -> &JSXAttributeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_NAME) as *const JSXAttributeName<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_SPREAD_ATTRIBUTE_SPAN: usize = offset_of!(JSXSpreadAttribute, span);
pub(crate) const OFFSET_JSX_SPREAD_ATTRIBUTE_ARGUMENT: usize =
    offset_of!(JSXSpreadAttribute, argument);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXSpreadAttributeWithoutArgument<'a>(pub(crate) *const JSXSpreadAttribute<'a>);

impl<'a> JSXSpreadAttributeWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_SPREAD_ATTRIBUTE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_JSX_SPREAD_CHILD_SPAN: usize = offset_of!(JSXSpreadChild, span);
pub(crate) const OFFSET_JSX_SPREAD_CHILD_EXPRESSION: usize = offset_of!(JSXSpreadChild, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSXSpreadChildWithoutExpression<'a>(pub(crate) *const JSXSpreadChild<'a>);

impl<'a> JSXSpreadChildWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_SPREAD_CHILD_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_THIS_PARAMETER_SPAN: usize = offset_of!(TSThisParameter, span);
pub(crate) const OFFSET_TS_THIS_PARAMETER_THIS: usize = offset_of!(TSThisParameter, this);
pub(crate) const OFFSET_TS_THIS_PARAMETER_TYPE_ANNOTATION: usize =
    offset_of!(TSThisParameter, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSThisParameterWithoutThis<'a>(pub(crate) *const TSThisParameter<'a>);

impl<'a> TSThisParameterWithoutThis<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSThisParameterWithoutTypeAnnotation<'a>(pub(crate) *const TSThisParameter<'a>);

impl<'a> TSThisParameterWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_THIS)
                as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_ENUM_DECLARATION_SPAN: usize = offset_of!(TSEnumDeclaration, span);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_ID: usize = offset_of!(TSEnumDeclaration, id);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_MEMBERS: usize = offset_of!(TSEnumDeclaration, members);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_MODIFIERS: usize =
    offset_of!(TSEnumDeclaration, modifiers);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSEnumDeclaration, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSEnumDeclarationWithoutId<'a>(pub(crate) *const TSEnumDeclaration<'a>);

impl<'a> TSEnumDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn members(&self) -> &Vec<'a, TSEnumMember<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_MEMBERS)
                as *const Vec<'a, TSEnumMember<'a>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSEnumDeclarationWithoutMembers<'a>(pub(crate) *const TSEnumDeclaration<'a>);

impl<'a> TSEnumDeclarationWithoutMembers<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_ENUM_MEMBER_SPAN: usize = offset_of!(TSEnumMember, span);
pub(crate) const OFFSET_TS_ENUM_MEMBER_ID: usize = offset_of!(TSEnumMember, id);
pub(crate) const OFFSET_TS_ENUM_MEMBER_INITIALIZER: usize = offset_of!(TSEnumMember, initializer);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSEnumMemberWithoutId<'a>(pub(crate) *const TSEnumMember<'a>);

impl<'a> TSEnumMemberWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn initializer(&self) -> &Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_INITIALIZER)
                as *const Option<Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSEnumMemberWithoutInitializer<'a>(pub(crate) *const TSEnumMember<'a>);

impl<'a> TSEnumMemberWithoutInitializer<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &TSEnumMemberName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_ID) as *const TSEnumMemberName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ANNOTATION_SPAN: usize = offset_of!(TSTypeAnnotation, span);
pub(crate) const OFFSET_TS_TYPE_ANNOTATION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAnnotation, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAnnotationWithoutTypeAnnotation<'a>(pub(crate) *const TSTypeAnnotation<'a>);

impl<'a> TSTypeAnnotationWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ANNOTATION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_LITERAL_TYPE_SPAN: usize = offset_of!(TSLiteralType, span);
pub(crate) const OFFSET_TS_LITERAL_TYPE_LITERAL: usize = offset_of!(TSLiteralType, literal);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSLiteralTypeWithoutLiteral<'a>(pub(crate) *const TSLiteralType<'a>);

impl<'a> TSLiteralTypeWithoutLiteral<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_LITERAL_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_SPAN: usize = offset_of!(TSConditionalType, span);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE: usize =
    offset_of!(TSConditionalType, check_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE: usize =
    offset_of!(TSConditionalType, extends_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE: usize =
    offset_of!(TSConditionalType, true_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE: usize =
    offset_of!(TSConditionalType, false_type);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConditionalTypeWithoutCheckType<'a>(pub(crate) *const TSConditionalType<'a>);

impl<'a> TSConditionalTypeWithoutCheckType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn extends_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConditionalTypeWithoutExtendsType<'a>(pub(crate) *const TSConditionalType<'a>);

impl<'a> TSConditionalTypeWithoutExtendsType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConditionalTypeWithoutTrueType<'a>(pub(crate) *const TSConditionalType<'a>);

impl<'a> TSConditionalTypeWithoutTrueType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn extends_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConditionalTypeWithoutFalseType<'a>(pub(crate) *const TSConditionalType<'a>);

impl<'a> TSConditionalTypeWithoutFalseType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn extends_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_UNION_TYPE_SPAN: usize = offset_of!(TSUnionType, span);
pub(crate) const OFFSET_TS_UNION_TYPE_TYPES: usize = offset_of!(TSUnionType, types);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSUnionTypeWithoutTypes<'a>(pub(crate) *const TSUnionType<'a>);

impl<'a> TSUnionTypeWithoutTypes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_UNION_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INTERSECTION_TYPE_SPAN: usize = offset_of!(TSIntersectionType, span);
pub(crate) const OFFSET_TS_INTERSECTION_TYPE_TYPES: usize = offset_of!(TSIntersectionType, types);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIntersectionTypeWithoutTypes<'a>(pub(crate) *const TSIntersectionType<'a>);

impl<'a> TSIntersectionTypeWithoutTypes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERSECTION_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_OPERATOR_SPAN: usize = offset_of!(TSTypeOperator, span);
pub(crate) const OFFSET_TS_TYPE_OPERATOR_OPERATOR: usize = offset_of!(TSTypeOperator, operator);
pub(crate) const OFFSET_TS_TYPE_OPERATOR_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeOperator, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeOperatorWithoutTypeAnnotation<'a>(pub(crate) *const TSTypeOperator<'a>);

impl<'a> TSTypeOperatorWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_OPERATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(&self) -> &TSTypeOperatorOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_OPERATOR_OPERATOR)
                as *const TSTypeOperatorOperator)
        }
    }
}

pub(crate) const OFFSET_TS_ARRAY_TYPE_SPAN: usize = offset_of!(TSArrayType, span);
pub(crate) const OFFSET_TS_ARRAY_TYPE_ELEMENT_TYPE: usize = offset_of!(TSArrayType, element_type);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSArrayTypeWithoutElementType<'a>(pub(crate) *const TSArrayType<'a>);

impl<'a> TSArrayTypeWithoutElementType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ARRAY_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN: usize = offset_of!(TSIndexedAccessType, span);
pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_OBJECT_TYPE: usize =
    offset_of!(TSIndexedAccessType, object_type);
pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_INDEX_TYPE: usize =
    offset_of!(TSIndexedAccessType, index_type);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIndexedAccessTypeWithoutObjectType<'a>(pub(crate) *const TSIndexedAccessType<'a>);

impl<'a> TSIndexedAccessTypeWithoutObjectType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn index_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_INDEX_TYPE)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIndexedAccessTypeWithoutIndexType<'a>(pub(crate) *const TSIndexedAccessType<'a>);

impl<'a> TSIndexedAccessTypeWithoutIndexType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_OBJECT_TYPE)
                as *const TSType<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TUPLE_TYPE_SPAN: usize = offset_of!(TSTupleType, span);
pub(crate) const OFFSET_TS_TUPLE_TYPE_ELEMENT_TYPES: usize = offset_of!(TSTupleType, element_types);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTupleTypeWithoutElementTypes<'a>(pub(crate) *const TSTupleType<'a>);

impl<'a> TSTupleTypeWithoutElementTypes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TUPLE_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN: usize = offset_of!(TSNamedTupleMember, span);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_ELEMENT_TYPE: usize =
    offset_of!(TSNamedTupleMember, element_type);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_LABEL: usize = offset_of!(TSNamedTupleMember, label);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL: usize =
    offset_of!(TSNamedTupleMember, optional);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSNamedTupleMemberWithoutElementType<'a>(pub(crate) *const TSNamedTupleMember<'a>);

impl<'a> TSNamedTupleMemberWithoutElementType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn label(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_LABEL)
                as *const IdentifierName<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSNamedTupleMemberWithoutLabel<'a>(pub(crate) *const TSNamedTupleMember<'a>);

impl<'a> TSNamedTupleMemberWithoutLabel<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn element_type(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_ELEMENT_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_TS_OPTIONAL_TYPE_SPAN: usize = offset_of!(TSOptionalType, span);
pub(crate) const OFFSET_TS_OPTIONAL_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSOptionalType, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSOptionalTypeWithoutTypeAnnotation<'a>(pub(crate) *const TSOptionalType<'a>);

impl<'a> TSOptionalTypeWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_OPTIONAL_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_REST_TYPE_SPAN: usize = offset_of!(TSRestType, span);
pub(crate) const OFFSET_TS_REST_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSRestType, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSRestTypeWithoutTypeAnnotation<'a>(pub(crate) *const TSRestType<'a>);

impl<'a> TSRestTypeWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_REST_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_REFERENCE_SPAN: usize = offset_of!(TSTypeReference, span);
pub(crate) const OFFSET_TS_TYPE_REFERENCE_TYPE_NAME: usize = offset_of!(TSTypeReference, type_name);
pub(crate) const OFFSET_TS_TYPE_REFERENCE_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeReference, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeReferenceWithoutTypeName<'a>(pub(crate) *const TSTypeReference<'a>);

impl<'a> TSTypeReferenceWithoutTypeName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeReferenceWithoutTypeParameters<'a>(pub(crate) *const TSTypeReference<'a>);

impl<'a> TSTypeReferenceWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_name(&self) -> &TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_TYPE_NAME)
                as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_QUALIFIED_NAME_SPAN: usize = offset_of!(TSQualifiedName, span);
pub(crate) const OFFSET_TS_QUALIFIED_NAME_LEFT: usize = offset_of!(TSQualifiedName, left);
pub(crate) const OFFSET_TS_QUALIFIED_NAME_RIGHT: usize = offset_of!(TSQualifiedName, right);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSQualifiedNameWithoutLeft<'a>(pub(crate) *const TSQualifiedName<'a>);

impl<'a> TSQualifiedNameWithoutLeft<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(&self) -> &IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_RIGHT)
                as *const IdentifierName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSQualifiedNameWithoutRight<'a>(pub(crate) *const TSQualifiedName<'a>);

impl<'a> TSQualifiedNameWithoutRight<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(&self) -> &TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_LEFT) as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_SPAN: usize =
    offset_of!(TSTypeParameterInstantiation, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_PARAMS: usize =
    offset_of!(TSTypeParameterInstantiation, params);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeParameterInstantiationWithoutParams<'a>(
    pub(crate) *const TSTypeParameterInstantiation<'a>,
);

impl<'a> TSTypeParameterInstantiationWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_SPAN)
                as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_SPAN: usize = offset_of!(TSTypeParameter, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_NAME: usize = offset_of!(TSTypeParameter, name);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_CONSTRAINT: usize =
    offset_of!(TSTypeParameter, constraint);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_DEFAULT: usize = offset_of!(TSTypeParameter, default);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_IN: usize = offset_of!(TSTypeParameter, r#in);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_OUT: usize = offset_of!(TSTypeParameter, out);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_CONST: usize = offset_of!(TSTypeParameter, r#const);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_SCOPE_ID: usize = offset_of!(TSTypeParameter, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeParameterWithoutName<'a>(pub(crate) *const TSTypeParameter<'a>);

impl<'a> TSTypeParameterWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn constraint(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONSTRAINT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn default(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DEFAULT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeParameterWithoutConstraint<'a>(pub(crate) *const TSTypeParameter<'a>);

impl<'a> TSTypeParameterWithoutConstraint<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_NAME)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn default(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DEFAULT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeParameterWithoutDefault<'a>(pub(crate) *const TSTypeParameter<'a>);

impl<'a> TSTypeParameterWithoutDefault<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_NAME)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn constraint(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONSTRAINT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_DECLARATION_SPAN: usize =
    offset_of!(TSTypeParameterDeclaration, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_DECLARATION_PARAMS: usize =
    offset_of!(TSTypeParameterDeclaration, params);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeParameterDeclarationWithoutParams<'a>(
    pub(crate) *const TSTypeParameterDeclaration<'a>,
);

impl<'a> TSTypeParameterDeclarationWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DECLARATION_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN: usize =
    offset_of!(TSTypeAliasDeclaration, span);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_ID: usize =
    offset_of!(TSTypeAliasDeclaration, id);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAliasDeclaration, type_annotation);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeAliasDeclaration, type_parameters);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_MODIFIERS: usize =
    offset_of!(TSTypeAliasDeclaration, modifiers);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAliasDeclarationWithoutId<'a>(pub(crate) *const TSTypeAliasDeclaration<'a>);

impl<'a> TSTypeAliasDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_annotation(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAliasDeclarationWithoutTypeAnnotation<'a>(
    pub(crate) *const TSTypeAliasDeclaration<'a>,
);

impl<'a> TSTypeAliasDeclarationWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAliasDeclarationWithoutTypeParameters<'a>(
    pub(crate) *const TSTypeAliasDeclaration<'a>,
);

impl<'a> TSTypeAliasDeclarationWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_annotation(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_SPAN: usize = offset_of!(TSClassImplements, span);
pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_EXPRESSION: usize =
    offset_of!(TSClassImplements, expression);
pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_TYPE_PARAMETERS: usize =
    offset_of!(TSClassImplements, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSClassImplementsWithoutExpression<'a>(pub(crate) *const TSClassImplements<'a>);

impl<'a> TSClassImplementsWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSClassImplementsWithoutTypeParameters<'a>(pub(crate) *const TSClassImplements<'a>);

impl<'a> TSClassImplementsWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(&self) -> &TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_EXPRESSION)
                as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_SPAN: usize =
    offset_of!(TSInterfaceDeclaration, span);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_ID: usize = offset_of!(TSInterfaceDeclaration, id);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_BODY: usize =
    offset_of!(TSInterfaceDeclaration, body);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSInterfaceDeclaration, type_parameters);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_EXTENDS: usize =
    offset_of!(TSInterfaceDeclaration, extends);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_MODIFIERS: usize =
    offset_of!(TSInterfaceDeclaration, modifiers);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceDeclarationWithoutId<'a>(pub(crate) *const TSInterfaceDeclaration<'a>);

impl<'a> TSInterfaceDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn extends(&self) -> &Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceDeclarationWithoutBody<'a>(pub(crate) *const TSInterfaceDeclaration<'a>);

impl<'a> TSInterfaceDeclarationWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn extends(&self) -> &Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceDeclarationWithoutTypeParameters<'a>(
    pub(crate) *const TSInterfaceDeclaration<'a>,
);

impl<'a> TSInterfaceDeclarationWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn extends(&self) -> &Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceDeclarationWithoutExtends<'a>(pub(crate) *const TSInterfaceDeclaration<'a>);

impl<'a> TSInterfaceDeclarationWithoutExtends<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn body(&self) -> &Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_BODY_SPAN: usize = offset_of!(TSInterfaceBody, span);
pub(crate) const OFFSET_TS_INTERFACE_BODY_BODY: usize = offset_of!(TSInterfaceBody, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceBodyWithoutBody<'a>(pub(crate) *const TSInterfaceBody<'a>);

impl<'a> TSInterfaceBodyWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_BODY_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_SPAN: usize = offset_of!(TSPropertySignature, span);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED: usize =
    offset_of!(TSPropertySignature, computed);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL: usize =
    offset_of!(TSPropertySignature, optional);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_READONLY: usize =
    offset_of!(TSPropertySignature, readonly);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_KEY: usize = offset_of!(TSPropertySignature, key);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_TYPE_ANNOTATION: usize =
    offset_of!(TSPropertySignature, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSPropertySignatureWithoutKey<'a>(pub(crate) *const TSPropertySignature<'a>);

impl<'a> TSPropertySignatureWithoutKey<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED) as *const bool)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL) as *const bool)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_READONLY) as *const bool)
        }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSPropertySignatureWithoutTypeAnnotation<'a>(pub(crate) *const TSPropertySignature<'a>);

impl<'a> TSPropertySignatureWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED) as *const bool)
        }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL) as *const bool)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_READONLY) as *const bool)
        }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_KEY)
                as *const PropertyKey<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INDEX_SIGNATURE_SPAN: usize = offset_of!(TSIndexSignature, span);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_PARAMETERS: usize =
    offset_of!(TSIndexSignature, parameters);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_TYPE_ANNOTATION: usize =
    offset_of!(TSIndexSignature, type_annotation);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_READONLY: usize = offset_of!(TSIndexSignature, readonly);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIndexSignatureWithoutParameters<'a>(pub(crate) *const TSIndexSignature<'a>);

impl<'a> TSIndexSignatureWithoutParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_TYPE_ANNOTATION)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_READONLY) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIndexSignatureWithoutTypeAnnotation<'a>(pub(crate) *const TSIndexSignature<'a>);

impl<'a> TSIndexSignatureWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn parameters(&self) -> &Vec<'a, TSIndexSignatureName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_PARAMETERS)
                as *const Vec<'a, TSIndexSignatureName<'a>>)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_READONLY) as *const bool) }
    }
}

pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN: usize =
    offset_of!(TSCallSignatureDeclaration, span);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM: usize =
    offset_of!(TSCallSignatureDeclaration, this_param);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS: usize =
    offset_of!(TSCallSignatureDeclaration, params);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE: usize =
    offset_of!(TSCallSignatureDeclaration, return_type);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSCallSignatureDeclaration, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSCallSignatureDeclarationWithoutThisParam<'a>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
);

impl<'a> TSCallSignatureDeclarationWithoutThisParam<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSCallSignatureDeclarationWithoutParams<'a>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
);

impl<'a> TSCallSignatureDeclarationWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSCallSignatureDeclarationWithoutReturnType<'a>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
);

impl<'a> TSCallSignatureDeclarationWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSCallSignatureDeclarationWithoutTypeParameters<'a>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
);

impl<'a> TSCallSignatureDeclarationWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

pub(crate) const OFFSET_TS_METHOD_SIGNATURE_SPAN: usize = offset_of!(TSMethodSignature, span);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_KEY: usize = offset_of!(TSMethodSignature, key);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_COMPUTED: usize =
    offset_of!(TSMethodSignature, computed);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_OPTIONAL: usize =
    offset_of!(TSMethodSignature, optional);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_KIND: usize = offset_of!(TSMethodSignature, kind);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM: usize =
    offset_of!(TSMethodSignature, this_param);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_PARAMS: usize = offset_of!(TSMethodSignature, params);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE: usize =
    offset_of!(TSMethodSignature, return_type);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS: usize =
    offset_of!(TSMethodSignature, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMethodSignatureWithoutKey<'a>(pub(crate) *const TSMethodSignature<'a>);

impl<'a> TSMethodSignatureWithoutKey<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(&self) -> &TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMethodSignatureWithoutThisParam<'a>(pub(crate) *const TSMethodSignature<'a>);

impl<'a> TSMethodSignatureWithoutThisParam<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(&self) -> &TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMethodSignatureWithoutParams<'a>(pub(crate) *const TSMethodSignature<'a>);

impl<'a> TSMethodSignatureWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(&self) -> &TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMethodSignatureWithoutReturnType<'a>(pub(crate) *const TSMethodSignature<'a>);

impl<'a> TSMethodSignatureWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(&self) -> &TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMethodSignatureWithoutTypeParameters<'a>(pub(crate) *const TSMethodSignature<'a>);

impl<'a> TSMethodSignatureWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(&self) -> &PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(&self) -> &TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN: usize =
    offset_of!(TSConstructSignatureDeclaration, span);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS: usize =
    offset_of!(TSConstructSignatureDeclaration, params);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE: usize =
    offset_of!(TSConstructSignatureDeclaration, return_type);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSConstructSignatureDeclaration, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructSignatureDeclarationWithoutParams<'a>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
);

impl<'a> TSConstructSignatureDeclarationWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructSignatureDeclarationWithoutReturnType<'a>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
);

impl<'a> TSConstructSignatureDeclarationWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructSignatureDeclarationWithoutTypeParameters<'a>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
);

impl<'a> TSConstructSignatureDeclarationWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_SPAN: usize =
    offset_of!(TSIndexSignatureName, span);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_NAME: usize =
    offset_of!(TSIndexSignatureName, name);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_TYPE_ANNOTATION: usize =
    offset_of!(TSIndexSignatureName, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSIndexSignatureNameWithoutTypeAnnotation<'a>(
    pub(crate) *const TSIndexSignatureName<'a>,
);

impl<'a> TSIndexSignatureNameWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(&self) -> &Atom<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_NAME_NAME) as *const Atom<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_SPAN: usize = offset_of!(TSInterfaceHeritage, span);
pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_EXPRESSION: usize =
    offset_of!(TSInterfaceHeritage, expression);
pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_TYPE_PARAMETERS: usize =
    offset_of!(TSInterfaceHeritage, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceHeritageWithoutExpression<'a>(pub(crate) *const TSInterfaceHeritage<'a>);

impl<'a> TSInterfaceHeritageWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInterfaceHeritageWithoutTypeParameters<'a>(pub(crate) *const TSInterfaceHeritage<'a>);

impl<'a> TSInterfaceHeritageWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PREDICATE_SPAN: usize = offset_of!(TSTypePredicate, span);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_PARAMETER_NAME: usize =
    offset_of!(TSTypePredicate, parameter_name);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_ASSERTS: usize = offset_of!(TSTypePredicate, asserts);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_TYPE_ANNOTATION: usize =
    offset_of!(TSTypePredicate, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypePredicateWithoutParameterName<'a>(pub(crate) *const TSTypePredicate<'a>);

impl<'a> TSTypePredicateWithoutParameterName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn asserts(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_ASSERTS) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypePredicateWithoutTypeAnnotation<'a>(pub(crate) *const TSTypePredicate<'a>);

impl<'a> TSTypePredicateWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn parameter_name(&self) -> &TSTypePredicateName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_PARAMETER_NAME)
                as *const TSTypePredicateName<'a>)
        }
    }

    #[inline]
    pub fn asserts(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_ASSERTS) as *const bool) }
    }
}

pub(crate) const OFFSET_TS_MODULE_DECLARATION_SPAN: usize = offset_of!(TSModuleDeclaration, span);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_ID: usize = offset_of!(TSModuleDeclaration, id);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_BODY: usize = offset_of!(TSModuleDeclaration, body);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_KIND: usize = offset_of!(TSModuleDeclaration, kind);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_MODIFIERS: usize =
    offset_of!(TSModuleDeclaration, modifiers);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSModuleDeclaration, scope_id);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSModuleDeclarationWithoutId<'a>(pub(crate) *const TSModuleDeclaration<'a>);

impl<'a> TSModuleDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(&self) -> &Option<TSModuleDeclarationBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_BODY)
                as *const Option<TSModuleDeclarationBody<'a>>)
        }
    }

    #[inline]
    pub fn kind(&self) -> &TSModuleDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_KIND)
                as *const TSModuleDeclarationKind)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSModuleDeclarationWithoutBody<'a>(pub(crate) *const TSModuleDeclaration<'a>);

impl<'a> TSModuleDeclarationWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(&self) -> &TSModuleDeclarationName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_ID)
                as *const TSModuleDeclarationName<'a>)
        }
    }

    #[inline]
    pub fn kind(&self) -> &TSModuleDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_KIND)
                as *const TSModuleDeclarationKind)
        }
    }

    #[inline]
    pub fn modifiers(&self) -> &Modifiers<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_MODIFIERS)
                as *const Modifiers<'a>)
        }
    }

    #[inline]
    pub fn scope_id(&self) -> &Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_MODULE_BLOCK_SPAN: usize = offset_of!(TSModuleBlock, span);
pub(crate) const OFFSET_TS_MODULE_BLOCK_BODY: usize = offset_of!(TSModuleBlock, body);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSModuleBlockWithoutBody<'a>(pub(crate) *const TSModuleBlock<'a>);

impl<'a> TSModuleBlockWithoutBody<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_BLOCK_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_LITERAL_SPAN: usize = offset_of!(TSTypeLiteral, span);
pub(crate) const OFFSET_TS_TYPE_LITERAL_MEMBERS: usize = offset_of!(TSTypeLiteral, members);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeLiteralWithoutMembers<'a>(pub(crate) *const TSTypeLiteral<'a>);

impl<'a> TSTypeLiteralWithoutMembers<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_LITERAL_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INFER_TYPE_SPAN: usize = offset_of!(TSInferType, span);
pub(crate) const OFFSET_TS_INFER_TYPE_TYPE_PARAMETER: usize =
    offset_of!(TSInferType, type_parameter);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInferTypeWithoutTypeParameter<'a>(pub(crate) *const TSInferType<'a>);

impl<'a> TSInferTypeWithoutTypeParameter<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INFER_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_QUERY_SPAN: usize = offset_of!(TSTypeQuery, span);
pub(crate) const OFFSET_TS_TYPE_QUERY_EXPR_NAME: usize = offset_of!(TSTypeQuery, expr_name);
pub(crate) const OFFSET_TS_TYPE_QUERY_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeQuery, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeQueryWithoutExprName<'a>(pub(crate) *const TSTypeQuery<'a>);

impl<'a> TSTypeQueryWithoutExprName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeQueryWithoutTypeParameters<'a>(pub(crate) *const TSTypeQuery<'a>);

impl<'a> TSTypeQueryWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expr_name(&self) -> &TSTypeQueryExprName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_EXPR_NAME)
                as *const TSTypeQueryExprName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_TYPE_SPAN: usize = offset_of!(TSImportType, span);
pub(crate) const OFFSET_TS_IMPORT_TYPE_ARGUMENT: usize = offset_of!(TSImportType, argument);
pub(crate) const OFFSET_TS_IMPORT_TYPE_QUALIFIER: usize = offset_of!(TSImportType, qualifier);
pub(crate) const OFFSET_TS_IMPORT_TYPE_ATTRIBUTES: usize = offset_of!(TSImportType, attributes);
pub(crate) const OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSImportType, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportTypeWithoutArgument<'a>(pub(crate) *const TSImportType<'a>);

impl<'a> TSImportTypeWithoutArgument<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn qualifier(&self) -> &Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn attributes(&self) -> &Option<TSImportAttributes<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<TSImportAttributes<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportTypeWithoutQualifier<'a>(pub(crate) *const TSImportType<'a>);

impl<'a> TSImportTypeWithoutQualifier<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn argument(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ARGUMENT) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn attributes(&self) -> &Option<TSImportAttributes<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<TSImportAttributes<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportTypeWithoutAttributes<'a>(pub(crate) *const TSImportType<'a>);

impl<'a> TSImportTypeWithoutAttributes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn argument(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ARGUMENT) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn qualifier(&self) -> &Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportTypeWithoutTypeParameters<'a>(pub(crate) *const TSImportType<'a>);

impl<'a> TSImportTypeWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn argument(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ARGUMENT) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn qualifier(&self) -> &Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn attributes(&self) -> &Option<TSImportAttributes<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<TSImportAttributes<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTES_SPAN: usize = offset_of!(TSImportAttributes, span);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTES_ELEMENTS: usize =
    offset_of!(TSImportAttributes, elements);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportAttributesWithoutElements<'a>(pub(crate) *const TSImportAttributes<'a>);

impl<'a> TSImportAttributesWithoutElements<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTES_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_SPAN: usize = offset_of!(TSImportAttribute, span);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_NAME: usize = offset_of!(TSImportAttribute, name);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_VALUE: usize = offset_of!(TSImportAttribute, value);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportAttributeWithoutName<'a>(pub(crate) *const TSImportAttribute<'a>);

impl<'a> TSImportAttributeWithoutName<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_VALUE) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportAttributeWithoutValue<'a>(pub(crate) *const TSImportAttribute<'a>);

impl<'a> TSImportAttributeWithoutValue<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(&self) -> &TSImportAttributeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_NAME)
                as *const TSImportAttributeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_FUNCTION_TYPE_SPAN: usize = offset_of!(TSFunctionType, span);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_THIS_PARAM: usize = offset_of!(TSFunctionType, this_param);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_PARAMS: usize = offset_of!(TSFunctionType, params);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE: usize =
    offset_of!(TSFunctionType, return_type);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSFunctionType, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSFunctionTypeWithoutThisParam<'a>(pub(crate) *const TSFunctionType<'a>);

impl<'a> TSFunctionTypeWithoutThisParam<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSFunctionTypeWithoutParams<'a>(pub(crate) *const TSFunctionType<'a>);

impl<'a> TSFunctionTypeWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSFunctionTypeWithoutReturnType<'a>(pub(crate) *const TSFunctionType<'a>);

impl<'a> TSFunctionTypeWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSFunctionTypeWithoutTypeParameters<'a>(pub(crate) *const TSFunctionType<'a>);

impl<'a> TSFunctionTypeWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this_param(&self) -> &Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_SPAN: usize = offset_of!(TSConstructorType, span);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT: usize =
    offset_of!(TSConstructorType, r#abstract);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS: usize = offset_of!(TSConstructorType, params);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE: usize =
    offset_of!(TSConstructorType, return_type);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSConstructorType, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructorTypeWithoutParams<'a>(pub(crate) *const TSConstructorType<'a>);

impl<'a> TSConstructorTypeWithoutParams<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn return_type(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructorTypeWithoutReturnType<'a>(pub(crate) *const TSConstructorType<'a>);

impl<'a> TSConstructorTypeWithoutReturnType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSConstructorTypeWithoutTypeParameters<'a>(pub(crate) *const TSConstructorType<'a>);

impl<'a> TSConstructorTypeWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn params(&self) -> &Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(&self) -> &Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_MAPPED_TYPE_SPAN: usize = offset_of!(TSMappedType, span);
pub(crate) const OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER: usize =
    offset_of!(TSMappedType, type_parameter);
pub(crate) const OFFSET_TS_MAPPED_TYPE_NAME_TYPE: usize = offset_of!(TSMappedType, name_type);
pub(crate) const OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSMappedType, type_annotation);
pub(crate) const OFFSET_TS_MAPPED_TYPE_OPTIONAL: usize = offset_of!(TSMappedType, optional);
pub(crate) const OFFSET_TS_MAPPED_TYPE_READONLY: usize = offset_of!(TSMappedType, readonly);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMappedTypeWithoutTypeParameter<'a>(pub(crate) *const TSMappedType<'a>);

impl<'a> TSMappedTypeWithoutTypeParameter<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name_type(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_NAME_TYPE)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMappedTypeWithoutNameType<'a>(pub(crate) *const TSMappedType<'a>);

impl<'a> TSMappedTypeWithoutNameType<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameter(&self) -> &Box<'a, TSTypeParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER)
                as *const Box<'a, TSTypeParameter<'a>>)
        }
    }

    #[inline]
    pub fn type_annotation(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSMappedTypeWithoutTypeAnnotation<'a>(pub(crate) *const TSMappedType<'a>);

impl<'a> TSMappedTypeWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameter(&self) -> &Box<'a, TSTypeParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER)
                as *const Box<'a, TSTypeParameter<'a>>)
        }
    }

    #[inline]
    pub fn name_type(&self) -> &Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_NAME_TYPE)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(&self) -> &TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }
}

pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN: usize =
    offset_of!(TSTemplateLiteralType, span);
pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_QUASIS: usize =
    offset_of!(TSTemplateLiteralType, quasis);
pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_TYPES: usize =
    offset_of!(TSTemplateLiteralType, types);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTemplateLiteralTypeWithoutQuasis<'a>(pub(crate) *const TSTemplateLiteralType<'a>);

impl<'a> TSTemplateLiteralTypeWithoutQuasis<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn types(&self) -> &Vec<'a, TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_TYPES)
                as *const Vec<'a, TSType<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTemplateLiteralTypeWithoutTypes<'a>(pub(crate) *const TSTemplateLiteralType<'a>);

impl<'a> TSTemplateLiteralTypeWithoutTypes<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn quasis(&self) -> &Vec<'a, TemplateElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_QUASIS)
                as *const Vec<'a, TemplateElement<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_AS_EXPRESSION_SPAN: usize = offset_of!(TSAsExpression, span);
pub(crate) const OFFSET_TS_AS_EXPRESSION_EXPRESSION: usize = offset_of!(TSAsExpression, expression);
pub(crate) const OFFSET_TS_AS_EXPRESSION_TYPE_ANNOTATION: usize =
    offset_of!(TSAsExpression, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSAsExpressionWithoutExpression<'a>(pub(crate) *const TSAsExpression<'a>);

impl<'a> TSAsExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSAsExpressionWithoutTypeAnnotation<'a>(pub(crate) *const TSAsExpression<'a>);

impl<'a> TSAsExpressionWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_SPAN: usize =
    offset_of!(TSSatisfiesExpression, span);
pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSSatisfiesExpression, expression);
pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_TYPE_ANNOTATION: usize =
    offset_of!(TSSatisfiesExpression, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSSatisfiesExpressionWithoutExpression<'a>(pub(crate) *const TSSatisfiesExpression<'a>);

impl<'a> TSSatisfiesExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSSatisfiesExpressionWithoutTypeAnnotation<'a>(
    pub(crate) *const TSSatisfiesExpression<'a>,
);

impl<'a> TSSatisfiesExpressionWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ASSERTION_SPAN: usize = offset_of!(TSTypeAssertion, span);
pub(crate) const OFFSET_TS_TYPE_ASSERTION_EXPRESSION: usize =
    offset_of!(TSTypeAssertion, expression);
pub(crate) const OFFSET_TS_TYPE_ASSERTION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAssertion, type_annotation);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAssertionWithoutExpression<'a>(pub(crate) *const TSTypeAssertion<'a>);

impl<'a> TSTypeAssertionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(&self) -> &TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSTypeAssertionWithoutTypeAnnotation<'a>(pub(crate) *const TSTypeAssertion<'a>);

impl<'a> TSTypeAssertionWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN: usize =
    offset_of!(TSImportEqualsDeclaration, span);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_ID: usize =
    offset_of!(TSImportEqualsDeclaration, id);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_MODULE_REFERENCE: usize =
    offset_of!(TSImportEqualsDeclaration, module_reference);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND: usize =
    offset_of!(TSImportEqualsDeclaration, import_kind);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportEqualsDeclarationWithoutId<'a>(pub(crate) *const TSImportEqualsDeclaration<'a>);

impl<'a> TSImportEqualsDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn module_reference(&self) -> &TSModuleReference<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_MODULE_REFERENCE)
                as *const TSModuleReference<'a>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSImportEqualsDeclarationWithoutModuleReference<'a>(
    pub(crate) *const TSImportEqualsDeclaration<'a>,
);

impl<'a> TSImportEqualsDeclarationWithoutModuleReference<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(&self) -> &BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn import_kind(&self) -> &ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_TS_EXTERNAL_MODULE_REFERENCE_SPAN: usize =
    offset_of!(TSExternalModuleReference, span);
pub(crate) const OFFSET_TS_EXTERNAL_MODULE_REFERENCE_EXPRESSION: usize =
    offset_of!(TSExternalModuleReference, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSExternalModuleReferenceWithoutExpression<'a>(
    pub(crate) *const TSExternalModuleReference<'a>,
);

impl<'a> TSExternalModuleReferenceWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_EXTERNAL_MODULE_REFERENCE_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_NON_NULL_EXPRESSION_SPAN: usize = offset_of!(TSNonNullExpression, span);
pub(crate) const OFFSET_TS_NON_NULL_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSNonNullExpression, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSNonNullExpressionWithoutExpression<'a>(pub(crate) *const TSNonNullExpression<'a>);

impl<'a> TSNonNullExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NON_NULL_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_DECORATOR_SPAN: usize = offset_of!(Decorator, span);
pub(crate) const OFFSET_DECORATOR_EXPRESSION: usize = offset_of!(Decorator, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct DecoratorWithoutExpression<'a>(pub(crate) *const Decorator<'a>);

impl<'a> DecoratorWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DECORATOR_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_EXPORT_ASSIGNMENT_SPAN: usize = offset_of!(TSExportAssignment, span);
pub(crate) const OFFSET_TS_EXPORT_ASSIGNMENT_EXPRESSION: usize =
    offset_of!(TSExportAssignment, expression);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSExportAssignmentWithoutExpression<'a>(pub(crate) *const TSExportAssignment<'a>);

impl<'a> TSExportAssignmentWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_EXPORT_ASSIGNMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_SPAN: usize =
    offset_of!(TSNamespaceExportDeclaration, span);
pub(crate) const OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_ID: usize =
    offset_of!(TSNamespaceExportDeclaration, id);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSNamespaceExportDeclarationWithoutId<'a>(
    pub(crate) *const TSNamespaceExportDeclaration<'a>,
);

impl<'a> TSNamespaceExportDeclarationWithoutId<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_SPAN)
                as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN: usize =
    offset_of!(TSInstantiationExpression, span);
pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSInstantiationExpression, expression);
pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(TSInstantiationExpression, type_parameters);

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInstantiationExpressionWithoutExpression<'a>(
    pub(crate) *const TSInstantiationExpression<'a>,
);

impl<'a> TSInstantiationExpressionWithoutExpression<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(&self) -> &Box<'a, TSTypeParameterInstantiation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_TYPE_PARAMETERS)
                as *const Box<'a, TSTypeParameterInstantiation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub struct TSInstantiationExpressionWithoutTypeParameters<'a>(
    pub(crate) *const TSInstantiationExpression<'a>,
);

impl<'a> TSInstantiationExpressionWithoutTypeParameters<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(&self) -> &Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_SPAN: usize = offset_of!(JSDocNullableType, span);
pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(JSDocNullableType, type_annotation);
pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_POSTFIX: usize =
    offset_of!(JSDocNullableType, postfix);

#[repr(transparent)]
#[derive(Debug)]
pub struct JSDocNullableTypeWithoutTypeAnnotation<'a>(pub(crate) *const JSDocNullableType<'a>);

impl<'a> JSDocNullableTypeWithoutTypeAnnotation<'a> {
    #[inline]
    pub fn span(&self) -> &Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JS_DOC_NULLABLE_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn postfix(&self) -> &bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JS_DOC_NULLABLE_TYPE_POSTFIX) as *const bool) }
    }
}
