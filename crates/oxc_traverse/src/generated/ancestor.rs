// Auto-generated code, DO NOT EDIT DIRECTLY!
// Generated by `oxc_traverse/scripts/build.mjs`.
// To alter this generated file you have to edit the codegen.

#![allow(
    unsafe_code,
    clippy::missing_safety_doc,
    clippy::ptr_as_ptr,
    clippy::undocumented_unsafe_blocks,
    clippy::cast_ptr_alignment
)]

use std::{cell::Cell, marker::PhantomData};

use memoffset::offset_of;

use oxc_allocator::{Box, Vec};
#[allow(clippy::wildcard_imports)]
use oxc_ast::ast::*;
use oxc_syntax::scope::ScopeId;

/// Type of [`Ancestor`].
/// Used in [`crate::TraverseCtx::retag_stack`].
#[repr(u16)]
#[derive(Clone, Copy)]
#[allow(dead_code)]
pub(crate) enum AncestorType {
    None = 0,
    ProgramHashbang = 1,
    ProgramDirectives = 2,
    ProgramBody = 3,
    ArrayExpressionElements = 4,
    ObjectExpressionProperties = 5,
    ObjectPropertyKey = 6,
    ObjectPropertyValue = 7,
    ObjectPropertyInit = 8,
    TemplateLiteralQuasis = 9,
    TemplateLiteralExpressions = 10,
    TaggedTemplateExpressionTag = 11,
    TaggedTemplateExpressionQuasi = 12,
    TaggedTemplateExpressionTypeParameters = 13,
    ComputedMemberExpressionObject = 14,
    ComputedMemberExpressionExpression = 15,
    StaticMemberExpressionObject = 16,
    StaticMemberExpressionProperty = 17,
    PrivateFieldExpressionObject = 18,
    PrivateFieldExpressionField = 19,
    CallExpressionCallee = 20,
    CallExpressionTypeParameters = 21,
    CallExpressionArguments = 22,
    NewExpressionCallee = 23,
    NewExpressionArguments = 24,
    NewExpressionTypeParameters = 25,
    MetaPropertyMeta = 26,
    MetaPropertyProperty = 27,
    SpreadElementArgument = 28,
    UpdateExpressionArgument = 29,
    UnaryExpressionArgument = 30,
    BinaryExpressionLeft = 31,
    BinaryExpressionRight = 32,
    PrivateInExpressionLeft = 33,
    PrivateInExpressionRight = 34,
    LogicalExpressionLeft = 35,
    LogicalExpressionRight = 36,
    ConditionalExpressionTest = 37,
    ConditionalExpressionConsequent = 38,
    ConditionalExpressionAlternate = 39,
    AssignmentExpressionLeft = 40,
    AssignmentExpressionRight = 41,
    ArrayAssignmentTargetElements = 42,
    ArrayAssignmentTargetRest = 43,
    ObjectAssignmentTargetProperties = 44,
    ObjectAssignmentTargetRest = 45,
    AssignmentTargetRestTarget = 46,
    AssignmentTargetWithDefaultBinding = 47,
    AssignmentTargetWithDefaultInit = 48,
    AssignmentTargetPropertyIdentifierBinding = 49,
    AssignmentTargetPropertyIdentifierInit = 50,
    AssignmentTargetPropertyPropertyName = 51,
    AssignmentTargetPropertyPropertyBinding = 52,
    SequenceExpressionExpressions = 53,
    AwaitExpressionArgument = 54,
    ChainExpressionExpression = 55,
    ParenthesizedExpressionExpression = 56,
    DirectiveExpression = 57,
    BlockStatementBody = 58,
    VariableDeclarationDeclarations = 59,
    VariableDeclaratorId = 60,
    VariableDeclaratorInit = 61,
    ExpressionStatementExpression = 62,
    IfStatementTest = 63,
    IfStatementConsequent = 64,
    IfStatementAlternate = 65,
    DoWhileStatementBody = 66,
    DoWhileStatementTest = 67,
    WhileStatementTest = 68,
    WhileStatementBody = 69,
    ForStatementInit = 70,
    ForStatementTest = 71,
    ForStatementUpdate = 72,
    ForStatementBody = 73,
    ForInStatementLeft = 74,
    ForInStatementRight = 75,
    ForInStatementBody = 76,
    ForOfStatementLeft = 77,
    ForOfStatementRight = 78,
    ForOfStatementBody = 79,
    ContinueStatementLabel = 80,
    BreakStatementLabel = 81,
    ReturnStatementArgument = 82,
    WithStatementObject = 83,
    WithStatementBody = 84,
    SwitchStatementDiscriminant = 85,
    SwitchStatementCases = 86,
    SwitchCaseTest = 87,
    SwitchCaseConsequent = 88,
    LabeledStatementLabel = 89,
    LabeledStatementBody = 90,
    ThrowStatementArgument = 91,
    TryStatementBlock = 92,
    TryStatementHandler = 93,
    TryStatementFinalizer = 94,
    CatchClauseParam = 95,
    CatchClauseBody = 96,
    CatchParameterPattern = 97,
    BindingPatternKind = 98,
    BindingPatternTypeAnnotation = 99,
    AssignmentPatternLeft = 100,
    AssignmentPatternRight = 101,
    ObjectPatternProperties = 102,
    ObjectPatternRest = 103,
    BindingPropertyKey = 104,
    BindingPropertyValue = 105,
    ArrayPatternElements = 106,
    ArrayPatternRest = 107,
    BindingRestElementArgument = 108,
    FunctionId = 109,
    FunctionTypeParameters = 110,
    FunctionThisParam = 111,
    FunctionParams = 112,
    FunctionReturnType = 113,
    FunctionBody = 114,
    FormalParametersItems = 115,
    FormalParametersRest = 116,
    FormalParameterDecorators = 117,
    FormalParameterPattern = 118,
    FunctionBodyDirectives = 119,
    FunctionBodyStatements = 120,
    ArrowFunctionExpressionTypeParameters = 121,
    ArrowFunctionExpressionParams = 122,
    ArrowFunctionExpressionReturnType = 123,
    ArrowFunctionExpressionBody = 124,
    YieldExpressionArgument = 125,
    ClassDecorators = 126,
    ClassId = 127,
    ClassTypeParameters = 128,
    ClassSuperClass = 129,
    ClassSuperTypeParameters = 130,
    ClassImplements = 131,
    ClassBody = 132,
    ClassBodyBody = 133,
    MethodDefinitionDecorators = 134,
    MethodDefinitionKey = 135,
    MethodDefinitionValue = 136,
    PropertyDefinitionDecorators = 137,
    PropertyDefinitionKey = 138,
    PropertyDefinitionValue = 139,
    PropertyDefinitionTypeAnnotation = 140,
    StaticBlockBody = 141,
    AccessorPropertyDecorators = 142,
    AccessorPropertyKey = 143,
    AccessorPropertyValue = 144,
    AccessorPropertyTypeAnnotation = 145,
    ImportExpressionSource = 146,
    ImportExpressionArguments = 147,
    ImportDeclarationSpecifiers = 148,
    ImportDeclarationSource = 149,
    ImportDeclarationWithClause = 150,
    ImportSpecifierImported = 151,
    ImportSpecifierLocal = 152,
    ImportDefaultSpecifierLocal = 153,
    ImportNamespaceSpecifierLocal = 154,
    WithClauseAttributesKeyword = 155,
    WithClauseWithEntries = 156,
    ImportAttributeKey = 157,
    ImportAttributeValue = 158,
    ExportNamedDeclarationDeclaration = 159,
    ExportNamedDeclarationSpecifiers = 160,
    ExportNamedDeclarationSource = 161,
    ExportNamedDeclarationWithClause = 162,
    ExportDefaultDeclarationDeclaration = 163,
    ExportDefaultDeclarationExported = 164,
    ExportAllDeclarationExported = 165,
    ExportAllDeclarationSource = 166,
    ExportAllDeclarationWithClause = 167,
    ExportSpecifierLocal = 168,
    ExportSpecifierExported = 169,
    JSXElementOpeningElement = 170,
    JSXElementClosingElement = 171,
    JSXElementChildren = 172,
    JSXOpeningElementName = 173,
    JSXOpeningElementAttributes = 174,
    JSXOpeningElementTypeParameters = 175,
    JSXClosingElementName = 176,
    JSXFragmentChildren = 177,
    JSXNamespacedNameNamespace = 178,
    JSXNamespacedNameProperty = 179,
    JSXMemberExpressionObject = 180,
    JSXMemberExpressionProperty = 181,
    JSXExpressionContainerExpression = 182,
    JSXAttributeName = 183,
    JSXAttributeValue = 184,
    JSXSpreadAttributeArgument = 185,
    JSXSpreadChildExpression = 186,
    TSThisParameterTypeAnnotation = 187,
    TSEnumDeclarationId = 188,
    TSEnumDeclarationMembers = 189,
    TSEnumMemberId = 190,
    TSEnumMemberInitializer = 191,
    TSTypeAnnotationTypeAnnotation = 192,
    TSLiteralTypeLiteral = 193,
    TSConditionalTypeCheckType = 194,
    TSConditionalTypeExtendsType = 195,
    TSConditionalTypeTrueType = 196,
    TSConditionalTypeFalseType = 197,
    TSUnionTypeTypes = 198,
    TSIntersectionTypeTypes = 199,
    TSParenthesizedTypeTypeAnnotation = 200,
    TSTypeOperatorTypeAnnotation = 201,
    TSArrayTypeElementType = 202,
    TSIndexedAccessTypeObjectType = 203,
    TSIndexedAccessTypeIndexType = 204,
    TSTupleTypeElementTypes = 205,
    TSNamedTupleMemberElementType = 206,
    TSNamedTupleMemberLabel = 207,
    TSOptionalTypeTypeAnnotation = 208,
    TSRestTypeTypeAnnotation = 209,
    TSTypeReferenceTypeName = 210,
    TSTypeReferenceTypeParameters = 211,
    TSQualifiedNameLeft = 212,
    TSQualifiedNameRight = 213,
    TSTypeParameterInstantiationParams = 214,
    TSTypeParameterName = 215,
    TSTypeParameterConstraint = 216,
    TSTypeParameterDefault = 217,
    TSTypeParameterDeclarationParams = 218,
    TSTypeAliasDeclarationId = 219,
    TSTypeAliasDeclarationTypeParameters = 220,
    TSTypeAliasDeclarationTypeAnnotation = 221,
    TSClassImplementsExpression = 222,
    TSClassImplementsTypeParameters = 223,
    TSInterfaceDeclarationId = 224,
    TSInterfaceDeclarationExtends = 225,
    TSInterfaceDeclarationTypeParameters = 226,
    TSInterfaceDeclarationBody = 227,
    TSInterfaceBodyBody = 228,
    TSPropertySignatureKey = 229,
    TSPropertySignatureTypeAnnotation = 230,
    TSIndexSignatureParameters = 231,
    TSIndexSignatureTypeAnnotation = 232,
    TSCallSignatureDeclarationTypeParameters = 233,
    TSCallSignatureDeclarationThisParam = 234,
    TSCallSignatureDeclarationParams = 235,
    TSCallSignatureDeclarationReturnType = 236,
    TSMethodSignatureKey = 237,
    TSMethodSignatureTypeParameters = 238,
    TSMethodSignatureThisParam = 239,
    TSMethodSignatureParams = 240,
    TSMethodSignatureReturnType = 241,
    TSConstructSignatureDeclarationTypeParameters = 242,
    TSConstructSignatureDeclarationParams = 243,
    TSConstructSignatureDeclarationReturnType = 244,
    TSIndexSignatureNameTypeAnnotation = 245,
    TSInterfaceHeritageExpression = 246,
    TSInterfaceHeritageTypeParameters = 247,
    TSTypePredicateParameterName = 248,
    TSTypePredicateTypeAnnotation = 249,
    TSModuleDeclarationId = 250,
    TSModuleDeclarationBody = 251,
    TSModuleBlockDirectives = 252,
    TSModuleBlockBody = 253,
    TSTypeLiteralMembers = 254,
    TSInferTypeTypeParameter = 255,
    TSTypeQueryExprName = 256,
    TSTypeQueryTypeParameters = 257,
    TSImportTypeParameter = 258,
    TSImportTypeQualifier = 259,
    TSImportTypeAttributes = 260,
    TSImportTypeTypeParameters = 261,
    TSImportAttributesAttributesKeyword = 262,
    TSImportAttributesElements = 263,
    TSImportAttributeName = 264,
    TSImportAttributeValue = 265,
    TSFunctionTypeTypeParameters = 266,
    TSFunctionTypeThisParam = 267,
    TSFunctionTypeParams = 268,
    TSFunctionTypeReturnType = 269,
    TSConstructorTypeTypeParameters = 270,
    TSConstructorTypeParams = 271,
    TSConstructorTypeReturnType = 272,
    TSMappedTypeTypeParameter = 273,
    TSMappedTypeNameType = 274,
    TSMappedTypeTypeAnnotation = 275,
    TSTemplateLiteralTypeQuasis = 276,
    TSTemplateLiteralTypeTypes = 277,
    TSAsExpressionExpression = 278,
    TSAsExpressionTypeAnnotation = 279,
    TSSatisfiesExpressionExpression = 280,
    TSSatisfiesExpressionTypeAnnotation = 281,
    TSTypeAssertionExpression = 282,
    TSTypeAssertionTypeAnnotation = 283,
    TSImportEqualsDeclarationId = 284,
    TSImportEqualsDeclarationModuleReference = 285,
    TSExternalModuleReferenceExpression = 286,
    TSNonNullExpressionExpression = 287,
    DecoratorExpression = 288,
    TSExportAssignmentExpression = 289,
    TSNamespaceExportDeclarationId = 290,
    TSInstantiationExpressionExpression = 291,
    TSInstantiationExpressionTypeParameters = 292,
    JSDocNullableTypeTypeAnnotation = 293,
    JSDocNonNullableTypeTypeAnnotation = 294,
}

/// Ancestor type used in AST traversal.
///
/// Encodes both the type of the parent, and child's location in the parent.
/// i.e. variants for `BinaryExpressionLeft` and `BinaryExpressionRight`, not just `BinaryExpression`.
///
/// `'a` is lifetime of AST nodes.
/// `'t` is lifetime of the `Ancestor` (which inherits lifetime from `&'t TraverseCtx'`).
/// i.e. `Ancestor`s can only exist within the body of `enter_*` and `exit_*` methods
/// and cannot "escape" from them.
//
// SAFETY:
// * This type must be `#[repr(u16)]`.
// * Variant discriminants must correspond to those in `AncestorType`.
//
// These invariants make it possible to set the discriminant of an `Ancestor` without altering
// the "payload" pointer with:
// `*(ancestor as *mut _ as *mut AncestorType) = AncestorType::Program`.
// `TraverseCtx::retag_stack` uses this technique.
#[repr(C, u16)]
#[derive(Clone, Copy, Debug)]
pub enum Ancestor<'a, 't> {
    None = AncestorType::None as u16,
    ProgramHashbang(ProgramWithoutHashbang<'a, 't>) = AncestorType::ProgramHashbang as u16,
    ProgramDirectives(ProgramWithoutDirectives<'a, 't>) = AncestorType::ProgramDirectives as u16,
    ProgramBody(ProgramWithoutBody<'a, 't>) = AncestorType::ProgramBody as u16,
    ArrayExpressionElements(ArrayExpressionWithoutElements<'a, 't>) =
        AncestorType::ArrayExpressionElements as u16,
    ObjectExpressionProperties(ObjectExpressionWithoutProperties<'a, 't>) =
        AncestorType::ObjectExpressionProperties as u16,
    ObjectPropertyKey(ObjectPropertyWithoutKey<'a, 't>) = AncestorType::ObjectPropertyKey as u16,
    ObjectPropertyValue(ObjectPropertyWithoutValue<'a, 't>) =
        AncestorType::ObjectPropertyValue as u16,
    ObjectPropertyInit(ObjectPropertyWithoutInit<'a, 't>) = AncestorType::ObjectPropertyInit as u16,
    TemplateLiteralQuasis(TemplateLiteralWithoutQuasis<'a, 't>) =
        AncestorType::TemplateLiteralQuasis as u16,
    TemplateLiteralExpressions(TemplateLiteralWithoutExpressions<'a, 't>) =
        AncestorType::TemplateLiteralExpressions as u16,
    TaggedTemplateExpressionTag(TaggedTemplateExpressionWithoutTag<'a, 't>) =
        AncestorType::TaggedTemplateExpressionTag as u16,
    TaggedTemplateExpressionQuasi(TaggedTemplateExpressionWithoutQuasi<'a, 't>) =
        AncestorType::TaggedTemplateExpressionQuasi as u16,
    TaggedTemplateExpressionTypeParameters(TaggedTemplateExpressionWithoutTypeParameters<'a, 't>) =
        AncestorType::TaggedTemplateExpressionTypeParameters as u16,
    ComputedMemberExpressionObject(ComputedMemberExpressionWithoutObject<'a, 't>) =
        AncestorType::ComputedMemberExpressionObject as u16,
    ComputedMemberExpressionExpression(ComputedMemberExpressionWithoutExpression<'a, 't>) =
        AncestorType::ComputedMemberExpressionExpression as u16,
    StaticMemberExpressionObject(StaticMemberExpressionWithoutObject<'a, 't>) =
        AncestorType::StaticMemberExpressionObject as u16,
    StaticMemberExpressionProperty(StaticMemberExpressionWithoutProperty<'a, 't>) =
        AncestorType::StaticMemberExpressionProperty as u16,
    PrivateFieldExpressionObject(PrivateFieldExpressionWithoutObject<'a, 't>) =
        AncestorType::PrivateFieldExpressionObject as u16,
    PrivateFieldExpressionField(PrivateFieldExpressionWithoutField<'a, 't>) =
        AncestorType::PrivateFieldExpressionField as u16,
    CallExpressionCallee(CallExpressionWithoutCallee<'a, 't>) =
        AncestorType::CallExpressionCallee as u16,
    CallExpressionTypeParameters(CallExpressionWithoutTypeParameters<'a, 't>) =
        AncestorType::CallExpressionTypeParameters as u16,
    CallExpressionArguments(CallExpressionWithoutArguments<'a, 't>) =
        AncestorType::CallExpressionArguments as u16,
    NewExpressionCallee(NewExpressionWithoutCallee<'a, 't>) =
        AncestorType::NewExpressionCallee as u16,
    NewExpressionArguments(NewExpressionWithoutArguments<'a, 't>) =
        AncestorType::NewExpressionArguments as u16,
    NewExpressionTypeParameters(NewExpressionWithoutTypeParameters<'a, 't>) =
        AncestorType::NewExpressionTypeParameters as u16,
    MetaPropertyMeta(MetaPropertyWithoutMeta<'a, 't>) = AncestorType::MetaPropertyMeta as u16,
    MetaPropertyProperty(MetaPropertyWithoutProperty<'a, 't>) =
        AncestorType::MetaPropertyProperty as u16,
    SpreadElementArgument(SpreadElementWithoutArgument<'a, 't>) =
        AncestorType::SpreadElementArgument as u16,
    UpdateExpressionArgument(UpdateExpressionWithoutArgument<'a, 't>) =
        AncestorType::UpdateExpressionArgument as u16,
    UnaryExpressionArgument(UnaryExpressionWithoutArgument<'a, 't>) =
        AncestorType::UnaryExpressionArgument as u16,
    BinaryExpressionLeft(BinaryExpressionWithoutLeft<'a, 't>) =
        AncestorType::BinaryExpressionLeft as u16,
    BinaryExpressionRight(BinaryExpressionWithoutRight<'a, 't>) =
        AncestorType::BinaryExpressionRight as u16,
    PrivateInExpressionLeft(PrivateInExpressionWithoutLeft<'a, 't>) =
        AncestorType::PrivateInExpressionLeft as u16,
    PrivateInExpressionRight(PrivateInExpressionWithoutRight<'a, 't>) =
        AncestorType::PrivateInExpressionRight as u16,
    LogicalExpressionLeft(LogicalExpressionWithoutLeft<'a, 't>) =
        AncestorType::LogicalExpressionLeft as u16,
    LogicalExpressionRight(LogicalExpressionWithoutRight<'a, 't>) =
        AncestorType::LogicalExpressionRight as u16,
    ConditionalExpressionTest(ConditionalExpressionWithoutTest<'a, 't>) =
        AncestorType::ConditionalExpressionTest as u16,
    ConditionalExpressionConsequent(ConditionalExpressionWithoutConsequent<'a, 't>) =
        AncestorType::ConditionalExpressionConsequent as u16,
    ConditionalExpressionAlternate(ConditionalExpressionWithoutAlternate<'a, 't>) =
        AncestorType::ConditionalExpressionAlternate as u16,
    AssignmentExpressionLeft(AssignmentExpressionWithoutLeft<'a, 't>) =
        AncestorType::AssignmentExpressionLeft as u16,
    AssignmentExpressionRight(AssignmentExpressionWithoutRight<'a, 't>) =
        AncestorType::AssignmentExpressionRight as u16,
    ArrayAssignmentTargetElements(ArrayAssignmentTargetWithoutElements<'a, 't>) =
        AncestorType::ArrayAssignmentTargetElements as u16,
    ArrayAssignmentTargetRest(ArrayAssignmentTargetWithoutRest<'a, 't>) =
        AncestorType::ArrayAssignmentTargetRest as u16,
    ObjectAssignmentTargetProperties(ObjectAssignmentTargetWithoutProperties<'a, 't>) =
        AncestorType::ObjectAssignmentTargetProperties as u16,
    ObjectAssignmentTargetRest(ObjectAssignmentTargetWithoutRest<'a, 't>) =
        AncestorType::ObjectAssignmentTargetRest as u16,
    AssignmentTargetRestTarget(AssignmentTargetRestWithoutTarget<'a, 't>) =
        AncestorType::AssignmentTargetRestTarget as u16,
    AssignmentTargetWithDefaultBinding(AssignmentTargetWithDefaultWithoutBinding<'a, 't>) =
        AncestorType::AssignmentTargetWithDefaultBinding as u16,
    AssignmentTargetWithDefaultInit(AssignmentTargetWithDefaultWithoutInit<'a, 't>) =
        AncestorType::AssignmentTargetWithDefaultInit as u16,
    AssignmentTargetPropertyIdentifierBinding(
        AssignmentTargetPropertyIdentifierWithoutBinding<'a, 't>,
    ) = AncestorType::AssignmentTargetPropertyIdentifierBinding as u16,
    AssignmentTargetPropertyIdentifierInit(AssignmentTargetPropertyIdentifierWithoutInit<'a, 't>) =
        AncestorType::AssignmentTargetPropertyIdentifierInit as u16,
    AssignmentTargetPropertyPropertyName(AssignmentTargetPropertyPropertyWithoutName<'a, 't>) =
        AncestorType::AssignmentTargetPropertyPropertyName as u16,
    AssignmentTargetPropertyPropertyBinding(AssignmentTargetPropertyPropertyWithoutBinding<'a, 't>) =
        AncestorType::AssignmentTargetPropertyPropertyBinding as u16,
    SequenceExpressionExpressions(SequenceExpressionWithoutExpressions<'a, 't>) =
        AncestorType::SequenceExpressionExpressions as u16,
    AwaitExpressionArgument(AwaitExpressionWithoutArgument<'a, 't>) =
        AncestorType::AwaitExpressionArgument as u16,
    ChainExpressionExpression(ChainExpressionWithoutExpression<'a, 't>) =
        AncestorType::ChainExpressionExpression as u16,
    ParenthesizedExpressionExpression(ParenthesizedExpressionWithoutExpression<'a, 't>) =
        AncestorType::ParenthesizedExpressionExpression as u16,
    DirectiveExpression(DirectiveWithoutExpression<'a, 't>) =
        AncestorType::DirectiveExpression as u16,
    BlockStatementBody(BlockStatementWithoutBody<'a, 't>) = AncestorType::BlockStatementBody as u16,
    VariableDeclarationDeclarations(VariableDeclarationWithoutDeclarations<'a, 't>) =
        AncestorType::VariableDeclarationDeclarations as u16,
    VariableDeclaratorId(VariableDeclaratorWithoutId<'a, 't>) =
        AncestorType::VariableDeclaratorId as u16,
    VariableDeclaratorInit(VariableDeclaratorWithoutInit<'a, 't>) =
        AncestorType::VariableDeclaratorInit as u16,
    ExpressionStatementExpression(ExpressionStatementWithoutExpression<'a, 't>) =
        AncestorType::ExpressionStatementExpression as u16,
    IfStatementTest(IfStatementWithoutTest<'a, 't>) = AncestorType::IfStatementTest as u16,
    IfStatementConsequent(IfStatementWithoutConsequent<'a, 't>) =
        AncestorType::IfStatementConsequent as u16,
    IfStatementAlternate(IfStatementWithoutAlternate<'a, 't>) =
        AncestorType::IfStatementAlternate as u16,
    DoWhileStatementBody(DoWhileStatementWithoutBody<'a, 't>) =
        AncestorType::DoWhileStatementBody as u16,
    DoWhileStatementTest(DoWhileStatementWithoutTest<'a, 't>) =
        AncestorType::DoWhileStatementTest as u16,
    WhileStatementTest(WhileStatementWithoutTest<'a, 't>) = AncestorType::WhileStatementTest as u16,
    WhileStatementBody(WhileStatementWithoutBody<'a, 't>) = AncestorType::WhileStatementBody as u16,
    ForStatementInit(ForStatementWithoutInit<'a, 't>) = AncestorType::ForStatementInit as u16,
    ForStatementTest(ForStatementWithoutTest<'a, 't>) = AncestorType::ForStatementTest as u16,
    ForStatementUpdate(ForStatementWithoutUpdate<'a, 't>) = AncestorType::ForStatementUpdate as u16,
    ForStatementBody(ForStatementWithoutBody<'a, 't>) = AncestorType::ForStatementBody as u16,
    ForInStatementLeft(ForInStatementWithoutLeft<'a, 't>) = AncestorType::ForInStatementLeft as u16,
    ForInStatementRight(ForInStatementWithoutRight<'a, 't>) =
        AncestorType::ForInStatementRight as u16,
    ForInStatementBody(ForInStatementWithoutBody<'a, 't>) = AncestorType::ForInStatementBody as u16,
    ForOfStatementLeft(ForOfStatementWithoutLeft<'a, 't>) = AncestorType::ForOfStatementLeft as u16,
    ForOfStatementRight(ForOfStatementWithoutRight<'a, 't>) =
        AncestorType::ForOfStatementRight as u16,
    ForOfStatementBody(ForOfStatementWithoutBody<'a, 't>) = AncestorType::ForOfStatementBody as u16,
    ContinueStatementLabel(ContinueStatementWithoutLabel<'a, 't>) =
        AncestorType::ContinueStatementLabel as u16,
    BreakStatementLabel(BreakStatementWithoutLabel<'a, 't>) =
        AncestorType::BreakStatementLabel as u16,
    ReturnStatementArgument(ReturnStatementWithoutArgument<'a, 't>) =
        AncestorType::ReturnStatementArgument as u16,
    WithStatementObject(WithStatementWithoutObject<'a, 't>) =
        AncestorType::WithStatementObject as u16,
    WithStatementBody(WithStatementWithoutBody<'a, 't>) = AncestorType::WithStatementBody as u16,
    SwitchStatementDiscriminant(SwitchStatementWithoutDiscriminant<'a, 't>) =
        AncestorType::SwitchStatementDiscriminant as u16,
    SwitchStatementCases(SwitchStatementWithoutCases<'a, 't>) =
        AncestorType::SwitchStatementCases as u16,
    SwitchCaseTest(SwitchCaseWithoutTest<'a, 't>) = AncestorType::SwitchCaseTest as u16,
    SwitchCaseConsequent(SwitchCaseWithoutConsequent<'a, 't>) =
        AncestorType::SwitchCaseConsequent as u16,
    LabeledStatementLabel(LabeledStatementWithoutLabel<'a, 't>) =
        AncestorType::LabeledStatementLabel as u16,
    LabeledStatementBody(LabeledStatementWithoutBody<'a, 't>) =
        AncestorType::LabeledStatementBody as u16,
    ThrowStatementArgument(ThrowStatementWithoutArgument<'a, 't>) =
        AncestorType::ThrowStatementArgument as u16,
    TryStatementBlock(TryStatementWithoutBlock<'a, 't>) = AncestorType::TryStatementBlock as u16,
    TryStatementHandler(TryStatementWithoutHandler<'a, 't>) =
        AncestorType::TryStatementHandler as u16,
    TryStatementFinalizer(TryStatementWithoutFinalizer<'a, 't>) =
        AncestorType::TryStatementFinalizer as u16,
    CatchClauseParam(CatchClauseWithoutParam<'a, 't>) = AncestorType::CatchClauseParam as u16,
    CatchClauseBody(CatchClauseWithoutBody<'a, 't>) = AncestorType::CatchClauseBody as u16,
    CatchParameterPattern(CatchParameterWithoutPattern<'a, 't>) =
        AncestorType::CatchParameterPattern as u16,
    BindingPatternKind(BindingPatternWithoutKind<'a, 't>) = AncestorType::BindingPatternKind as u16,
    BindingPatternTypeAnnotation(BindingPatternWithoutTypeAnnotation<'a, 't>) =
        AncestorType::BindingPatternTypeAnnotation as u16,
    AssignmentPatternLeft(AssignmentPatternWithoutLeft<'a, 't>) =
        AncestorType::AssignmentPatternLeft as u16,
    AssignmentPatternRight(AssignmentPatternWithoutRight<'a, 't>) =
        AncestorType::AssignmentPatternRight as u16,
    ObjectPatternProperties(ObjectPatternWithoutProperties<'a, 't>) =
        AncestorType::ObjectPatternProperties as u16,
    ObjectPatternRest(ObjectPatternWithoutRest<'a, 't>) = AncestorType::ObjectPatternRest as u16,
    BindingPropertyKey(BindingPropertyWithoutKey<'a, 't>) = AncestorType::BindingPropertyKey as u16,
    BindingPropertyValue(BindingPropertyWithoutValue<'a, 't>) =
        AncestorType::BindingPropertyValue as u16,
    ArrayPatternElements(ArrayPatternWithoutElements<'a, 't>) =
        AncestorType::ArrayPatternElements as u16,
    ArrayPatternRest(ArrayPatternWithoutRest<'a, 't>) = AncestorType::ArrayPatternRest as u16,
    BindingRestElementArgument(BindingRestElementWithoutArgument<'a, 't>) =
        AncestorType::BindingRestElementArgument as u16,
    FunctionId(FunctionWithoutId<'a, 't>) = AncestorType::FunctionId as u16,
    FunctionTypeParameters(FunctionWithoutTypeParameters<'a, 't>) =
        AncestorType::FunctionTypeParameters as u16,
    FunctionThisParam(FunctionWithoutThisParam<'a, 't>) = AncestorType::FunctionThisParam as u16,
    FunctionParams(FunctionWithoutParams<'a, 't>) = AncestorType::FunctionParams as u16,
    FunctionReturnType(FunctionWithoutReturnType<'a, 't>) = AncestorType::FunctionReturnType as u16,
    FunctionBody(FunctionWithoutBody<'a, 't>) = AncestorType::FunctionBody as u16,
    FormalParametersItems(FormalParametersWithoutItems<'a, 't>) =
        AncestorType::FormalParametersItems as u16,
    FormalParametersRest(FormalParametersWithoutRest<'a, 't>) =
        AncestorType::FormalParametersRest as u16,
    FormalParameterDecorators(FormalParameterWithoutDecorators<'a, 't>) =
        AncestorType::FormalParameterDecorators as u16,
    FormalParameterPattern(FormalParameterWithoutPattern<'a, 't>) =
        AncestorType::FormalParameterPattern as u16,
    FunctionBodyDirectives(FunctionBodyWithoutDirectives<'a, 't>) =
        AncestorType::FunctionBodyDirectives as u16,
    FunctionBodyStatements(FunctionBodyWithoutStatements<'a, 't>) =
        AncestorType::FunctionBodyStatements as u16,
    ArrowFunctionExpressionTypeParameters(ArrowFunctionExpressionWithoutTypeParameters<'a, 't>) =
        AncestorType::ArrowFunctionExpressionTypeParameters as u16,
    ArrowFunctionExpressionParams(ArrowFunctionExpressionWithoutParams<'a, 't>) =
        AncestorType::ArrowFunctionExpressionParams as u16,
    ArrowFunctionExpressionReturnType(ArrowFunctionExpressionWithoutReturnType<'a, 't>) =
        AncestorType::ArrowFunctionExpressionReturnType as u16,
    ArrowFunctionExpressionBody(ArrowFunctionExpressionWithoutBody<'a, 't>) =
        AncestorType::ArrowFunctionExpressionBody as u16,
    YieldExpressionArgument(YieldExpressionWithoutArgument<'a, 't>) =
        AncestorType::YieldExpressionArgument as u16,
    ClassDecorators(ClassWithoutDecorators<'a, 't>) = AncestorType::ClassDecorators as u16,
    ClassId(ClassWithoutId<'a, 't>) = AncestorType::ClassId as u16,
    ClassTypeParameters(ClassWithoutTypeParameters<'a, 't>) =
        AncestorType::ClassTypeParameters as u16,
    ClassSuperClass(ClassWithoutSuperClass<'a, 't>) = AncestorType::ClassSuperClass as u16,
    ClassSuperTypeParameters(ClassWithoutSuperTypeParameters<'a, 't>) =
        AncestorType::ClassSuperTypeParameters as u16,
    ClassImplements(ClassWithoutImplements<'a, 't>) = AncestorType::ClassImplements as u16,
    ClassBody(ClassWithoutBody<'a, 't>) = AncestorType::ClassBody as u16,
    ClassBodyBody(ClassBodyWithoutBody<'a, 't>) = AncestorType::ClassBodyBody as u16,
    MethodDefinitionDecorators(MethodDefinitionWithoutDecorators<'a, 't>) =
        AncestorType::MethodDefinitionDecorators as u16,
    MethodDefinitionKey(MethodDefinitionWithoutKey<'a, 't>) =
        AncestorType::MethodDefinitionKey as u16,
    MethodDefinitionValue(MethodDefinitionWithoutValue<'a, 't>) =
        AncestorType::MethodDefinitionValue as u16,
    PropertyDefinitionDecorators(PropertyDefinitionWithoutDecorators<'a, 't>) =
        AncestorType::PropertyDefinitionDecorators as u16,
    PropertyDefinitionKey(PropertyDefinitionWithoutKey<'a, 't>) =
        AncestorType::PropertyDefinitionKey as u16,
    PropertyDefinitionValue(PropertyDefinitionWithoutValue<'a, 't>) =
        AncestorType::PropertyDefinitionValue as u16,
    PropertyDefinitionTypeAnnotation(PropertyDefinitionWithoutTypeAnnotation<'a, 't>) =
        AncestorType::PropertyDefinitionTypeAnnotation as u16,
    StaticBlockBody(StaticBlockWithoutBody<'a, 't>) = AncestorType::StaticBlockBody as u16,
    AccessorPropertyDecorators(AccessorPropertyWithoutDecorators<'a, 't>) =
        AncestorType::AccessorPropertyDecorators as u16,
    AccessorPropertyKey(AccessorPropertyWithoutKey<'a, 't>) =
        AncestorType::AccessorPropertyKey as u16,
    AccessorPropertyValue(AccessorPropertyWithoutValue<'a, 't>) =
        AncestorType::AccessorPropertyValue as u16,
    AccessorPropertyTypeAnnotation(AccessorPropertyWithoutTypeAnnotation<'a, 't>) =
        AncestorType::AccessorPropertyTypeAnnotation as u16,
    ImportExpressionSource(ImportExpressionWithoutSource<'a, 't>) =
        AncestorType::ImportExpressionSource as u16,
    ImportExpressionArguments(ImportExpressionWithoutArguments<'a, 't>) =
        AncestorType::ImportExpressionArguments as u16,
    ImportDeclarationSpecifiers(ImportDeclarationWithoutSpecifiers<'a, 't>) =
        AncestorType::ImportDeclarationSpecifiers as u16,
    ImportDeclarationSource(ImportDeclarationWithoutSource<'a, 't>) =
        AncestorType::ImportDeclarationSource as u16,
    ImportDeclarationWithClause(ImportDeclarationWithoutWithClause<'a, 't>) =
        AncestorType::ImportDeclarationWithClause as u16,
    ImportSpecifierImported(ImportSpecifierWithoutImported<'a, 't>) =
        AncestorType::ImportSpecifierImported as u16,
    ImportSpecifierLocal(ImportSpecifierWithoutLocal<'a, 't>) =
        AncestorType::ImportSpecifierLocal as u16,
    ImportDefaultSpecifierLocal(ImportDefaultSpecifierWithoutLocal<'a, 't>) =
        AncestorType::ImportDefaultSpecifierLocal as u16,
    ImportNamespaceSpecifierLocal(ImportNamespaceSpecifierWithoutLocal<'a, 't>) =
        AncestorType::ImportNamespaceSpecifierLocal as u16,
    WithClauseAttributesKeyword(WithClauseWithoutAttributesKeyword<'a, 't>) =
        AncestorType::WithClauseAttributesKeyword as u16,
    WithClauseWithEntries(WithClauseWithoutWithEntries<'a, 't>) =
        AncestorType::WithClauseWithEntries as u16,
    ImportAttributeKey(ImportAttributeWithoutKey<'a, 't>) = AncestorType::ImportAttributeKey as u16,
    ImportAttributeValue(ImportAttributeWithoutValue<'a, 't>) =
        AncestorType::ImportAttributeValue as u16,
    ExportNamedDeclarationDeclaration(ExportNamedDeclarationWithoutDeclaration<'a, 't>) =
        AncestorType::ExportNamedDeclarationDeclaration as u16,
    ExportNamedDeclarationSpecifiers(ExportNamedDeclarationWithoutSpecifiers<'a, 't>) =
        AncestorType::ExportNamedDeclarationSpecifiers as u16,
    ExportNamedDeclarationSource(ExportNamedDeclarationWithoutSource<'a, 't>) =
        AncestorType::ExportNamedDeclarationSource as u16,
    ExportNamedDeclarationWithClause(ExportNamedDeclarationWithoutWithClause<'a, 't>) =
        AncestorType::ExportNamedDeclarationWithClause as u16,
    ExportDefaultDeclarationDeclaration(ExportDefaultDeclarationWithoutDeclaration<'a, 't>) =
        AncestorType::ExportDefaultDeclarationDeclaration as u16,
    ExportDefaultDeclarationExported(ExportDefaultDeclarationWithoutExported<'a, 't>) =
        AncestorType::ExportDefaultDeclarationExported as u16,
    ExportAllDeclarationExported(ExportAllDeclarationWithoutExported<'a, 't>) =
        AncestorType::ExportAllDeclarationExported as u16,
    ExportAllDeclarationSource(ExportAllDeclarationWithoutSource<'a, 't>) =
        AncestorType::ExportAllDeclarationSource as u16,
    ExportAllDeclarationWithClause(ExportAllDeclarationWithoutWithClause<'a, 't>) =
        AncestorType::ExportAllDeclarationWithClause as u16,
    ExportSpecifierLocal(ExportSpecifierWithoutLocal<'a, 't>) =
        AncestorType::ExportSpecifierLocal as u16,
    ExportSpecifierExported(ExportSpecifierWithoutExported<'a, 't>) =
        AncestorType::ExportSpecifierExported as u16,
    JSXElementOpeningElement(JSXElementWithoutOpeningElement<'a, 't>) =
        AncestorType::JSXElementOpeningElement as u16,
    JSXElementClosingElement(JSXElementWithoutClosingElement<'a, 't>) =
        AncestorType::JSXElementClosingElement as u16,
    JSXElementChildren(JSXElementWithoutChildren<'a, 't>) = AncestorType::JSXElementChildren as u16,
    JSXOpeningElementName(JSXOpeningElementWithoutName<'a, 't>) =
        AncestorType::JSXOpeningElementName as u16,
    JSXOpeningElementAttributes(JSXOpeningElementWithoutAttributes<'a, 't>) =
        AncestorType::JSXOpeningElementAttributes as u16,
    JSXOpeningElementTypeParameters(JSXOpeningElementWithoutTypeParameters<'a, 't>) =
        AncestorType::JSXOpeningElementTypeParameters as u16,
    JSXClosingElementName(JSXClosingElementWithoutName<'a, 't>) =
        AncestorType::JSXClosingElementName as u16,
    JSXFragmentChildren(JSXFragmentWithoutChildren<'a, 't>) =
        AncestorType::JSXFragmentChildren as u16,
    JSXNamespacedNameNamespace(JSXNamespacedNameWithoutNamespace<'a, 't>) =
        AncestorType::JSXNamespacedNameNamespace as u16,
    JSXNamespacedNameProperty(JSXNamespacedNameWithoutProperty<'a, 't>) =
        AncestorType::JSXNamespacedNameProperty as u16,
    JSXMemberExpressionObject(JSXMemberExpressionWithoutObject<'a, 't>) =
        AncestorType::JSXMemberExpressionObject as u16,
    JSXMemberExpressionProperty(JSXMemberExpressionWithoutProperty<'a, 't>) =
        AncestorType::JSXMemberExpressionProperty as u16,
    JSXExpressionContainerExpression(JSXExpressionContainerWithoutExpression<'a, 't>) =
        AncestorType::JSXExpressionContainerExpression as u16,
    JSXAttributeName(JSXAttributeWithoutName<'a, 't>) = AncestorType::JSXAttributeName as u16,
    JSXAttributeValue(JSXAttributeWithoutValue<'a, 't>) = AncestorType::JSXAttributeValue as u16,
    JSXSpreadAttributeArgument(JSXSpreadAttributeWithoutArgument<'a, 't>) =
        AncestorType::JSXSpreadAttributeArgument as u16,
    JSXSpreadChildExpression(JSXSpreadChildWithoutExpression<'a, 't>) =
        AncestorType::JSXSpreadChildExpression as u16,
    TSThisParameterTypeAnnotation(TSThisParameterWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSThisParameterTypeAnnotation as u16,
    TSEnumDeclarationId(TSEnumDeclarationWithoutId<'a, 't>) =
        AncestorType::TSEnumDeclarationId as u16,
    TSEnumDeclarationMembers(TSEnumDeclarationWithoutMembers<'a, 't>) =
        AncestorType::TSEnumDeclarationMembers as u16,
    TSEnumMemberId(TSEnumMemberWithoutId<'a, 't>) = AncestorType::TSEnumMemberId as u16,
    TSEnumMemberInitializer(TSEnumMemberWithoutInitializer<'a, 't>) =
        AncestorType::TSEnumMemberInitializer as u16,
    TSTypeAnnotationTypeAnnotation(TSTypeAnnotationWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSTypeAnnotationTypeAnnotation as u16,
    TSLiteralTypeLiteral(TSLiteralTypeWithoutLiteral<'a, 't>) =
        AncestorType::TSLiteralTypeLiteral as u16,
    TSConditionalTypeCheckType(TSConditionalTypeWithoutCheckType<'a, 't>) =
        AncestorType::TSConditionalTypeCheckType as u16,
    TSConditionalTypeExtendsType(TSConditionalTypeWithoutExtendsType<'a, 't>) =
        AncestorType::TSConditionalTypeExtendsType as u16,
    TSConditionalTypeTrueType(TSConditionalTypeWithoutTrueType<'a, 't>) =
        AncestorType::TSConditionalTypeTrueType as u16,
    TSConditionalTypeFalseType(TSConditionalTypeWithoutFalseType<'a, 't>) =
        AncestorType::TSConditionalTypeFalseType as u16,
    TSUnionTypeTypes(TSUnionTypeWithoutTypes<'a, 't>) = AncestorType::TSUnionTypeTypes as u16,
    TSIntersectionTypeTypes(TSIntersectionTypeWithoutTypes<'a, 't>) =
        AncestorType::TSIntersectionTypeTypes as u16,
    TSParenthesizedTypeTypeAnnotation(TSParenthesizedTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSParenthesizedTypeTypeAnnotation as u16,
    TSTypeOperatorTypeAnnotation(TSTypeOperatorWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSTypeOperatorTypeAnnotation as u16,
    TSArrayTypeElementType(TSArrayTypeWithoutElementType<'a, 't>) =
        AncestorType::TSArrayTypeElementType as u16,
    TSIndexedAccessTypeObjectType(TSIndexedAccessTypeWithoutObjectType<'a, 't>) =
        AncestorType::TSIndexedAccessTypeObjectType as u16,
    TSIndexedAccessTypeIndexType(TSIndexedAccessTypeWithoutIndexType<'a, 't>) =
        AncestorType::TSIndexedAccessTypeIndexType as u16,
    TSTupleTypeElementTypes(TSTupleTypeWithoutElementTypes<'a, 't>) =
        AncestorType::TSTupleTypeElementTypes as u16,
    TSNamedTupleMemberElementType(TSNamedTupleMemberWithoutElementType<'a, 't>) =
        AncestorType::TSNamedTupleMemberElementType as u16,
    TSNamedTupleMemberLabel(TSNamedTupleMemberWithoutLabel<'a, 't>) =
        AncestorType::TSNamedTupleMemberLabel as u16,
    TSOptionalTypeTypeAnnotation(TSOptionalTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSOptionalTypeTypeAnnotation as u16,
    TSRestTypeTypeAnnotation(TSRestTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSRestTypeTypeAnnotation as u16,
    TSTypeReferenceTypeName(TSTypeReferenceWithoutTypeName<'a, 't>) =
        AncestorType::TSTypeReferenceTypeName as u16,
    TSTypeReferenceTypeParameters(TSTypeReferenceWithoutTypeParameters<'a, 't>) =
        AncestorType::TSTypeReferenceTypeParameters as u16,
    TSQualifiedNameLeft(TSQualifiedNameWithoutLeft<'a, 't>) =
        AncestorType::TSQualifiedNameLeft as u16,
    TSQualifiedNameRight(TSQualifiedNameWithoutRight<'a, 't>) =
        AncestorType::TSQualifiedNameRight as u16,
    TSTypeParameterInstantiationParams(TSTypeParameterInstantiationWithoutParams<'a, 't>) =
        AncestorType::TSTypeParameterInstantiationParams as u16,
    TSTypeParameterName(TSTypeParameterWithoutName<'a, 't>) =
        AncestorType::TSTypeParameterName as u16,
    TSTypeParameterConstraint(TSTypeParameterWithoutConstraint<'a, 't>) =
        AncestorType::TSTypeParameterConstraint as u16,
    TSTypeParameterDefault(TSTypeParameterWithoutDefault<'a, 't>) =
        AncestorType::TSTypeParameterDefault as u16,
    TSTypeParameterDeclarationParams(TSTypeParameterDeclarationWithoutParams<'a, 't>) =
        AncestorType::TSTypeParameterDeclarationParams as u16,
    TSTypeAliasDeclarationId(TSTypeAliasDeclarationWithoutId<'a, 't>) =
        AncestorType::TSTypeAliasDeclarationId as u16,
    TSTypeAliasDeclarationTypeParameters(TSTypeAliasDeclarationWithoutTypeParameters<'a, 't>) =
        AncestorType::TSTypeAliasDeclarationTypeParameters as u16,
    TSTypeAliasDeclarationTypeAnnotation(TSTypeAliasDeclarationWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSTypeAliasDeclarationTypeAnnotation as u16,
    TSClassImplementsExpression(TSClassImplementsWithoutExpression<'a, 't>) =
        AncestorType::TSClassImplementsExpression as u16,
    TSClassImplementsTypeParameters(TSClassImplementsWithoutTypeParameters<'a, 't>) =
        AncestorType::TSClassImplementsTypeParameters as u16,
    TSInterfaceDeclarationId(TSInterfaceDeclarationWithoutId<'a, 't>) =
        AncestorType::TSInterfaceDeclarationId as u16,
    TSInterfaceDeclarationExtends(TSInterfaceDeclarationWithoutExtends<'a, 't>) =
        AncestorType::TSInterfaceDeclarationExtends as u16,
    TSInterfaceDeclarationTypeParameters(TSInterfaceDeclarationWithoutTypeParameters<'a, 't>) =
        AncestorType::TSInterfaceDeclarationTypeParameters as u16,
    TSInterfaceDeclarationBody(TSInterfaceDeclarationWithoutBody<'a, 't>) =
        AncestorType::TSInterfaceDeclarationBody as u16,
    TSInterfaceBodyBody(TSInterfaceBodyWithoutBody<'a, 't>) =
        AncestorType::TSInterfaceBodyBody as u16,
    TSPropertySignatureKey(TSPropertySignatureWithoutKey<'a, 't>) =
        AncestorType::TSPropertySignatureKey as u16,
    TSPropertySignatureTypeAnnotation(TSPropertySignatureWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSPropertySignatureTypeAnnotation as u16,
    TSIndexSignatureParameters(TSIndexSignatureWithoutParameters<'a, 't>) =
        AncestorType::TSIndexSignatureParameters as u16,
    TSIndexSignatureTypeAnnotation(TSIndexSignatureWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSIndexSignatureTypeAnnotation as u16,
    TSCallSignatureDeclarationTypeParameters(
        TSCallSignatureDeclarationWithoutTypeParameters<'a, 't>,
    ) = AncestorType::TSCallSignatureDeclarationTypeParameters as u16,
    TSCallSignatureDeclarationThisParam(TSCallSignatureDeclarationWithoutThisParam<'a, 't>) =
        AncestorType::TSCallSignatureDeclarationThisParam as u16,
    TSCallSignatureDeclarationParams(TSCallSignatureDeclarationWithoutParams<'a, 't>) =
        AncestorType::TSCallSignatureDeclarationParams as u16,
    TSCallSignatureDeclarationReturnType(TSCallSignatureDeclarationWithoutReturnType<'a, 't>) =
        AncestorType::TSCallSignatureDeclarationReturnType as u16,
    TSMethodSignatureKey(TSMethodSignatureWithoutKey<'a, 't>) =
        AncestorType::TSMethodSignatureKey as u16,
    TSMethodSignatureTypeParameters(TSMethodSignatureWithoutTypeParameters<'a, 't>) =
        AncestorType::TSMethodSignatureTypeParameters as u16,
    TSMethodSignatureThisParam(TSMethodSignatureWithoutThisParam<'a, 't>) =
        AncestorType::TSMethodSignatureThisParam as u16,
    TSMethodSignatureParams(TSMethodSignatureWithoutParams<'a, 't>) =
        AncestorType::TSMethodSignatureParams as u16,
    TSMethodSignatureReturnType(TSMethodSignatureWithoutReturnType<'a, 't>) =
        AncestorType::TSMethodSignatureReturnType as u16,
    TSConstructSignatureDeclarationTypeParameters(
        TSConstructSignatureDeclarationWithoutTypeParameters<'a, 't>,
    ) = AncestorType::TSConstructSignatureDeclarationTypeParameters as u16,
    TSConstructSignatureDeclarationParams(TSConstructSignatureDeclarationWithoutParams<'a, 't>) =
        AncestorType::TSConstructSignatureDeclarationParams as u16,
    TSConstructSignatureDeclarationReturnType(
        TSConstructSignatureDeclarationWithoutReturnType<'a, 't>,
    ) = AncestorType::TSConstructSignatureDeclarationReturnType as u16,
    TSIndexSignatureNameTypeAnnotation(TSIndexSignatureNameWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSIndexSignatureNameTypeAnnotation as u16,
    TSInterfaceHeritageExpression(TSInterfaceHeritageWithoutExpression<'a, 't>) =
        AncestorType::TSInterfaceHeritageExpression as u16,
    TSInterfaceHeritageTypeParameters(TSInterfaceHeritageWithoutTypeParameters<'a, 't>) =
        AncestorType::TSInterfaceHeritageTypeParameters as u16,
    TSTypePredicateParameterName(TSTypePredicateWithoutParameterName<'a, 't>) =
        AncestorType::TSTypePredicateParameterName as u16,
    TSTypePredicateTypeAnnotation(TSTypePredicateWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSTypePredicateTypeAnnotation as u16,
    TSModuleDeclarationId(TSModuleDeclarationWithoutId<'a, 't>) =
        AncestorType::TSModuleDeclarationId as u16,
    TSModuleDeclarationBody(TSModuleDeclarationWithoutBody<'a, 't>) =
        AncestorType::TSModuleDeclarationBody as u16,
    TSModuleBlockDirectives(TSModuleBlockWithoutDirectives<'a, 't>) =
        AncestorType::TSModuleBlockDirectives as u16,
    TSModuleBlockBody(TSModuleBlockWithoutBody<'a, 't>) = AncestorType::TSModuleBlockBody as u16,
    TSTypeLiteralMembers(TSTypeLiteralWithoutMembers<'a, 't>) =
        AncestorType::TSTypeLiteralMembers as u16,
    TSInferTypeTypeParameter(TSInferTypeWithoutTypeParameter<'a, 't>) =
        AncestorType::TSInferTypeTypeParameter as u16,
    TSTypeQueryExprName(TSTypeQueryWithoutExprName<'a, 't>) =
        AncestorType::TSTypeQueryExprName as u16,
    TSTypeQueryTypeParameters(TSTypeQueryWithoutTypeParameters<'a, 't>) =
        AncestorType::TSTypeQueryTypeParameters as u16,
    TSImportTypeParameter(TSImportTypeWithoutParameter<'a, 't>) =
        AncestorType::TSImportTypeParameter as u16,
    TSImportTypeQualifier(TSImportTypeWithoutQualifier<'a, 't>) =
        AncestorType::TSImportTypeQualifier as u16,
    TSImportTypeAttributes(TSImportTypeWithoutAttributes<'a, 't>) =
        AncestorType::TSImportTypeAttributes as u16,
    TSImportTypeTypeParameters(TSImportTypeWithoutTypeParameters<'a, 't>) =
        AncestorType::TSImportTypeTypeParameters as u16,
    TSImportAttributesAttributesKeyword(TSImportAttributesWithoutAttributesKeyword<'a, 't>) =
        AncestorType::TSImportAttributesAttributesKeyword as u16,
    TSImportAttributesElements(TSImportAttributesWithoutElements<'a, 't>) =
        AncestorType::TSImportAttributesElements as u16,
    TSImportAttributeName(TSImportAttributeWithoutName<'a, 't>) =
        AncestorType::TSImportAttributeName as u16,
    TSImportAttributeValue(TSImportAttributeWithoutValue<'a, 't>) =
        AncestorType::TSImportAttributeValue as u16,
    TSFunctionTypeTypeParameters(TSFunctionTypeWithoutTypeParameters<'a, 't>) =
        AncestorType::TSFunctionTypeTypeParameters as u16,
    TSFunctionTypeThisParam(TSFunctionTypeWithoutThisParam<'a, 't>) =
        AncestorType::TSFunctionTypeThisParam as u16,
    TSFunctionTypeParams(TSFunctionTypeWithoutParams<'a, 't>) =
        AncestorType::TSFunctionTypeParams as u16,
    TSFunctionTypeReturnType(TSFunctionTypeWithoutReturnType<'a, 't>) =
        AncestorType::TSFunctionTypeReturnType as u16,
    TSConstructorTypeTypeParameters(TSConstructorTypeWithoutTypeParameters<'a, 't>) =
        AncestorType::TSConstructorTypeTypeParameters as u16,
    TSConstructorTypeParams(TSConstructorTypeWithoutParams<'a, 't>) =
        AncestorType::TSConstructorTypeParams as u16,
    TSConstructorTypeReturnType(TSConstructorTypeWithoutReturnType<'a, 't>) =
        AncestorType::TSConstructorTypeReturnType as u16,
    TSMappedTypeTypeParameter(TSMappedTypeWithoutTypeParameter<'a, 't>) =
        AncestorType::TSMappedTypeTypeParameter as u16,
    TSMappedTypeNameType(TSMappedTypeWithoutNameType<'a, 't>) =
        AncestorType::TSMappedTypeNameType as u16,
    TSMappedTypeTypeAnnotation(TSMappedTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSMappedTypeTypeAnnotation as u16,
    TSTemplateLiteralTypeQuasis(TSTemplateLiteralTypeWithoutQuasis<'a, 't>) =
        AncestorType::TSTemplateLiteralTypeQuasis as u16,
    TSTemplateLiteralTypeTypes(TSTemplateLiteralTypeWithoutTypes<'a, 't>) =
        AncestorType::TSTemplateLiteralTypeTypes as u16,
    TSAsExpressionExpression(TSAsExpressionWithoutExpression<'a, 't>) =
        AncestorType::TSAsExpressionExpression as u16,
    TSAsExpressionTypeAnnotation(TSAsExpressionWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSAsExpressionTypeAnnotation as u16,
    TSSatisfiesExpressionExpression(TSSatisfiesExpressionWithoutExpression<'a, 't>) =
        AncestorType::TSSatisfiesExpressionExpression as u16,
    TSSatisfiesExpressionTypeAnnotation(TSSatisfiesExpressionWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSSatisfiesExpressionTypeAnnotation as u16,
    TSTypeAssertionExpression(TSTypeAssertionWithoutExpression<'a, 't>) =
        AncestorType::TSTypeAssertionExpression as u16,
    TSTypeAssertionTypeAnnotation(TSTypeAssertionWithoutTypeAnnotation<'a, 't>) =
        AncestorType::TSTypeAssertionTypeAnnotation as u16,
    TSImportEqualsDeclarationId(TSImportEqualsDeclarationWithoutId<'a, 't>) =
        AncestorType::TSImportEqualsDeclarationId as u16,
    TSImportEqualsDeclarationModuleReference(
        TSImportEqualsDeclarationWithoutModuleReference<'a, 't>,
    ) = AncestorType::TSImportEqualsDeclarationModuleReference as u16,
    TSExternalModuleReferenceExpression(TSExternalModuleReferenceWithoutExpression<'a, 't>) =
        AncestorType::TSExternalModuleReferenceExpression as u16,
    TSNonNullExpressionExpression(TSNonNullExpressionWithoutExpression<'a, 't>) =
        AncestorType::TSNonNullExpressionExpression as u16,
    DecoratorExpression(DecoratorWithoutExpression<'a, 't>) =
        AncestorType::DecoratorExpression as u16,
    TSExportAssignmentExpression(TSExportAssignmentWithoutExpression<'a, 't>) =
        AncestorType::TSExportAssignmentExpression as u16,
    TSNamespaceExportDeclarationId(TSNamespaceExportDeclarationWithoutId<'a, 't>) =
        AncestorType::TSNamespaceExportDeclarationId as u16,
    TSInstantiationExpressionExpression(TSInstantiationExpressionWithoutExpression<'a, 't>) =
        AncestorType::TSInstantiationExpressionExpression as u16,
    TSInstantiationExpressionTypeParameters(TSInstantiationExpressionWithoutTypeParameters<'a, 't>) =
        AncestorType::TSInstantiationExpressionTypeParameters as u16,
    JSDocNullableTypeTypeAnnotation(JSDocNullableTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::JSDocNullableTypeTypeAnnotation as u16,
    JSDocNonNullableTypeTypeAnnotation(JSDocNonNullableTypeWithoutTypeAnnotation<'a, 't>) =
        AncestorType::JSDocNonNullableTypeTypeAnnotation as u16,
}

impl<'a, 't> Ancestor<'a, 't> {
    #[inline]
    pub fn is_program(self) -> bool {
        matches!(self, Self::ProgramHashbang(_) | Self::ProgramDirectives(_) | Self::ProgramBody(_))
    }

    #[inline]
    pub fn is_array_expression(self) -> bool {
        matches!(self, Self::ArrayExpressionElements(_))
    }

    #[inline]
    pub fn is_object_expression(self) -> bool {
        matches!(self, Self::ObjectExpressionProperties(_))
    }

    #[inline]
    pub fn is_object_property(self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyKey(_) | Self::ObjectPropertyValue(_) | Self::ObjectPropertyInit(_)
        )
    }

    #[inline]
    pub fn is_template_literal(self) -> bool {
        matches!(self, Self::TemplateLiteralQuasis(_) | Self::TemplateLiteralExpressions(_))
    }

    #[inline]
    pub fn is_tagged_template_expression(self) -> bool {
        matches!(
            self,
            Self::TaggedTemplateExpressionTag(_)
                | Self::TaggedTemplateExpressionQuasi(_)
                | Self::TaggedTemplateExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_computed_member_expression(self) -> bool {
        matches!(
            self,
            Self::ComputedMemberExpressionObject(_) | Self::ComputedMemberExpressionExpression(_)
        )
    }

    #[inline]
    pub fn is_static_member_expression(self) -> bool {
        matches!(
            self,
            Self::StaticMemberExpressionObject(_) | Self::StaticMemberExpressionProperty(_)
        )
    }

    #[inline]
    pub fn is_private_field_expression(self) -> bool {
        matches!(self, Self::PrivateFieldExpressionObject(_) | Self::PrivateFieldExpressionField(_))
    }

    #[inline]
    pub fn is_call_expression(self) -> bool {
        matches!(
            self,
            Self::CallExpressionCallee(_)
                | Self::CallExpressionTypeParameters(_)
                | Self::CallExpressionArguments(_)
        )
    }

    #[inline]
    pub fn is_new_expression(self) -> bool {
        matches!(
            self,
            Self::NewExpressionCallee(_)
                | Self::NewExpressionArguments(_)
                | Self::NewExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_meta_property(self) -> bool {
        matches!(self, Self::MetaPropertyMeta(_) | Self::MetaPropertyProperty(_))
    }

    #[inline]
    pub fn is_spread_element(self) -> bool {
        matches!(self, Self::SpreadElementArgument(_))
    }

    #[inline]
    pub fn is_update_expression(self) -> bool {
        matches!(self, Self::UpdateExpressionArgument(_))
    }

    #[inline]
    pub fn is_unary_expression(self) -> bool {
        matches!(self, Self::UnaryExpressionArgument(_))
    }

    #[inline]
    pub fn is_binary_expression(self) -> bool {
        matches!(self, Self::BinaryExpressionLeft(_) | Self::BinaryExpressionRight(_))
    }

    #[inline]
    pub fn is_private_in_expression(self) -> bool {
        matches!(self, Self::PrivateInExpressionLeft(_) | Self::PrivateInExpressionRight(_))
    }

    #[inline]
    pub fn is_logical_expression(self) -> bool {
        matches!(self, Self::LogicalExpressionLeft(_) | Self::LogicalExpressionRight(_))
    }

    #[inline]
    pub fn is_conditional_expression(self) -> bool {
        matches!(
            self,
            Self::ConditionalExpressionTest(_)
                | Self::ConditionalExpressionConsequent(_)
                | Self::ConditionalExpressionAlternate(_)
        )
    }

    #[inline]
    pub fn is_assignment_expression(self) -> bool {
        matches!(self, Self::AssignmentExpressionLeft(_) | Self::AssignmentExpressionRight(_))
    }

    #[inline]
    pub fn is_array_assignment_target(self) -> bool {
        matches!(self, Self::ArrayAssignmentTargetElements(_) | Self::ArrayAssignmentTargetRest(_))
    }

    #[inline]
    pub fn is_object_assignment_target(self) -> bool {
        matches!(
            self,
            Self::ObjectAssignmentTargetProperties(_) | Self::ObjectAssignmentTargetRest(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_rest(self) -> bool {
        matches!(self, Self::AssignmentTargetRestTarget(_))
    }

    #[inline]
    pub fn is_assignment_target_with_default(self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetWithDefaultBinding(_) | Self::AssignmentTargetWithDefaultInit(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_property_identifier(self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetPropertyIdentifierBinding(_)
                | Self::AssignmentTargetPropertyIdentifierInit(_)
        )
    }

    #[inline]
    pub fn is_assignment_target_property_property(self) -> bool {
        matches!(
            self,
            Self::AssignmentTargetPropertyPropertyName(_)
                | Self::AssignmentTargetPropertyPropertyBinding(_)
        )
    }

    #[inline]
    pub fn is_sequence_expression(self) -> bool {
        matches!(self, Self::SequenceExpressionExpressions(_))
    }

    #[inline]
    pub fn is_await_expression(self) -> bool {
        matches!(self, Self::AwaitExpressionArgument(_))
    }

    #[inline]
    pub fn is_chain_expression(self) -> bool {
        matches!(self, Self::ChainExpressionExpression(_))
    }

    #[inline]
    pub fn is_parenthesized_expression(self) -> bool {
        matches!(self, Self::ParenthesizedExpressionExpression(_))
    }

    #[inline]
    pub fn is_directive(self) -> bool {
        matches!(self, Self::DirectiveExpression(_))
    }

    #[inline]
    pub fn is_block_statement(self) -> bool {
        matches!(self, Self::BlockStatementBody(_))
    }

    #[inline]
    pub fn is_variable_declaration(self) -> bool {
        matches!(self, Self::VariableDeclarationDeclarations(_))
    }

    #[inline]
    pub fn is_variable_declarator(self) -> bool {
        matches!(self, Self::VariableDeclaratorId(_) | Self::VariableDeclaratorInit(_))
    }

    #[inline]
    pub fn is_expression_statement(self) -> bool {
        matches!(self, Self::ExpressionStatementExpression(_))
    }

    #[inline]
    pub fn is_if_statement(self) -> bool {
        matches!(
            self,
            Self::IfStatementTest(_)
                | Self::IfStatementConsequent(_)
                | Self::IfStatementAlternate(_)
        )
    }

    #[inline]
    pub fn is_do_while_statement(self) -> bool {
        matches!(self, Self::DoWhileStatementBody(_) | Self::DoWhileStatementTest(_))
    }

    #[inline]
    pub fn is_while_statement(self) -> bool {
        matches!(self, Self::WhileStatementTest(_) | Self::WhileStatementBody(_))
    }

    #[inline]
    pub fn is_for_statement(self) -> bool {
        matches!(
            self,
            Self::ForStatementInit(_)
                | Self::ForStatementTest(_)
                | Self::ForStatementUpdate(_)
                | Self::ForStatementBody(_)
        )
    }

    #[inline]
    pub fn is_for_in_statement(self) -> bool {
        matches!(
            self,
            Self::ForInStatementLeft(_)
                | Self::ForInStatementRight(_)
                | Self::ForInStatementBody(_)
        )
    }

    #[inline]
    pub fn is_for_of_statement(self) -> bool {
        matches!(
            self,
            Self::ForOfStatementLeft(_)
                | Self::ForOfStatementRight(_)
                | Self::ForOfStatementBody(_)
        )
    }

    #[inline]
    pub fn is_continue_statement(self) -> bool {
        matches!(self, Self::ContinueStatementLabel(_))
    }

    #[inline]
    pub fn is_break_statement(self) -> bool {
        matches!(self, Self::BreakStatementLabel(_))
    }

    #[inline]
    pub fn is_return_statement(self) -> bool {
        matches!(self, Self::ReturnStatementArgument(_))
    }

    #[inline]
    pub fn is_with_statement(self) -> bool {
        matches!(self, Self::WithStatementObject(_) | Self::WithStatementBody(_))
    }

    #[inline]
    pub fn is_switch_statement(self) -> bool {
        matches!(self, Self::SwitchStatementDiscriminant(_) | Self::SwitchStatementCases(_))
    }

    #[inline]
    pub fn is_switch_case(self) -> bool {
        matches!(self, Self::SwitchCaseTest(_) | Self::SwitchCaseConsequent(_))
    }

    #[inline]
    pub fn is_labeled_statement(self) -> bool {
        matches!(self, Self::LabeledStatementLabel(_) | Self::LabeledStatementBody(_))
    }

    #[inline]
    pub fn is_throw_statement(self) -> bool {
        matches!(self, Self::ThrowStatementArgument(_))
    }

    #[inline]
    pub fn is_try_statement(self) -> bool {
        matches!(
            self,
            Self::TryStatementBlock(_)
                | Self::TryStatementHandler(_)
                | Self::TryStatementFinalizer(_)
        )
    }

    #[inline]
    pub fn is_catch_clause(self) -> bool {
        matches!(self, Self::CatchClauseParam(_) | Self::CatchClauseBody(_))
    }

    #[inline]
    pub fn is_catch_parameter(self) -> bool {
        matches!(self, Self::CatchParameterPattern(_))
    }

    #[inline]
    pub fn is_binding_pattern(self) -> bool {
        matches!(self, Self::BindingPatternKind(_) | Self::BindingPatternTypeAnnotation(_))
    }

    #[inline]
    pub fn is_assignment_pattern(self) -> bool {
        matches!(self, Self::AssignmentPatternLeft(_) | Self::AssignmentPatternRight(_))
    }

    #[inline]
    pub fn is_object_pattern(self) -> bool {
        matches!(self, Self::ObjectPatternProperties(_) | Self::ObjectPatternRest(_))
    }

    #[inline]
    pub fn is_binding_property(self) -> bool {
        matches!(self, Self::BindingPropertyKey(_) | Self::BindingPropertyValue(_))
    }

    #[inline]
    pub fn is_array_pattern(self) -> bool {
        matches!(self, Self::ArrayPatternElements(_) | Self::ArrayPatternRest(_))
    }

    #[inline]
    pub fn is_binding_rest_element(self) -> bool {
        matches!(self, Self::BindingRestElementArgument(_))
    }

    #[inline]
    pub fn is_function(self) -> bool {
        matches!(
            self,
            Self::FunctionId(_)
                | Self::FunctionTypeParameters(_)
                | Self::FunctionThisParam(_)
                | Self::FunctionParams(_)
                | Self::FunctionReturnType(_)
                | Self::FunctionBody(_)
        )
    }

    #[inline]
    pub fn is_formal_parameters(self) -> bool {
        matches!(self, Self::FormalParametersItems(_) | Self::FormalParametersRest(_))
    }

    #[inline]
    pub fn is_formal_parameter(self) -> bool {
        matches!(self, Self::FormalParameterDecorators(_) | Self::FormalParameterPattern(_))
    }

    #[inline]
    pub fn is_function_body(self) -> bool {
        matches!(self, Self::FunctionBodyDirectives(_) | Self::FunctionBodyStatements(_))
    }

    #[inline]
    pub fn is_arrow_function_expression(self) -> bool {
        matches!(
            self,
            Self::ArrowFunctionExpressionTypeParameters(_)
                | Self::ArrowFunctionExpressionParams(_)
                | Self::ArrowFunctionExpressionReturnType(_)
                | Self::ArrowFunctionExpressionBody(_)
        )
    }

    #[inline]
    pub fn is_yield_expression(self) -> bool {
        matches!(self, Self::YieldExpressionArgument(_))
    }

    #[inline]
    pub fn is_class(self) -> bool {
        matches!(
            self,
            Self::ClassDecorators(_)
                | Self::ClassId(_)
                | Self::ClassTypeParameters(_)
                | Self::ClassSuperClass(_)
                | Self::ClassSuperTypeParameters(_)
                | Self::ClassImplements(_)
                | Self::ClassBody(_)
        )
    }

    #[inline]
    pub fn is_class_body(self) -> bool {
        matches!(self, Self::ClassBodyBody(_))
    }

    #[inline]
    pub fn is_method_definition(self) -> bool {
        matches!(
            self,
            Self::MethodDefinitionDecorators(_)
                | Self::MethodDefinitionKey(_)
                | Self::MethodDefinitionValue(_)
        )
    }

    #[inline]
    pub fn is_property_definition(self) -> bool {
        matches!(
            self,
            Self::PropertyDefinitionDecorators(_)
                | Self::PropertyDefinitionKey(_)
                | Self::PropertyDefinitionValue(_)
                | Self::PropertyDefinitionTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_static_block(self) -> bool {
        matches!(self, Self::StaticBlockBody(_))
    }

    #[inline]
    pub fn is_accessor_property(self) -> bool {
        matches!(
            self,
            Self::AccessorPropertyDecorators(_)
                | Self::AccessorPropertyKey(_)
                | Self::AccessorPropertyValue(_)
                | Self::AccessorPropertyTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_import_expression(self) -> bool {
        matches!(self, Self::ImportExpressionSource(_) | Self::ImportExpressionArguments(_))
    }

    #[inline]
    pub fn is_import_declaration(self) -> bool {
        matches!(
            self,
            Self::ImportDeclarationSpecifiers(_)
                | Self::ImportDeclarationSource(_)
                | Self::ImportDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_import_specifier(self) -> bool {
        matches!(self, Self::ImportSpecifierImported(_) | Self::ImportSpecifierLocal(_))
    }

    #[inline]
    pub fn is_import_default_specifier(self) -> bool {
        matches!(self, Self::ImportDefaultSpecifierLocal(_))
    }

    #[inline]
    pub fn is_import_namespace_specifier(self) -> bool {
        matches!(self, Self::ImportNamespaceSpecifierLocal(_))
    }

    #[inline]
    pub fn is_with_clause(self) -> bool {
        matches!(self, Self::WithClauseAttributesKeyword(_) | Self::WithClauseWithEntries(_))
    }

    #[inline]
    pub fn is_import_attribute(self) -> bool {
        matches!(self, Self::ImportAttributeKey(_) | Self::ImportAttributeValue(_))
    }

    #[inline]
    pub fn is_export_named_declaration(self) -> bool {
        matches!(
            self,
            Self::ExportNamedDeclarationDeclaration(_)
                | Self::ExportNamedDeclarationSpecifiers(_)
                | Self::ExportNamedDeclarationSource(_)
                | Self::ExportNamedDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_export_default_declaration(self) -> bool {
        matches!(
            self,
            Self::ExportDefaultDeclarationDeclaration(_)
                | Self::ExportDefaultDeclarationExported(_)
        )
    }

    #[inline]
    pub fn is_export_all_declaration(self) -> bool {
        matches!(
            self,
            Self::ExportAllDeclarationExported(_)
                | Self::ExportAllDeclarationSource(_)
                | Self::ExportAllDeclarationWithClause(_)
        )
    }

    #[inline]
    pub fn is_export_specifier(self) -> bool {
        matches!(self, Self::ExportSpecifierLocal(_) | Self::ExportSpecifierExported(_))
    }

    #[inline]
    pub fn is_jsx_element(self) -> bool {
        matches!(
            self,
            Self::JSXElementOpeningElement(_)
                | Self::JSXElementClosingElement(_)
                | Self::JSXElementChildren(_)
        )
    }

    #[inline]
    pub fn is_jsx_opening_element(self) -> bool {
        matches!(
            self,
            Self::JSXOpeningElementName(_)
                | Self::JSXOpeningElementAttributes(_)
                | Self::JSXOpeningElementTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_jsx_closing_element(self) -> bool {
        matches!(self, Self::JSXClosingElementName(_))
    }

    #[inline]
    pub fn is_jsx_fragment(self) -> bool {
        matches!(self, Self::JSXFragmentChildren(_))
    }

    #[inline]
    pub fn is_jsx_namespaced_name(self) -> bool {
        matches!(self, Self::JSXNamespacedNameNamespace(_) | Self::JSXNamespacedNameProperty(_))
    }

    #[inline]
    pub fn is_jsx_member_expression(self) -> bool {
        matches!(self, Self::JSXMemberExpressionObject(_) | Self::JSXMemberExpressionProperty(_))
    }

    #[inline]
    pub fn is_jsx_expression_container(self) -> bool {
        matches!(self, Self::JSXExpressionContainerExpression(_))
    }

    #[inline]
    pub fn is_jsx_attribute(self) -> bool {
        matches!(self, Self::JSXAttributeName(_) | Self::JSXAttributeValue(_))
    }

    #[inline]
    pub fn is_jsx_spread_attribute(self) -> bool {
        matches!(self, Self::JSXSpreadAttributeArgument(_))
    }

    #[inline]
    pub fn is_jsx_spread_child(self) -> bool {
        matches!(self, Self::JSXSpreadChildExpression(_))
    }

    #[inline]
    pub fn is_ts_this_parameter(self) -> bool {
        matches!(self, Self::TSThisParameterTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_enum_declaration(self) -> bool {
        matches!(self, Self::TSEnumDeclarationId(_) | Self::TSEnumDeclarationMembers(_))
    }

    #[inline]
    pub fn is_ts_enum_member(self) -> bool {
        matches!(self, Self::TSEnumMemberId(_) | Self::TSEnumMemberInitializer(_))
    }

    #[inline]
    pub fn is_ts_type_annotation(self) -> bool {
        matches!(self, Self::TSTypeAnnotationTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_literal_type(self) -> bool {
        matches!(self, Self::TSLiteralTypeLiteral(_))
    }

    #[inline]
    pub fn is_ts_conditional_type(self) -> bool {
        matches!(
            self,
            Self::TSConditionalTypeCheckType(_)
                | Self::TSConditionalTypeExtendsType(_)
                | Self::TSConditionalTypeTrueType(_)
                | Self::TSConditionalTypeFalseType(_)
        )
    }

    #[inline]
    pub fn is_ts_union_type(self) -> bool {
        matches!(self, Self::TSUnionTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_intersection_type(self) -> bool {
        matches!(self, Self::TSIntersectionTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_parenthesized_type(self) -> bool {
        matches!(self, Self::TSParenthesizedTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_type_operator(self) -> bool {
        matches!(self, Self::TSTypeOperatorTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_array_type(self) -> bool {
        matches!(self, Self::TSArrayTypeElementType(_))
    }

    #[inline]
    pub fn is_ts_indexed_access_type(self) -> bool {
        matches!(
            self,
            Self::TSIndexedAccessTypeObjectType(_) | Self::TSIndexedAccessTypeIndexType(_)
        )
    }

    #[inline]
    pub fn is_ts_tuple_type(self) -> bool {
        matches!(self, Self::TSTupleTypeElementTypes(_))
    }

    #[inline]
    pub fn is_ts_named_tuple_member(self) -> bool {
        matches!(self, Self::TSNamedTupleMemberElementType(_) | Self::TSNamedTupleMemberLabel(_))
    }

    #[inline]
    pub fn is_ts_optional_type(self) -> bool {
        matches!(self, Self::TSOptionalTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_rest_type(self) -> bool {
        matches!(self, Self::TSRestTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_type_reference(self) -> bool {
        matches!(self, Self::TSTypeReferenceTypeName(_) | Self::TSTypeReferenceTypeParameters(_))
    }

    #[inline]
    pub fn is_ts_qualified_name(self) -> bool {
        matches!(self, Self::TSQualifiedNameLeft(_) | Self::TSQualifiedNameRight(_))
    }

    #[inline]
    pub fn is_ts_type_parameter_instantiation(self) -> bool {
        matches!(self, Self::TSTypeParameterInstantiationParams(_))
    }

    #[inline]
    pub fn is_ts_type_parameter(self) -> bool {
        matches!(
            self,
            Self::TSTypeParameterName(_)
                | Self::TSTypeParameterConstraint(_)
                | Self::TSTypeParameterDefault(_)
        )
    }

    #[inline]
    pub fn is_ts_type_parameter_declaration(self) -> bool {
        matches!(self, Self::TSTypeParameterDeclarationParams(_))
    }

    #[inline]
    pub fn is_ts_type_alias_declaration(self) -> bool {
        matches!(
            self,
            Self::TSTypeAliasDeclarationId(_)
                | Self::TSTypeAliasDeclarationTypeParameters(_)
                | Self::TSTypeAliasDeclarationTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_class_implements(self) -> bool {
        matches!(
            self,
            Self::TSClassImplementsExpression(_) | Self::TSClassImplementsTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_interface_declaration(self) -> bool {
        matches!(
            self,
            Self::TSInterfaceDeclarationId(_)
                | Self::TSInterfaceDeclarationExtends(_)
                | Self::TSInterfaceDeclarationTypeParameters(_)
                | Self::TSInterfaceDeclarationBody(_)
        )
    }

    #[inline]
    pub fn is_ts_interface_body(self) -> bool {
        matches!(self, Self::TSInterfaceBodyBody(_))
    }

    #[inline]
    pub fn is_ts_property_signature(self) -> bool {
        matches!(self, Self::TSPropertySignatureKey(_) | Self::TSPropertySignatureTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_index_signature(self) -> bool {
        matches!(
            self,
            Self::TSIndexSignatureParameters(_) | Self::TSIndexSignatureTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_call_signature_declaration(self) -> bool {
        matches!(
            self,
            Self::TSCallSignatureDeclarationTypeParameters(_)
                | Self::TSCallSignatureDeclarationThisParam(_)
                | Self::TSCallSignatureDeclarationParams(_)
                | Self::TSCallSignatureDeclarationReturnType(_)
        )
    }

    #[inline]
    pub fn is_ts_method_signature(self) -> bool {
        matches!(
            self,
            Self::TSMethodSignatureKey(_)
                | Self::TSMethodSignatureTypeParameters(_)
                | Self::TSMethodSignatureThisParam(_)
                | Self::TSMethodSignatureParams(_)
                | Self::TSMethodSignatureReturnType(_)
        )
    }

    #[inline]
    pub fn is_ts_construct_signature_declaration(self) -> bool {
        matches!(
            self,
            Self::TSConstructSignatureDeclarationTypeParameters(_)
                | Self::TSConstructSignatureDeclarationParams(_)
                | Self::TSConstructSignatureDeclarationReturnType(_)
        )
    }

    #[inline]
    pub fn is_ts_index_signature_name(self) -> bool {
        matches!(self, Self::TSIndexSignatureNameTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_interface_heritage(self) -> bool {
        matches!(
            self,
            Self::TSInterfaceHeritageExpression(_) | Self::TSInterfaceHeritageTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_type_predicate(self) -> bool {
        matches!(
            self,
            Self::TSTypePredicateParameterName(_) | Self::TSTypePredicateTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_module_declaration(self) -> bool {
        matches!(self, Self::TSModuleDeclarationId(_) | Self::TSModuleDeclarationBody(_))
    }

    #[inline]
    pub fn is_ts_module_block(self) -> bool {
        matches!(self, Self::TSModuleBlockDirectives(_) | Self::TSModuleBlockBody(_))
    }

    #[inline]
    pub fn is_ts_type_literal(self) -> bool {
        matches!(self, Self::TSTypeLiteralMembers(_))
    }

    #[inline]
    pub fn is_ts_infer_type(self) -> bool {
        matches!(self, Self::TSInferTypeTypeParameter(_))
    }

    #[inline]
    pub fn is_ts_type_query(self) -> bool {
        matches!(self, Self::TSTypeQueryExprName(_) | Self::TSTypeQueryTypeParameters(_))
    }

    #[inline]
    pub fn is_ts_import_type(self) -> bool {
        matches!(
            self,
            Self::TSImportTypeParameter(_)
                | Self::TSImportTypeQualifier(_)
                | Self::TSImportTypeAttributes(_)
                | Self::TSImportTypeTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_ts_import_attributes(self) -> bool {
        matches!(
            self,
            Self::TSImportAttributesAttributesKeyword(_) | Self::TSImportAttributesElements(_)
        )
    }

    #[inline]
    pub fn is_ts_import_attribute(self) -> bool {
        matches!(self, Self::TSImportAttributeName(_) | Self::TSImportAttributeValue(_))
    }

    #[inline]
    pub fn is_ts_function_type(self) -> bool {
        matches!(
            self,
            Self::TSFunctionTypeTypeParameters(_)
                | Self::TSFunctionTypeThisParam(_)
                | Self::TSFunctionTypeParams(_)
                | Self::TSFunctionTypeReturnType(_)
        )
    }

    #[inline]
    pub fn is_ts_constructor_type(self) -> bool {
        matches!(
            self,
            Self::TSConstructorTypeTypeParameters(_)
                | Self::TSConstructorTypeParams(_)
                | Self::TSConstructorTypeReturnType(_)
        )
    }

    #[inline]
    pub fn is_ts_mapped_type(self) -> bool {
        matches!(
            self,
            Self::TSMappedTypeTypeParameter(_)
                | Self::TSMappedTypeNameType(_)
                | Self::TSMappedTypeTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_template_literal_type(self) -> bool {
        matches!(self, Self::TSTemplateLiteralTypeQuasis(_) | Self::TSTemplateLiteralTypeTypes(_))
    }

    #[inline]
    pub fn is_ts_as_expression(self) -> bool {
        matches!(self, Self::TSAsExpressionExpression(_) | Self::TSAsExpressionTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_satisfies_expression(self) -> bool {
        matches!(
            self,
            Self::TSSatisfiesExpressionExpression(_) | Self::TSSatisfiesExpressionTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_ts_type_assertion(self) -> bool {
        matches!(self, Self::TSTypeAssertionExpression(_) | Self::TSTypeAssertionTypeAnnotation(_))
    }

    #[inline]
    pub fn is_ts_import_equals_declaration(self) -> bool {
        matches!(
            self,
            Self::TSImportEqualsDeclarationId(_)
                | Self::TSImportEqualsDeclarationModuleReference(_)
        )
    }

    #[inline]
    pub fn is_ts_external_module_reference(self) -> bool {
        matches!(self, Self::TSExternalModuleReferenceExpression(_))
    }

    #[inline]
    pub fn is_ts_non_null_expression(self) -> bool {
        matches!(self, Self::TSNonNullExpressionExpression(_))
    }

    #[inline]
    pub fn is_decorator(self) -> bool {
        matches!(self, Self::DecoratorExpression(_))
    }

    #[inline]
    pub fn is_ts_export_assignment(self) -> bool {
        matches!(self, Self::TSExportAssignmentExpression(_))
    }

    #[inline]
    pub fn is_ts_namespace_export_declaration(self) -> bool {
        matches!(self, Self::TSNamespaceExportDeclarationId(_))
    }

    #[inline]
    pub fn is_ts_instantiation_expression(self) -> bool {
        matches!(
            self,
            Self::TSInstantiationExpressionExpression(_)
                | Self::TSInstantiationExpressionTypeParameters(_)
        )
    }

    #[inline]
    pub fn is_js_doc_nullable_type(self) -> bool {
        matches!(self, Self::JSDocNullableTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_js_doc_non_nullable_type(self) -> bool {
        matches!(self, Self::JSDocNonNullableTypeTypeAnnotation(_))
    }

    #[inline]
    pub fn is_via_statement(self) -> bool {
        matches!(
            self,
            Self::ProgramBody(_)
                | Self::BlockStatementBody(_)
                | Self::IfStatementConsequent(_)
                | Self::IfStatementAlternate(_)
                | Self::DoWhileStatementBody(_)
                | Self::WhileStatementBody(_)
                | Self::ForStatementBody(_)
                | Self::ForInStatementBody(_)
                | Self::ForOfStatementBody(_)
                | Self::WithStatementBody(_)
                | Self::SwitchCaseConsequent(_)
                | Self::LabeledStatementBody(_)
                | Self::FunctionBodyStatements(_)
                | Self::StaticBlockBody(_)
                | Self::TSModuleBlockBody(_)
        )
    }

    #[inline]
    pub fn is_via_array_expression_element(self) -> bool {
        matches!(self, Self::ArrayExpressionElements(_))
    }

    #[inline]
    pub fn is_via_object_property_kind(self) -> bool {
        matches!(self, Self::ObjectExpressionProperties(_))
    }

    #[inline]
    pub fn is_via_property_key(self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyKey(_)
                | Self::AssignmentTargetPropertyPropertyName(_)
                | Self::BindingPropertyKey(_)
                | Self::MethodDefinitionKey(_)
                | Self::PropertyDefinitionKey(_)
                | Self::AccessorPropertyKey(_)
                | Self::TSPropertySignatureKey(_)
                | Self::TSMethodSignatureKey(_)
        )
    }

    #[inline]
    pub fn is_via_expression(self) -> bool {
        matches!(
            self,
            Self::ObjectPropertyValue(_)
                | Self::ObjectPropertyInit(_)
                | Self::TemplateLiteralExpressions(_)
                | Self::TaggedTemplateExpressionTag(_)
                | Self::ComputedMemberExpressionObject(_)
                | Self::ComputedMemberExpressionExpression(_)
                | Self::StaticMemberExpressionObject(_)
                | Self::PrivateFieldExpressionObject(_)
                | Self::CallExpressionCallee(_)
                | Self::NewExpressionCallee(_)
                | Self::SpreadElementArgument(_)
                | Self::UnaryExpressionArgument(_)
                | Self::BinaryExpressionLeft(_)
                | Self::BinaryExpressionRight(_)
                | Self::PrivateInExpressionRight(_)
                | Self::LogicalExpressionLeft(_)
                | Self::LogicalExpressionRight(_)
                | Self::ConditionalExpressionTest(_)
                | Self::ConditionalExpressionConsequent(_)
                | Self::ConditionalExpressionAlternate(_)
                | Self::AssignmentExpressionRight(_)
                | Self::AssignmentTargetWithDefaultInit(_)
                | Self::AssignmentTargetPropertyIdentifierInit(_)
                | Self::SequenceExpressionExpressions(_)
                | Self::AwaitExpressionArgument(_)
                | Self::ParenthesizedExpressionExpression(_)
                | Self::VariableDeclaratorInit(_)
                | Self::ExpressionStatementExpression(_)
                | Self::IfStatementTest(_)
                | Self::DoWhileStatementTest(_)
                | Self::WhileStatementTest(_)
                | Self::ForStatementTest(_)
                | Self::ForStatementUpdate(_)
                | Self::ForInStatementRight(_)
                | Self::ForOfStatementRight(_)
                | Self::ReturnStatementArgument(_)
                | Self::WithStatementObject(_)
                | Self::SwitchStatementDiscriminant(_)
                | Self::SwitchCaseTest(_)
                | Self::ThrowStatementArgument(_)
                | Self::AssignmentPatternRight(_)
                | Self::YieldExpressionArgument(_)
                | Self::ClassSuperClass(_)
                | Self::PropertyDefinitionValue(_)
                | Self::AccessorPropertyValue(_)
                | Self::ImportExpressionSource(_)
                | Self::ImportExpressionArguments(_)
                | Self::JSXSpreadAttributeArgument(_)
                | Self::JSXSpreadChildExpression(_)
                | Self::TSEnumMemberInitializer(_)
                | Self::TSInterfaceHeritageExpression(_)
                | Self::TSImportAttributeValue(_)
                | Self::TSAsExpressionExpression(_)
                | Self::TSSatisfiesExpressionExpression(_)
                | Self::TSTypeAssertionExpression(_)
                | Self::TSNonNullExpressionExpression(_)
                | Self::DecoratorExpression(_)
                | Self::TSExportAssignmentExpression(_)
                | Self::TSInstantiationExpressionExpression(_)
        )
    }

    #[inline]
    pub fn is_via_argument(self) -> bool {
        matches!(self, Self::CallExpressionArguments(_) | Self::NewExpressionArguments(_))
    }

    #[inline]
    pub fn is_via_simple_assignment_target(self) -> bool {
        matches!(self, Self::UpdateExpressionArgument(_))
    }

    #[inline]
    pub fn is_via_assignment_target(self) -> bool {
        matches!(
            self,
            Self::AssignmentExpressionLeft(_)
                | Self::AssignmentTargetRestTarget(_)
                | Self::AssignmentTargetWithDefaultBinding(_)
        )
    }

    #[inline]
    pub fn is_via_assignment_target_maybe_default(self) -> bool {
        matches!(
            self,
            Self::ArrayAssignmentTargetElements(_)
                | Self::AssignmentTargetPropertyPropertyBinding(_)
        )
    }

    #[inline]
    pub fn is_via_assignment_target_property(self) -> bool {
        matches!(self, Self::ObjectAssignmentTargetProperties(_))
    }

    #[inline]
    pub fn is_via_chain_element(self) -> bool {
        matches!(self, Self::ChainExpressionExpression(_))
    }

    #[inline]
    pub fn is_via_for_statement_init(self) -> bool {
        matches!(self, Self::ForStatementInit(_))
    }

    #[inline]
    pub fn is_via_for_statement_left(self) -> bool {
        matches!(self, Self::ForInStatementLeft(_) | Self::ForOfStatementLeft(_))
    }

    #[inline]
    pub fn is_via_binding_pattern_kind(self) -> bool {
        matches!(self, Self::BindingPatternKind(_))
    }

    #[inline]
    pub fn is_via_class_element(self) -> bool {
        matches!(self, Self::ClassBodyBody(_))
    }

    #[inline]
    pub fn is_via_import_declaration_specifier(self) -> bool {
        matches!(self, Self::ImportDeclarationSpecifiers(_))
    }

    #[inline]
    pub fn is_via_module_export_name(self) -> bool {
        matches!(
            self,
            Self::ImportSpecifierImported(_)
                | Self::ExportDefaultDeclarationExported(_)
                | Self::ExportAllDeclarationExported(_)
                | Self::ExportSpecifierLocal(_)
                | Self::ExportSpecifierExported(_)
        )
    }

    #[inline]
    pub fn is_via_import_attribute_key(self) -> bool {
        matches!(self, Self::ImportAttributeKey(_))
    }

    #[inline]
    pub fn is_via_declaration(self) -> bool {
        matches!(self, Self::ExportNamedDeclarationDeclaration(_))
    }

    #[inline]
    pub fn is_via_export_default_declaration_kind(self) -> bool {
        matches!(self, Self::ExportDefaultDeclarationDeclaration(_))
    }

    #[inline]
    pub fn is_via_jsx_child(self) -> bool {
        matches!(self, Self::JSXElementChildren(_) | Self::JSXFragmentChildren(_))
    }

    #[inline]
    pub fn is_via_jsx_element_name(self) -> bool {
        matches!(self, Self::JSXOpeningElementName(_) | Self::JSXClosingElementName(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_item(self) -> bool {
        matches!(self, Self::JSXOpeningElementAttributes(_))
    }

    #[inline]
    pub fn is_via_jsx_member_expression_object(self) -> bool {
        matches!(self, Self::JSXMemberExpressionObject(_))
    }

    #[inline]
    pub fn is_via_jsx_expression(self) -> bool {
        matches!(self, Self::JSXExpressionContainerExpression(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_name(self) -> bool {
        matches!(self, Self::JSXAttributeName(_))
    }

    #[inline]
    pub fn is_via_jsx_attribute_value(self) -> bool {
        matches!(self, Self::JSXAttributeValue(_))
    }

    #[inline]
    pub fn is_via_ts_enum_member_name(self) -> bool {
        matches!(self, Self::TSEnumMemberId(_))
    }

    #[inline]
    pub fn is_via_ts_type(self) -> bool {
        matches!(
            self,
            Self::TSTypeAnnotationTypeAnnotation(_)
                | Self::TSConditionalTypeCheckType(_)
                | Self::TSConditionalTypeExtendsType(_)
                | Self::TSConditionalTypeTrueType(_)
                | Self::TSConditionalTypeFalseType(_)
                | Self::TSUnionTypeTypes(_)
                | Self::TSIntersectionTypeTypes(_)
                | Self::TSParenthesizedTypeTypeAnnotation(_)
                | Self::TSTypeOperatorTypeAnnotation(_)
                | Self::TSArrayTypeElementType(_)
                | Self::TSIndexedAccessTypeObjectType(_)
                | Self::TSIndexedAccessTypeIndexType(_)
                | Self::TSOptionalTypeTypeAnnotation(_)
                | Self::TSRestTypeTypeAnnotation(_)
                | Self::TSTypeParameterInstantiationParams(_)
                | Self::TSTypeParameterConstraint(_)
                | Self::TSTypeParameterDefault(_)
                | Self::TSTypeAliasDeclarationTypeAnnotation(_)
                | Self::TSImportTypeParameter(_)
                | Self::TSMappedTypeNameType(_)
                | Self::TSMappedTypeTypeAnnotation(_)
                | Self::TSTemplateLiteralTypeTypes(_)
                | Self::TSAsExpressionTypeAnnotation(_)
                | Self::TSSatisfiesExpressionTypeAnnotation(_)
                | Self::TSTypeAssertionTypeAnnotation(_)
                | Self::JSDocNullableTypeTypeAnnotation(_)
                | Self::JSDocNonNullableTypeTypeAnnotation(_)
        )
    }

    #[inline]
    pub fn is_via_ts_literal(self) -> bool {
        matches!(self, Self::TSLiteralTypeLiteral(_))
    }

    #[inline]
    pub fn is_via_ts_tuple_element(self) -> bool {
        matches!(self, Self::TSTupleTypeElementTypes(_) | Self::TSNamedTupleMemberElementType(_))
    }

    #[inline]
    pub fn is_via_ts_type_name(self) -> bool {
        matches!(
            self,
            Self::TSTypeReferenceTypeName(_)
                | Self::TSQualifiedNameLeft(_)
                | Self::TSClassImplementsExpression(_)
                | Self::TSImportTypeQualifier(_)
        )
    }

    #[inline]
    pub fn is_via_ts_signature(self) -> bool {
        matches!(self, Self::TSInterfaceBodyBody(_) | Self::TSTypeLiteralMembers(_))
    }

    #[inline]
    pub fn is_via_ts_type_predicate_name(self) -> bool {
        matches!(self, Self::TSTypePredicateParameterName(_))
    }

    #[inline]
    pub fn is_via_ts_module_declaration_name(self) -> bool {
        matches!(self, Self::TSModuleDeclarationId(_))
    }

    #[inline]
    pub fn is_via_ts_module_declaration_body(self) -> bool {
        matches!(self, Self::TSModuleDeclarationBody(_))
    }

    #[inline]
    pub fn is_via_ts_type_query_expr_name(self) -> bool {
        matches!(self, Self::TSTypeQueryExprName(_))
    }

    #[inline]
    pub fn is_via_ts_import_attribute_name(self) -> bool {
        matches!(self, Self::TSImportAttributeName(_))
    }

    #[inline]
    pub fn is_via_ts_module_reference(self) -> bool {
        matches!(self, Self::TSImportEqualsDeclarationModuleReference(_))
    }
}

pub(crate) const OFFSET_PROGRAM_SPAN: usize = offset_of!(Program, span);
pub(crate) const OFFSET_PROGRAM_SOURCE_TYPE: usize = offset_of!(Program, source_type);
pub(crate) const OFFSET_PROGRAM_SOURCE_TEXT: usize = offset_of!(Program, source_text);
pub(crate) const OFFSET_PROGRAM_COMMENTS: usize = offset_of!(Program, comments);
pub(crate) const OFFSET_PROGRAM_HASHBANG: usize = offset_of!(Program, hashbang);
pub(crate) const OFFSET_PROGRAM_DIRECTIVES: usize = offset_of!(Program, directives);
pub(crate) const OFFSET_PROGRAM_BODY: usize = offset_of!(Program, body);
pub(crate) const OFFSET_PROGRAM_SCOPE_ID: usize = offset_of!(Program, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ProgramWithoutHashbang<'a, 't>(
    pub(crate) *const Program<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ProgramWithoutHashbang<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(self) -> &'t SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn source_text(self) -> &'t &'a str {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TEXT) as *const &'a str) }
    }

    #[inline]
    pub fn comments(self) -> &'t Vec<'a, Comment> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_COMMENTS) as *const Vec<'a, Comment>) }
    }

    #[inline]
    pub fn directives(self) -> &'t Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_BODY) as *const Vec<'a, Statement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ProgramWithoutDirectives<'a, 't>(
    pub(crate) *const Program<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ProgramWithoutDirectives<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(self) -> &'t SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn source_text(self) -> &'t &'a str {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TEXT) as *const &'a str) }
    }

    #[inline]
    pub fn comments(self) -> &'t Vec<'a, Comment> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_COMMENTS) as *const Vec<'a, Comment>) }
    }

    #[inline]
    pub fn hashbang(self) -> &'t Option<Hashbang<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_HASHBANG) as *const Option<Hashbang<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_BODY) as *const Vec<'a, Statement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ProgramWithoutBody<'a, 't>(
    pub(crate) *const Program<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ProgramWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source_type(self) -> &'t SourceType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TYPE) as *const SourceType) }
    }

    #[inline]
    pub fn source_text(self) -> &'t &'a str {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_SOURCE_TEXT) as *const &'a str) }
    }

    #[inline]
    pub fn comments(self) -> &'t Vec<'a, Comment> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROGRAM_COMMENTS) as *const Vec<'a, Comment>) }
    }

    #[inline]
    pub fn hashbang(self) -> &'t Option<Hashbang<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_HASHBANG) as *const Option<Hashbang<'a>>)
        }
    }

    #[inline]
    pub fn directives(self) -> &'t Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROGRAM_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_ARRAY_EXPRESSION_SPAN: usize = offset_of!(ArrayExpression, span);
pub(crate) const OFFSET_ARRAY_EXPRESSION_ELEMENTS: usize = offset_of!(ArrayExpression, elements);
pub(crate) const OFFSET_ARRAY_EXPRESSION_TRAILING_COMMA: usize =
    offset_of!(ArrayExpression, trailing_comma);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrayExpressionWithoutElements<'a, 't>(
    pub(crate) *const ArrayExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrayExpressionWithoutElements<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn trailing_comma(self) -> &'t Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_EXPRESSION_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_EXPRESSION_SPAN: usize = offset_of!(ObjectExpression, span);
pub(crate) const OFFSET_OBJECT_EXPRESSION_PROPERTIES: usize =
    offset_of!(ObjectExpression, properties);
pub(crate) const OFFSET_OBJECT_EXPRESSION_TRAILING_COMMA: usize =
    offset_of!(ObjectExpression, trailing_comma);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectExpressionWithoutProperties<'a, 't>(
    pub(crate) *const ObjectExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectExpressionWithoutProperties<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn trailing_comma(self) -> &'t Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_EXPRESSION_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_PROPERTY_SPAN: usize = offset_of!(ObjectProperty, span);
pub(crate) const OFFSET_OBJECT_PROPERTY_KIND: usize = offset_of!(ObjectProperty, kind);
pub(crate) const OFFSET_OBJECT_PROPERTY_KEY: usize = offset_of!(ObjectProperty, key);
pub(crate) const OFFSET_OBJECT_PROPERTY_VALUE: usize = offset_of!(ObjectProperty, value);
pub(crate) const OFFSET_OBJECT_PROPERTY_INIT: usize = offset_of!(ObjectProperty, init);
pub(crate) const OFFSET_OBJECT_PROPERTY_METHOD: usize = offset_of!(ObjectProperty, method);
pub(crate) const OFFSET_OBJECT_PROPERTY_SHORTHAND: usize = offset_of!(ObjectProperty, shorthand);
pub(crate) const OFFSET_OBJECT_PROPERTY_COMPUTED: usize = offset_of!(ObjectProperty, computed);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectPropertyWithoutKey<'a, 't>(
    pub(crate) *const ObjectProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectPropertyWithoutKey<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn value(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_VALUE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn init(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn method(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectPropertyWithoutValue<'a, 't>(
    pub(crate) *const ObjectProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectPropertyWithoutValue<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn init(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn method(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectPropertyWithoutInit<'a, 't>(
    pub(crate) *const ObjectProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectPropertyWithoutInit<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t PropertyKind {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KIND) as *const PropertyKind) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_VALUE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn method(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_METHOD) as *const bool) }
    }

    #[inline]
    pub fn shorthand(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PROPERTY_COMPUTED) as *const bool) }
    }
}

pub(crate) const OFFSET_TEMPLATE_LITERAL_SPAN: usize = offset_of!(TemplateLiteral, span);
pub(crate) const OFFSET_TEMPLATE_LITERAL_QUASIS: usize = offset_of!(TemplateLiteral, quasis);
pub(crate) const OFFSET_TEMPLATE_LITERAL_EXPRESSIONS: usize =
    offset_of!(TemplateLiteral, expressions);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TemplateLiteralWithoutQuasis<'a, 't>(
    pub(crate) *const TemplateLiteral<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TemplateLiteralWithoutQuasis<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expressions(self) -> &'t Vec<'a, Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_EXPRESSIONS)
                as *const Vec<'a, Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TemplateLiteralWithoutExpressions<'a, 't>(
    pub(crate) *const TemplateLiteral<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TemplateLiteralWithoutExpressions<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_SPAN) as *const Span) }
    }

    #[inline]
    pub fn quasis(self) -> &'t Vec<'a, TemplateElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TEMPLATE_LITERAL_QUASIS)
                as *const Vec<'a, TemplateElement<'a>>)
        }
    }
}

pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN: usize =
    offset_of!(TaggedTemplateExpression, span);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG: usize =
    offset_of!(TaggedTemplateExpression, tag);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI: usize =
    offset_of!(TaggedTemplateExpression, quasi);
pub(crate) const OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(TaggedTemplateExpression, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TaggedTemplateExpressionWithoutTag<'a, 't>(
    pub(crate) *const TaggedTemplateExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TaggedTemplateExpressionWithoutTag<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn quasi(self) -> &'t TemplateLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI)
                as *const TemplateLiteral<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TaggedTemplateExpressionWithoutQuasi<'a, 't>(
    pub(crate) *const TaggedTemplateExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TaggedTemplateExpressionWithoutQuasi<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn tag(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TaggedTemplateExpressionWithoutTypeParameters<'a, 't>(
    pub(crate) *const TaggedTemplateExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TaggedTemplateExpressionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn tag(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_TAG)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn quasi(self) -> &'t TemplateLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TAGGED_TEMPLATE_EXPRESSION_QUASI)
                as *const TemplateLiteral<'a>)
        }
    }
}

pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN: usize =
    offset_of!(ComputedMemberExpression, span);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(ComputedMemberExpression, object);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_EXPRESSION: usize =
    offset_of!(ComputedMemberExpression, expression);
pub(crate) const OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL: usize =
    offset_of!(ComputedMemberExpression, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ComputedMemberExpressionWithoutObject<'a, 't>(
    pub(crate) *const ComputedMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ComputedMemberExpressionWithoutObject<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ComputedMemberExpressionWithoutExpression<'a, 't>(
    pub(crate) *const ComputedMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ComputedMemberExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_COMPUTED_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_SPAN: usize =
    offset_of!(StaticMemberExpression, span);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(StaticMemberExpression, object);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_PROPERTY: usize =
    offset_of!(StaticMemberExpression, property);
pub(crate) const OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL: usize =
    offset_of!(StaticMemberExpression, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct StaticMemberExpressionWithoutObject<'a, 't>(
    pub(crate) *const StaticMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> StaticMemberExpressionWithoutObject<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn property(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_PROPERTY)
                as *const IdentifierName<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct StaticMemberExpressionWithoutProperty<'a, 't>(
    pub(crate) *const StaticMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> StaticMemberExpressionWithoutProperty<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_MEMBER_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN: usize =
    offset_of!(PrivateFieldExpression, span);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_OBJECT: usize =
    offset_of!(PrivateFieldExpression, object);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_FIELD: usize =
    offset_of!(PrivateFieldExpression, field);
pub(crate) const OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL: usize =
    offset_of!(PrivateFieldExpression, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PrivateFieldExpressionWithoutObject<'a, 't>(
    pub(crate) *const PrivateFieldExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PrivateFieldExpressionWithoutObject<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn field(self) -> &'t PrivateIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_FIELD)
                as *const PrivateIdentifier<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PrivateFieldExpressionWithoutField<'a, 't>(
    pub(crate) *const PrivateFieldExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PrivateFieldExpressionWithoutField<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn object(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OBJECT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_FIELD_EXPRESSION_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_CALL_EXPRESSION_SPAN: usize = offset_of!(CallExpression, span);
pub(crate) const OFFSET_CALL_EXPRESSION_CALLEE: usize = offset_of!(CallExpression, callee);
pub(crate) const OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(CallExpression, type_parameters);
pub(crate) const OFFSET_CALL_EXPRESSION_ARGUMENTS: usize = offset_of!(CallExpression, arguments);
pub(crate) const OFFSET_CALL_EXPRESSION_OPTIONAL: usize = offset_of!(CallExpression, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CallExpressionWithoutCallee<'a, 't>(
    pub(crate) *const CallExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CallExpressionWithoutCallee<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn arguments(self) -> &'t Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CallExpressionWithoutTypeParameters<'a, 't>(
    pub(crate) *const CallExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CallExpressionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn arguments(self) -> &'t Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CallExpressionWithoutArguments<'a, 't>(
    pub(crate) *const CallExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CallExpressionWithoutArguments<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CALL_EXPRESSION_OPTIONAL) as *const bool) }
    }
}

pub(crate) const OFFSET_NEW_EXPRESSION_SPAN: usize = offset_of!(NewExpression, span);
pub(crate) const OFFSET_NEW_EXPRESSION_CALLEE: usize = offset_of!(NewExpression, callee);
pub(crate) const OFFSET_NEW_EXPRESSION_ARGUMENTS: usize = offset_of!(NewExpression, arguments);
pub(crate) const OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(NewExpression, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct NewExpressionWithoutCallee<'a, 't>(
    pub(crate) *const NewExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> NewExpressionWithoutCallee<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn arguments(self) -> &'t Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct NewExpressionWithoutArguments<'a, 't>(
    pub(crate) *const NewExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> NewExpressionWithoutArguments<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct NewExpressionWithoutTypeParameters<'a, 't>(
    pub(crate) *const NewExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> NewExpressionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn callee(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_CALLEE) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn arguments(self) -> &'t Vec<'a, Argument<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_NEW_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Argument<'a>>)
        }
    }
}

pub(crate) const OFFSET_META_PROPERTY_SPAN: usize = offset_of!(MetaProperty, span);
pub(crate) const OFFSET_META_PROPERTY_META: usize = offset_of!(MetaProperty, meta);
pub(crate) const OFFSET_META_PROPERTY_PROPERTY: usize = offset_of!(MetaProperty, property);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct MetaPropertyWithoutMeta<'a, 't>(
    pub(crate) *const MetaProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> MetaPropertyWithoutMeta<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_PROPERTY)
                as *const IdentifierName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct MetaPropertyWithoutProperty<'a, 't>(
    pub(crate) *const MetaProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> MetaPropertyWithoutProperty<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn meta(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_META_PROPERTY_META) as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_SPREAD_ELEMENT_SPAN: usize = offset_of!(SpreadElement, span);
pub(crate) const OFFSET_SPREAD_ELEMENT_ARGUMENT: usize = offset_of!(SpreadElement, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SpreadElementWithoutArgument<'a, 't>(
    pub(crate) *const SpreadElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SpreadElementWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SPREAD_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_UPDATE_EXPRESSION_SPAN: usize = offset_of!(UpdateExpression, span);
pub(crate) const OFFSET_UPDATE_EXPRESSION_OPERATOR: usize = offset_of!(UpdateExpression, operator);
pub(crate) const OFFSET_UPDATE_EXPRESSION_PREFIX: usize = offset_of!(UpdateExpression, prefix);
pub(crate) const OFFSET_UPDATE_EXPRESSION_ARGUMENT: usize = offset_of!(UpdateExpression, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct UpdateExpressionWithoutArgument<'a, 't>(
    pub(crate) *const UpdateExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> UpdateExpressionWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t UpdateOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_OPERATOR)
                as *const UpdateOperator)
        }
    }

    #[inline]
    pub fn prefix(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UPDATE_EXPRESSION_PREFIX) as *const bool) }
    }
}

pub(crate) const OFFSET_UNARY_EXPRESSION_SPAN: usize = offset_of!(UnaryExpression, span);
pub(crate) const OFFSET_UNARY_EXPRESSION_OPERATOR: usize = offset_of!(UnaryExpression, operator);
pub(crate) const OFFSET_UNARY_EXPRESSION_ARGUMENT: usize = offset_of!(UnaryExpression, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct UnaryExpressionWithoutArgument<'a, 't>(
    pub(crate) *const UnaryExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> UnaryExpressionWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_UNARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t UnaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_UNARY_EXPRESSION_OPERATOR) as *const UnaryOperator)
        }
    }
}

pub(crate) const OFFSET_BINARY_EXPRESSION_SPAN: usize = offset_of!(BinaryExpression, span);
pub(crate) const OFFSET_BINARY_EXPRESSION_LEFT: usize = offset_of!(BinaryExpression, left);
pub(crate) const OFFSET_BINARY_EXPRESSION_OPERATOR: usize = offset_of!(BinaryExpression, operator);
pub(crate) const OFFSET_BINARY_EXPRESSION_RIGHT: usize = offset_of!(BinaryExpression, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BinaryExpressionWithoutLeft<'a, 't>(
    pub(crate) *const BinaryExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BinaryExpressionWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BinaryExpressionWithoutRight<'a, 't>(
    pub(crate) *const BinaryExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BinaryExpressionWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_LEFT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn operator(self) -> &'t BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINARY_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }
}

pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_SPAN: usize = offset_of!(PrivateInExpression, span);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_LEFT: usize = offset_of!(PrivateInExpression, left);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR: usize =
    offset_of!(PrivateInExpression, operator);
pub(crate) const OFFSET_PRIVATE_IN_EXPRESSION_RIGHT: usize = offset_of!(PrivateInExpression, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PrivateInExpressionWithoutLeft<'a, 't>(
    pub(crate) *const PrivateInExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PrivateInExpressionWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_RIGHT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PrivateInExpressionWithoutRight<'a, 't>(
    pub(crate) *const PrivateInExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PrivateInExpressionWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t PrivateIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_LEFT)
                as *const PrivateIdentifier<'a>)
        }
    }

    #[inline]
    pub fn operator(self) -> &'t BinaryOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PRIVATE_IN_EXPRESSION_OPERATOR)
                as *const BinaryOperator)
        }
    }
}

pub(crate) const OFFSET_LOGICAL_EXPRESSION_SPAN: usize = offset_of!(LogicalExpression, span);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_LEFT: usize = offset_of!(LogicalExpression, left);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_OPERATOR: usize =
    offset_of!(LogicalExpression, operator);
pub(crate) const OFFSET_LOGICAL_EXPRESSION_RIGHT: usize = offset_of!(LogicalExpression, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct LogicalExpressionWithoutLeft<'a, 't>(
    pub(crate) *const LogicalExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> LogicalExpressionWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t LogicalOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_OPERATOR)
                as *const LogicalOperator)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct LogicalExpressionWithoutRight<'a, 't>(
    pub(crate) *const LogicalExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> LogicalExpressionWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_LEFT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn operator(self) -> &'t LogicalOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LOGICAL_EXPRESSION_OPERATOR)
                as *const LogicalOperator)
        }
    }
}

pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_SPAN: usize =
    offset_of!(ConditionalExpression, span);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_TEST: usize =
    offset_of!(ConditionalExpression, test);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT: usize =
    offset_of!(ConditionalExpression, consequent);
pub(crate) const OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE: usize =
    offset_of!(ConditionalExpression, alternate);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ConditionalExpressionWithoutTest<'a, 't>(
    pub(crate) *const ConditionalExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ConditionalExpressionWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn alternate(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ConditionalExpressionWithoutConsequent<'a, 't>(
    pub(crate) *const ConditionalExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ConditionalExpressionWithoutConsequent<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_TEST)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn alternate(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_ALTERNATE)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ConditionalExpressionWithoutAlternate<'a, 't>(
    pub(crate) *const ConditionalExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ConditionalExpressionWithoutAlternate<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_TEST)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn consequent(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CONDITIONAL_EXPRESSION_CONSEQUENT)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_SPAN: usize = offset_of!(AssignmentExpression, span);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR: usize =
    offset_of!(AssignmentExpression, operator);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_LEFT: usize = offset_of!(AssignmentExpression, left);
pub(crate) const OFFSET_ASSIGNMENT_EXPRESSION_RIGHT: usize =
    offset_of!(AssignmentExpression, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentExpressionWithoutLeft<'a, 't>(
    pub(crate) *const AssignmentExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentExpressionWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t AssignmentOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR)
                as *const AssignmentOperator)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_RIGHT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentExpressionWithoutRight<'a, 't>(
    pub(crate) *const AssignmentExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentExpressionWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t AssignmentOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_OPERATOR)
                as *const AssignmentOperator)
        }
    }

    #[inline]
    pub fn left(self) -> &'t AssignmentTarget<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_EXPRESSION_LEFT)
                as *const AssignmentTarget<'a>)
        }
    }
}

pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN: usize =
    offset_of!(ArrayAssignmentTarget, span);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_ELEMENTS: usize =
    offset_of!(ArrayAssignmentTarget, elements);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_REST: usize =
    offset_of!(ArrayAssignmentTarget, rest);
pub(crate) const OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA: usize =
    offset_of!(ArrayAssignmentTarget, trailing_comma);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrayAssignmentTargetWithoutElements<'a, 't>(
    pub(crate) *const ArrayAssignmentTarget<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrayAssignmentTargetWithoutElements<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(self) -> &'t Option<AssignmentTargetRest<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_REST)
                as *const Option<AssignmentTargetRest<'a>>)
        }
    }

    #[inline]
    pub fn trailing_comma(self) -> &'t Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrayAssignmentTargetWithoutRest<'a, 't>(
    pub(crate) *const ArrayAssignmentTarget<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrayAssignmentTargetWithoutRest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_SPAN) as *const Span) }
    }

    #[inline]
    pub fn elements(self) -> &'t Vec<'a, Option<AssignmentTargetMaybeDefault<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_ELEMENTS)
                as *const Vec<'a, Option<AssignmentTargetMaybeDefault<'a>>>)
        }
    }

    #[inline]
    pub fn trailing_comma(self) -> &'t Option<Span> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_ASSIGNMENT_TARGET_TRAILING_COMMA)
                as *const Option<Span>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN: usize =
    offset_of!(ObjectAssignmentTarget, span);
pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_PROPERTIES: usize =
    offset_of!(ObjectAssignmentTarget, properties);
pub(crate) const OFFSET_OBJECT_ASSIGNMENT_TARGET_REST: usize =
    offset_of!(ObjectAssignmentTarget, rest);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectAssignmentTargetWithoutProperties<'a, 't>(
    pub(crate) *const ObjectAssignmentTarget<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectAssignmentTargetWithoutProperties<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn rest(self) -> &'t Option<AssignmentTargetRest<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_REST)
                as *const Option<AssignmentTargetRest<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectAssignmentTargetWithoutRest<'a, 't>(
    pub(crate) *const ObjectAssignmentTarget<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectAssignmentTargetWithoutRest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn properties(self) -> &'t Vec<'a, AssignmentTargetProperty<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_ASSIGNMENT_TARGET_PROPERTIES)
                as *const Vec<'a, AssignmentTargetProperty<'a>>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_REST_SPAN: usize = offset_of!(AssignmentTargetRest, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_REST_TARGET: usize =
    offset_of!(AssignmentTargetRest, target);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetRestWithoutTarget<'a, 't>(
    pub(crate) *const AssignmentTargetRest<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetRestWithoutTarget<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_REST_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN: usize =
    offset_of!(AssignmentTargetWithDefault, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_BINDING: usize =
    offset_of!(AssignmentTargetWithDefault, binding);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_INIT: usize =
    offset_of!(AssignmentTargetWithDefault, init);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetWithDefaultWithoutBinding<'a, 't>(
    pub(crate) *const AssignmentTargetWithDefault<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetWithDefaultWithoutBinding<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn init(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_INIT)
                as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetWithDefaultWithoutInit<'a, 't>(
    pub(crate) *const AssignmentTargetWithDefault<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetWithDefaultWithoutInit<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn binding(self) -> &'t AssignmentTarget<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_WITH_DEFAULT_BINDING)
                as *const AssignmentTarget<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_BINDING: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, binding);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_INIT: usize =
    offset_of!(AssignmentTargetPropertyIdentifier, init);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetPropertyIdentifierWithoutBinding<'a, 't>(
    pub(crate) *const AssignmentTargetPropertyIdentifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetPropertyIdentifierWithoutBinding<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn init(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_INIT)
                as *const Option<Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetPropertyIdentifierWithoutInit<'a, 't>(
    pub(crate) *const AssignmentTargetPropertyIdentifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetPropertyIdentifierWithoutInit<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn binding(self) -> &'t IdentifierReference<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_IDENTIFIER_BINDING)
                as *const IdentifierReference<'a>)
        }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN: usize =
    offset_of!(AssignmentTargetPropertyProperty, span);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_NAME: usize =
    offset_of!(AssignmentTargetPropertyProperty, name);
pub(crate) const OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_BINDING: usize =
    offset_of!(AssignmentTargetPropertyProperty, binding);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetPropertyPropertyWithoutName<'a, 't>(
    pub(crate) *const AssignmentTargetPropertyProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetPropertyPropertyWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn binding(self) -> &'t AssignmentTargetMaybeDefault<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_BINDING)
                as *const AssignmentTargetMaybeDefault<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentTargetPropertyPropertyWithoutBinding<'a, 't>(
    pub(crate) *const AssignmentTargetPropertyProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentTargetPropertyPropertyWithoutBinding<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn name(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_TARGET_PROPERTY_PROPERTY_NAME)
                as *const PropertyKey<'a>)
        }
    }
}

pub(crate) const OFFSET_SEQUENCE_EXPRESSION_SPAN: usize = offset_of!(SequenceExpression, span);
pub(crate) const OFFSET_SEQUENCE_EXPRESSION_EXPRESSIONS: usize =
    offset_of!(SequenceExpression, expressions);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SequenceExpressionWithoutExpressions<'a, 't>(
    pub(crate) *const SequenceExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SequenceExpressionWithoutExpressions<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SEQUENCE_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_AWAIT_EXPRESSION_SPAN: usize = offset_of!(AwaitExpression, span);
pub(crate) const OFFSET_AWAIT_EXPRESSION_ARGUMENT: usize = offset_of!(AwaitExpression, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AwaitExpressionWithoutArgument<'a, 't>(
    pub(crate) *const AwaitExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AwaitExpressionWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_AWAIT_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_CHAIN_EXPRESSION_SPAN: usize = offset_of!(ChainExpression, span);
pub(crate) const OFFSET_CHAIN_EXPRESSION_EXPRESSION: usize =
    offset_of!(ChainExpression, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ChainExpressionWithoutExpression<'a, 't>(
    pub(crate) *const ChainExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ChainExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CHAIN_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_PARENTHESIZED_EXPRESSION_SPAN: usize =
    offset_of!(ParenthesizedExpression, span);
pub(crate) const OFFSET_PARENTHESIZED_EXPRESSION_EXPRESSION: usize =
    offset_of!(ParenthesizedExpression, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ParenthesizedExpressionWithoutExpression<'a, 't>(
    pub(crate) *const ParenthesizedExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ParenthesizedExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PARENTHESIZED_EXPRESSION_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_DIRECTIVE_SPAN: usize = offset_of!(Directive, span);
pub(crate) const OFFSET_DIRECTIVE_EXPRESSION: usize = offset_of!(Directive, expression);
pub(crate) const OFFSET_DIRECTIVE_DIRECTIVE: usize = offset_of!(Directive, directive);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct DirectiveWithoutExpression<'a, 't>(
    pub(crate) *const Directive<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> DirectiveWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DIRECTIVE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn directive(self) -> &'t Atom<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DIRECTIVE_DIRECTIVE) as *const Atom<'a>) }
    }
}

pub(crate) const OFFSET_BLOCK_STATEMENT_SPAN: usize = offset_of!(BlockStatement, span);
pub(crate) const OFFSET_BLOCK_STATEMENT_BODY: usize = offset_of!(BlockStatement, body);
pub(crate) const OFFSET_BLOCK_STATEMENT_SCOPE_ID: usize = offset_of!(BlockStatement, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BlockStatementWithoutBody<'a, 't>(
    pub(crate) *const BlockStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BlockStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BLOCK_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BLOCK_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_VARIABLE_DECLARATION_SPAN: usize = offset_of!(VariableDeclaration, span);
pub(crate) const OFFSET_VARIABLE_DECLARATION_KIND: usize = offset_of!(VariableDeclaration, kind);
pub(crate) const OFFSET_VARIABLE_DECLARATION_DECLARATIONS: usize =
    offset_of!(VariableDeclaration, declarations);
pub(crate) const OFFSET_VARIABLE_DECLARATION_DECLARE: usize =
    offset_of!(VariableDeclaration, declare);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct VariableDeclarationWithoutDeclarations<'a, 't>(
    pub(crate) *const VariableDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> VariableDeclarationWithoutDeclarations<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATION_DECLARE) as *const bool) }
    }
}

pub(crate) const OFFSET_VARIABLE_DECLARATOR_SPAN: usize = offset_of!(VariableDeclarator, span);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_KIND: usize = offset_of!(VariableDeclarator, kind);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_ID: usize = offset_of!(VariableDeclarator, id);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_INIT: usize = offset_of!(VariableDeclarator, init);
pub(crate) const OFFSET_VARIABLE_DECLARATOR_DEFINITE: usize =
    offset_of!(VariableDeclarator, definite);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct VariableDeclaratorWithoutId<'a, 't>(
    pub(crate) *const VariableDeclarator<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> VariableDeclaratorWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn init(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_INIT)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_DEFINITE) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct VariableDeclaratorWithoutInit<'a, 't>(
    pub(crate) *const VariableDeclarator<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> VariableDeclaratorWithoutInit<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t VariableDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_KIND)
                as *const VariableDeclarationKind)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_ID)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_VARIABLE_DECLARATOR_DEFINITE) as *const bool) }
    }
}

pub(crate) const OFFSET_EXPRESSION_STATEMENT_SPAN: usize = offset_of!(ExpressionStatement, span);
pub(crate) const OFFSET_EXPRESSION_STATEMENT_EXPRESSION: usize =
    offset_of!(ExpressionStatement, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExpressionStatementWithoutExpression<'a, 't>(
    pub(crate) *const ExpressionStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExpressionStatementWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPRESSION_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_IF_STATEMENT_SPAN: usize = offset_of!(IfStatement, span);
pub(crate) const OFFSET_IF_STATEMENT_TEST: usize = offset_of!(IfStatement, test);
pub(crate) const OFFSET_IF_STATEMENT_CONSEQUENT: usize = offset_of!(IfStatement, consequent);
pub(crate) const OFFSET_IF_STATEMENT_ALTERNATE: usize = offset_of!(IfStatement, alternate);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct IfStatementWithoutTest<'a, 't>(
    pub(crate) *const IfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> IfStatementWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_CONSEQUENT) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn alternate(self) -> &'t Option<Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_ALTERNATE)
                as *const Option<Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct IfStatementWithoutConsequent<'a, 't>(
    pub(crate) *const IfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> IfStatementWithoutConsequent<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_TEST) as *const Expression<'a>) }
    }

    #[inline]
    pub fn alternate(self) -> &'t Option<Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_ALTERNATE)
                as *const Option<Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct IfStatementWithoutAlternate<'a, 't>(
    pub(crate) *const IfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> IfStatementWithoutAlternate<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_TEST) as *const Expression<'a>) }
    }

    #[inline]
    pub fn consequent(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IF_STATEMENT_CONSEQUENT) as *const Statement<'a>)
        }
    }
}

pub(crate) const OFFSET_DO_WHILE_STATEMENT_SPAN: usize = offset_of!(DoWhileStatement, span);
pub(crate) const OFFSET_DO_WHILE_STATEMENT_BODY: usize = offset_of!(DoWhileStatement, body);
pub(crate) const OFFSET_DO_WHILE_STATEMENT_TEST: usize = offset_of!(DoWhileStatement, test);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct DoWhileStatementWithoutBody<'a, 't>(
    pub(crate) *const DoWhileStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> DoWhileStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_TEST) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct DoWhileStatementWithoutTest<'a, 't>(
    pub(crate) *const DoWhileStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> DoWhileStatementWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_DO_WHILE_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

pub(crate) const OFFSET_WHILE_STATEMENT_SPAN: usize = offset_of!(WhileStatement, span);
pub(crate) const OFFSET_WHILE_STATEMENT_TEST: usize = offset_of!(WhileStatement, test);
pub(crate) const OFFSET_WHILE_STATEMENT_BODY: usize = offset_of!(WhileStatement, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WhileStatementWithoutTest<'a, 't>(
    pub(crate) *const WhileStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WhileStatementWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WhileStatementWithoutBody<'a, 't>(
    pub(crate) *const WhileStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WhileStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WHILE_STATEMENT_TEST) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_FOR_STATEMENT_SPAN: usize = offset_of!(ForStatement, span);
pub(crate) const OFFSET_FOR_STATEMENT_INIT: usize = offset_of!(ForStatement, init);
pub(crate) const OFFSET_FOR_STATEMENT_TEST: usize = offset_of!(ForStatement, test);
pub(crate) const OFFSET_FOR_STATEMENT_UPDATE: usize = offset_of!(ForStatement, update);
pub(crate) const OFFSET_FOR_STATEMENT_BODY: usize = offset_of!(ForStatement, body);
pub(crate) const OFFSET_FOR_STATEMENT_SCOPE_ID: usize = offset_of!(ForStatement, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForStatementWithoutInit<'a, 't>(
    pub(crate) *const ForStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForStatementWithoutInit<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn update(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForStatementWithoutTest<'a, 't>(
    pub(crate) *const ForStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForStatementWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(self) -> &'t Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn update(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForStatementWithoutUpdate<'a, 't>(
    pub(crate) *const ForStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForStatementWithoutUpdate<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(self) -> &'t Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn test(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_BODY) as *const Statement<'a>) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForStatementWithoutBody<'a, 't>(
    pub(crate) *const ForStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn init(self) -> &'t Option<ForStatementInit<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_INIT)
                as *const Option<ForStatementInit<'a>>)
        }
    }

    #[inline]
    pub fn test(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_TEST)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn update(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_UPDATE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FOR_IN_STATEMENT_SPAN: usize = offset_of!(ForInStatement, span);
pub(crate) const OFFSET_FOR_IN_STATEMENT_LEFT: usize = offset_of!(ForInStatement, left);
pub(crate) const OFFSET_FOR_IN_STATEMENT_RIGHT: usize = offset_of!(ForInStatement, right);
pub(crate) const OFFSET_FOR_IN_STATEMENT_BODY: usize = offset_of!(ForInStatement, body);
pub(crate) const OFFSET_FOR_IN_STATEMENT_SCOPE_ID: usize = offset_of!(ForInStatement, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForInStatementWithoutLeft<'a, 't>(
    pub(crate) *const ForInStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForInStatementWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForInStatementWithoutRight<'a, 't>(
    pub(crate) *const ForInStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForInStatementWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForInStatementWithoutBody<'a, 't>(
    pub(crate) *const ForInStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForInStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_IN_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FOR_OF_STATEMENT_SPAN: usize = offset_of!(ForOfStatement, span);
pub(crate) const OFFSET_FOR_OF_STATEMENT_AWAIT: usize = offset_of!(ForOfStatement, r#await);
pub(crate) const OFFSET_FOR_OF_STATEMENT_LEFT: usize = offset_of!(ForOfStatement, left);
pub(crate) const OFFSET_FOR_OF_STATEMENT_RIGHT: usize = offset_of!(ForOfStatement, right);
pub(crate) const OFFSET_FOR_OF_STATEMENT_BODY: usize = offset_of!(ForOfStatement, body);
pub(crate) const OFFSET_FOR_OF_STATEMENT_SCOPE_ID: usize = offset_of!(ForOfStatement, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForOfStatementWithoutLeft<'a, 't>(
    pub(crate) *const ForOfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForOfStatementWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForOfStatementWithoutRight<'a, 't>(
    pub(crate) *const ForOfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForOfStatementWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn left(self) -> &'t ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_BODY) as *const Statement<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ForOfStatementWithoutBody<'a, 't>(
    pub(crate) *const ForOfStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ForOfStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#await(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_AWAIT) as *const bool) }
    }

    #[inline]
    pub fn left(self) -> &'t ForStatementLeft<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_LEFT)
                as *const ForStatementLeft<'a>)
        }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_RIGHT) as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FOR_OF_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CONTINUE_STATEMENT_SPAN: usize = offset_of!(ContinueStatement, span);
pub(crate) const OFFSET_CONTINUE_STATEMENT_LABEL: usize = offset_of!(ContinueStatement, label);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ContinueStatementWithoutLabel<'a, 't>(
    pub(crate) *const ContinueStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ContinueStatementWithoutLabel<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CONTINUE_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_BREAK_STATEMENT_SPAN: usize = offset_of!(BreakStatement, span);
pub(crate) const OFFSET_BREAK_STATEMENT_LABEL: usize = offset_of!(BreakStatement, label);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BreakStatementWithoutLabel<'a, 't>(
    pub(crate) *const BreakStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BreakStatementWithoutLabel<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BREAK_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_RETURN_STATEMENT_SPAN: usize = offset_of!(ReturnStatement, span);
pub(crate) const OFFSET_RETURN_STATEMENT_ARGUMENT: usize = offset_of!(ReturnStatement, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ReturnStatementWithoutArgument<'a, 't>(
    pub(crate) *const ReturnStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ReturnStatementWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_RETURN_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_WITH_STATEMENT_SPAN: usize = offset_of!(WithStatement, span);
pub(crate) const OFFSET_WITH_STATEMENT_OBJECT: usize = offset_of!(WithStatement, object);
pub(crate) const OFFSET_WITH_STATEMENT_BODY: usize = offset_of!(WithStatement, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WithStatementWithoutObject<'a, 't>(
    pub(crate) *const WithStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WithStatementWithoutObject<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_BODY) as *const Statement<'a>) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WithStatementWithoutBody<'a, 't>(
    pub(crate) *const WithStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WithStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_STATEMENT_OBJECT) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_SWITCH_STATEMENT_SPAN: usize = offset_of!(SwitchStatement, span);
pub(crate) const OFFSET_SWITCH_STATEMENT_DISCRIMINANT: usize =
    offset_of!(SwitchStatement, discriminant);
pub(crate) const OFFSET_SWITCH_STATEMENT_CASES: usize = offset_of!(SwitchStatement, cases);
pub(crate) const OFFSET_SWITCH_STATEMENT_SCOPE_ID: usize = offset_of!(SwitchStatement, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SwitchStatementWithoutDiscriminant<'a, 't>(
    pub(crate) *const SwitchStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SwitchStatementWithoutDiscriminant<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn cases(self) -> &'t Vec<'a, SwitchCase<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_CASES)
                as *const Vec<'a, SwitchCase<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SwitchStatementWithoutCases<'a, 't>(
    pub(crate) *const SwitchStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SwitchStatementWithoutCases<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn discriminant(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_DISCRIMINANT)
                as *const Expression<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_STATEMENT_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_SWITCH_CASE_SPAN: usize = offset_of!(SwitchCase, span);
pub(crate) const OFFSET_SWITCH_CASE_TEST: usize = offset_of!(SwitchCase, test);
pub(crate) const OFFSET_SWITCH_CASE_CONSEQUENT: usize = offset_of!(SwitchCase, consequent);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SwitchCaseWithoutTest<'a, 't>(
    pub(crate) *const SwitchCase<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SwitchCaseWithoutTest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn consequent(self) -> &'t Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_CONSEQUENT)
                as *const Vec<'a, Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct SwitchCaseWithoutConsequent<'a, 't>(
    pub(crate) *const SwitchCase<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> SwitchCaseWithoutConsequent<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn test(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_SWITCH_CASE_TEST) as *const Option<Expression<'a>>)
        }
    }
}

pub(crate) const OFFSET_LABELED_STATEMENT_SPAN: usize = offset_of!(LabeledStatement, span);
pub(crate) const OFFSET_LABELED_STATEMENT_LABEL: usize = offset_of!(LabeledStatement, label);
pub(crate) const OFFSET_LABELED_STATEMENT_BODY: usize = offset_of!(LabeledStatement, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct LabeledStatementWithoutLabel<'a, 't>(
    pub(crate) *const LabeledStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> LabeledStatementWithoutLabel<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Statement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_BODY) as *const Statement<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct LabeledStatementWithoutBody<'a, 't>(
    pub(crate) *const LabeledStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> LabeledStatementWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn label(self) -> &'t LabelIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_LABELED_STATEMENT_LABEL)
                as *const LabelIdentifier<'a>)
        }
    }
}

pub(crate) const OFFSET_THROW_STATEMENT_SPAN: usize = offset_of!(ThrowStatement, span);
pub(crate) const OFFSET_THROW_STATEMENT_ARGUMENT: usize = offset_of!(ThrowStatement, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ThrowStatementWithoutArgument<'a, 't>(
    pub(crate) *const ThrowStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ThrowStatementWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_THROW_STATEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TRY_STATEMENT_SPAN: usize = offset_of!(TryStatement, span);
pub(crate) const OFFSET_TRY_STATEMENT_BLOCK: usize = offset_of!(TryStatement, block);
pub(crate) const OFFSET_TRY_STATEMENT_HANDLER: usize = offset_of!(TryStatement, handler);
pub(crate) const OFFSET_TRY_STATEMENT_FINALIZER: usize = offset_of!(TryStatement, finalizer);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TryStatementWithoutBlock<'a, 't>(
    pub(crate) *const TryStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TryStatementWithoutBlock<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn handler(self) -> &'t Option<Box<'a, CatchClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_HANDLER)
                as *const Option<Box<'a, CatchClause<'a>>>)
        }
    }

    #[inline]
    pub fn finalizer(self) -> &'t Option<Box<'a, BlockStatement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_FINALIZER)
                as *const Option<Box<'a, BlockStatement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TryStatementWithoutHandler<'a, 't>(
    pub(crate) *const TryStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TryStatementWithoutHandler<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn block(self) -> &'t Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_BLOCK)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn finalizer(self) -> &'t Option<Box<'a, BlockStatement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_FINALIZER)
                as *const Option<Box<'a, BlockStatement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TryStatementWithoutFinalizer<'a, 't>(
    pub(crate) *const TryStatement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TryStatementWithoutFinalizer<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn block(self) -> &'t Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_BLOCK)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn handler(self) -> &'t Option<Box<'a, CatchClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TRY_STATEMENT_HANDLER)
                as *const Option<Box<'a, CatchClause<'a>>>)
        }
    }
}

pub(crate) const OFFSET_CATCH_CLAUSE_SPAN: usize = offset_of!(CatchClause, span);
pub(crate) const OFFSET_CATCH_CLAUSE_PARAM: usize = offset_of!(CatchClause, param);
pub(crate) const OFFSET_CATCH_CLAUSE_BODY: usize = offset_of!(CatchClause, body);
pub(crate) const OFFSET_CATCH_CLAUSE_SCOPE_ID: usize = offset_of!(CatchClause, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CatchClauseWithoutParam<'a, 't>(
    pub(crate) *const CatchClause<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CatchClauseWithoutParam<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, BlockStatement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_BODY)
                as *const Box<'a, BlockStatement<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CatchClauseWithoutBody<'a, 't>(
    pub(crate) *const CatchClause<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CatchClauseWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn param(self) -> &'t Option<CatchParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_PARAM)
                as *const Option<CatchParameter<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CATCH_CLAUSE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CATCH_PARAMETER_SPAN: usize = offset_of!(CatchParameter, span);
pub(crate) const OFFSET_CATCH_PARAMETER_PATTERN: usize = offset_of!(CatchParameter, pattern);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct CatchParameterWithoutPattern<'a, 't>(
    pub(crate) *const CatchParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> CatchParameterWithoutPattern<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CATCH_PARAMETER_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_BINDING_PATTERN_KIND: usize = offset_of!(BindingPattern, kind);
pub(crate) const OFFSET_BINDING_PATTERN_TYPE_ANNOTATION: usize =
    offset_of!(BindingPattern, type_annotation);
pub(crate) const OFFSET_BINDING_PATTERN_OPTIONAL: usize = offset_of!(BindingPattern, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BindingPatternWithoutKind<'a, 't>(
    pub(crate) *const BindingPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BindingPatternWithoutKind<'a, 't> {
    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_OPTIONAL) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BindingPatternWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const BindingPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BindingPatternWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn kind(self) -> &'t BindingPatternKind<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_KIND)
                as *const BindingPatternKind<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PATTERN_OPTIONAL) as *const bool) }
    }
}

pub(crate) const OFFSET_ASSIGNMENT_PATTERN_SPAN: usize = offset_of!(AssignmentPattern, span);
pub(crate) const OFFSET_ASSIGNMENT_PATTERN_LEFT: usize = offset_of!(AssignmentPattern, left);
pub(crate) const OFFSET_ASSIGNMENT_PATTERN_RIGHT: usize = offset_of!(AssignmentPattern, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentPatternWithoutLeft<'a, 't>(
    pub(crate) *const AssignmentPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentPatternWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_RIGHT) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AssignmentPatternWithoutRight<'a, 't>(
    pub(crate) *const AssignmentPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AssignmentPatternWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ASSIGNMENT_PATTERN_LEFT)
                as *const BindingPattern<'a>)
        }
    }
}

pub(crate) const OFFSET_OBJECT_PATTERN_SPAN: usize = offset_of!(ObjectPattern, span);
pub(crate) const OFFSET_OBJECT_PATTERN_PROPERTIES: usize = offset_of!(ObjectPattern, properties);
pub(crate) const OFFSET_OBJECT_PATTERN_REST: usize = offset_of!(ObjectPattern, rest);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectPatternWithoutProperties<'a, 't>(
    pub(crate) *const ObjectPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectPatternWithoutProperties<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(self) -> &'t Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ObjectPatternWithoutRest<'a, 't>(
    pub(crate) *const ObjectPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ObjectPatternWithoutRest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn properties(self) -> &'t Vec<'a, BindingProperty<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_OBJECT_PATTERN_PROPERTIES)
                as *const Vec<'a, BindingProperty<'a>>)
        }
    }
}

pub(crate) const OFFSET_BINDING_PROPERTY_SPAN: usize = offset_of!(BindingProperty, span);
pub(crate) const OFFSET_BINDING_PROPERTY_KEY: usize = offset_of!(BindingProperty, key);
pub(crate) const OFFSET_BINDING_PROPERTY_VALUE: usize = offset_of!(BindingProperty, value);
pub(crate) const OFFSET_BINDING_PROPERTY_SHORTHAND: usize = offset_of!(BindingProperty, shorthand);
pub(crate) const OFFSET_BINDING_PROPERTY_COMPUTED: usize = offset_of!(BindingProperty, computed);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BindingPropertyWithoutKey<'a, 't>(
    pub(crate) *const BindingProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BindingPropertyWithoutKey<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(self) -> &'t BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_VALUE)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn shorthand(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_COMPUTED) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BindingPropertyWithoutValue<'a, 't>(
    pub(crate) *const BindingProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BindingPropertyWithoutValue<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn shorthand(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_SHORTHAND) as *const bool) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_PROPERTY_COMPUTED) as *const bool) }
    }
}

pub(crate) const OFFSET_ARRAY_PATTERN_SPAN: usize = offset_of!(ArrayPattern, span);
pub(crate) const OFFSET_ARRAY_PATTERN_ELEMENTS: usize = offset_of!(ArrayPattern, elements);
pub(crate) const OFFSET_ARRAY_PATTERN_REST: usize = offset_of!(ArrayPattern, rest);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrayPatternWithoutElements<'a, 't>(
    pub(crate) *const ArrayPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrayPatternWithoutElements<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn rest(self) -> &'t Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrayPatternWithoutRest<'a, 't>(
    pub(crate) *const ArrayPattern<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrayPatternWithoutRest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_SPAN) as *const Span) }
    }

    #[inline]
    pub fn elements(self) -> &'t Vec<'a, Option<BindingPattern<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARRAY_PATTERN_ELEMENTS)
                as *const Vec<'a, Option<BindingPattern<'a>>>)
        }
    }
}

pub(crate) const OFFSET_BINDING_REST_ELEMENT_SPAN: usize = offset_of!(BindingRestElement, span);
pub(crate) const OFFSET_BINDING_REST_ELEMENT_ARGUMENT: usize =
    offset_of!(BindingRestElement, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct BindingRestElementWithoutArgument<'a, 't>(
    pub(crate) *const BindingRestElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> BindingRestElementWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_BINDING_REST_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_FUNCTION_TYPE: usize = offset_of!(Function, r#type);
pub(crate) const OFFSET_FUNCTION_SPAN: usize = offset_of!(Function, span);
pub(crate) const OFFSET_FUNCTION_ID: usize = offset_of!(Function, id);
pub(crate) const OFFSET_FUNCTION_GENERATOR: usize = offset_of!(Function, generator);
pub(crate) const OFFSET_FUNCTION_ASYNC: usize = offset_of!(Function, r#async);
pub(crate) const OFFSET_FUNCTION_DECLARE: usize = offset_of!(Function, declare);
pub(crate) const OFFSET_FUNCTION_TYPE_PARAMETERS: usize = offset_of!(Function, type_parameters);
pub(crate) const OFFSET_FUNCTION_THIS_PARAM: usize = offset_of!(Function, this_param);
pub(crate) const OFFSET_FUNCTION_PARAMS: usize = offset_of!(Function, params);
pub(crate) const OFFSET_FUNCTION_RETURN_TYPE: usize = offset_of!(Function, return_type);
pub(crate) const OFFSET_FUNCTION_BODY: usize = offset_of!(Function, body);
pub(crate) const OFFSET_FUNCTION_SCOPE_ID: usize = offset_of!(Function, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutId<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutId<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutTypeParameters<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutThisParam<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutThisParam<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutParams<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutParams<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutReturnType<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutReturnType<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Option<Box<'a, FunctionBody<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY)
                as *const Option<Box<'a, FunctionBody<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionWithoutBody<'a, 't>(
    pub(crate) *const Function<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionWithoutBody<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t FunctionType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE) as *const FunctionType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_ID)
                as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn generator(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_GENERATOR) as *const bool) }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_ASYNC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_FORMAL_PARAMETERS_SPAN: usize = offset_of!(FormalParameters, span);
pub(crate) const OFFSET_FORMAL_PARAMETERS_KIND: usize = offset_of!(FormalParameters, kind);
pub(crate) const OFFSET_FORMAL_PARAMETERS_ITEMS: usize = offset_of!(FormalParameters, items);
pub(crate) const OFFSET_FORMAL_PARAMETERS_REST: usize = offset_of!(FormalParameters, rest);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FormalParametersWithoutItems<'a, 't>(
    pub(crate) *const FormalParameters<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FormalParametersWithoutItems<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t FormalParameterKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_KIND)
                as *const FormalParameterKind)
        }
    }

    #[inline]
    pub fn rest(self) -> &'t Option<Box<'a, BindingRestElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_REST)
                as *const Option<Box<'a, BindingRestElement<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FormalParametersWithoutRest<'a, 't>(
    pub(crate) *const FormalParameters<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FormalParametersWithoutRest<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn kind(self) -> &'t FormalParameterKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_KIND)
                as *const FormalParameterKind)
        }
    }

    #[inline]
    pub fn items(self) -> &'t Vec<'a, FormalParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETERS_ITEMS)
                as *const Vec<'a, FormalParameter<'a>>)
        }
    }
}

pub(crate) const OFFSET_FORMAL_PARAMETER_SPAN: usize = offset_of!(FormalParameter, span);
pub(crate) const OFFSET_FORMAL_PARAMETER_DECORATORS: usize =
    offset_of!(FormalParameter, decorators);
pub(crate) const OFFSET_FORMAL_PARAMETER_PATTERN: usize = offset_of!(FormalParameter, pattern);
pub(crate) const OFFSET_FORMAL_PARAMETER_ACCESSIBILITY: usize =
    offset_of!(FormalParameter, accessibility);
pub(crate) const OFFSET_FORMAL_PARAMETER_READONLY: usize = offset_of!(FormalParameter, readonly);
pub(crate) const OFFSET_FORMAL_PARAMETER_OVERRIDE: usize = offset_of!(FormalParameter, r#override);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FormalParameterWithoutDecorators<'a, 't>(
    pub(crate) *const FormalParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FormalParameterWithoutDecorators<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn pattern(self) -> &'t BindingPattern<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_PATTERN)
                as *const BindingPattern<'a>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_READONLY) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_OVERRIDE) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FormalParameterWithoutPattern<'a, 't>(
    pub(crate) *const FormalParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FormalParameterWithoutPattern<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_READONLY) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FORMAL_PARAMETER_OVERRIDE) as *const bool) }
    }
}

pub(crate) const OFFSET_FUNCTION_BODY_SPAN: usize = offset_of!(FunctionBody, span);
pub(crate) const OFFSET_FUNCTION_BODY_DIRECTIVES: usize = offset_of!(FunctionBody, directives);
pub(crate) const OFFSET_FUNCTION_BODY_STATEMENTS: usize = offset_of!(FunctionBody, statements);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionBodyWithoutDirectives<'a, 't>(
    pub(crate) *const FunctionBody<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionBodyWithoutDirectives<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn statements(self) -> &'t Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_STATEMENTS)
                as *const Vec<'a, Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct FunctionBodyWithoutStatements<'a, 't>(
    pub(crate) *const FunctionBody<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> FunctionBodyWithoutStatements<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn directives(self) -> &'t Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_FUNCTION_BODY_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }
}

pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN: usize =
    offset_of!(ArrowFunctionExpression, span);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION: usize =
    offset_of!(ArrowFunctionExpression, expression);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC: usize =
    offset_of!(ArrowFunctionExpression, r#async);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(ArrowFunctionExpression, type_parameters);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS: usize =
    offset_of!(ArrowFunctionExpression, params);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE: usize =
    offset_of!(ArrowFunctionExpression, return_type);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_BODY: usize =
    offset_of!(ArrowFunctionExpression, body);
pub(crate) const OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID: usize =
    offset_of!(ArrowFunctionExpression, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrowFunctionExpressionWithoutTypeParameters<'a, 't>(
    pub(crate) *const ArrowFunctionExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrowFunctionExpressionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrowFunctionExpressionWithoutParams<'a, 't>(
    pub(crate) *const ArrowFunctionExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrowFunctionExpressionWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrowFunctionExpressionWithoutReturnType<'a, 't>(
    pub(crate) *const ArrowFunctionExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrowFunctionExpressionWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, FunctionBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_BODY)
                as *const Box<'a, FunctionBody<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ArrowFunctionExpressionWithoutBody<'a, 't>(
    pub(crate) *const ArrowFunctionExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ArrowFunctionExpressionWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_EXPRESSION)
                as *const bool)
        }
    }

    #[inline]
    pub fn r#async(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_ASYNC) as *const bool)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ARROW_FUNCTION_EXPRESSION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_YIELD_EXPRESSION_SPAN: usize = offset_of!(YieldExpression, span);
pub(crate) const OFFSET_YIELD_EXPRESSION_DELEGATE: usize = offset_of!(YieldExpression, delegate);
pub(crate) const OFFSET_YIELD_EXPRESSION_ARGUMENT: usize = offset_of!(YieldExpression, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct YieldExpressionWithoutArgument<'a, 't>(
    pub(crate) *const YieldExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> YieldExpressionWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_YIELD_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn delegate(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_YIELD_EXPRESSION_DELEGATE) as *const bool) }
    }
}

pub(crate) const OFFSET_CLASS_TYPE: usize = offset_of!(Class, r#type);
pub(crate) const OFFSET_CLASS_SPAN: usize = offset_of!(Class, span);
pub(crate) const OFFSET_CLASS_DECORATORS: usize = offset_of!(Class, decorators);
pub(crate) const OFFSET_CLASS_ID: usize = offset_of!(Class, id);
pub(crate) const OFFSET_CLASS_TYPE_PARAMETERS: usize = offset_of!(Class, type_parameters);
pub(crate) const OFFSET_CLASS_SUPER_CLASS: usize = offset_of!(Class, super_class);
pub(crate) const OFFSET_CLASS_SUPER_TYPE_PARAMETERS: usize =
    offset_of!(Class, super_type_parameters);
pub(crate) const OFFSET_CLASS_IMPLEMENTS: usize = offset_of!(Class, implements);
pub(crate) const OFFSET_CLASS_BODY: usize = offset_of!(Class, body);
pub(crate) const OFFSET_CLASS_ABSTRACT: usize = offset_of!(Class, r#abstract);
pub(crate) const OFFSET_CLASS_DECLARE: usize = offset_of!(Class, declare);
pub(crate) const OFFSET_CLASS_SCOPE_ID: usize = offset_of!(Class, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutDecorators<'a, 't>(
    pub(crate) *const Class<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassWithoutDecorators<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutId<'a, 't>(pub(crate) *const Class<'a>, pub(crate) PhantomData<&'t ()>);

impl<'a, 't> ClassWithoutId<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutTypeParameters<'a, 't>(
    pub(crate) *const Class<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutSuperClass<'a, 't>(
    pub(crate) *const Class<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassWithoutSuperClass<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutSuperTypeParameters<'a, 't>(
    pub(crate) *const Class<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassWithoutSuperTypeParameters<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutImplements<'a, 't>(
    pub(crate) *const Class<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassWithoutImplements<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, ClassBody<'a>> {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY) as *const Box<'a, ClassBody<'a>>) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassWithoutBody<'a, 't>(pub(crate) *const Class<'a>, pub(crate) PhantomData<&'t ()>);

impl<'a, 't> ClassWithoutBody<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t ClassType {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE) as *const ClassType) }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_DECORATORS) as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn id(self) -> &'t Option<BindingIdentifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_ID) as *const Option<BindingIdentifier<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn super_class(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_CLASS) as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn super_type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SUPER_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }

    #[inline]
    pub fn implements(self) -> &'t Option<Vec<'a, TSClassImplements<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_IMPLEMENTS)
                as *const Option<Vec<'a, TSClassImplements<'a>>>)
        }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_CLASS_SCOPE_ID) as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_CLASS_BODY_SPAN: usize = offset_of!(ClassBody, span);
pub(crate) const OFFSET_CLASS_BODY_BODY: usize = offset_of!(ClassBody, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ClassBodyWithoutBody<'a, 't>(
    pub(crate) *const ClassBody<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ClassBodyWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_CLASS_BODY_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_METHOD_DEFINITION_TYPE: usize = offset_of!(MethodDefinition, r#type);
pub(crate) const OFFSET_METHOD_DEFINITION_SPAN: usize = offset_of!(MethodDefinition, span);
pub(crate) const OFFSET_METHOD_DEFINITION_DECORATORS: usize =
    offset_of!(MethodDefinition, decorators);
pub(crate) const OFFSET_METHOD_DEFINITION_KEY: usize = offset_of!(MethodDefinition, key);
pub(crate) const OFFSET_METHOD_DEFINITION_VALUE: usize = offset_of!(MethodDefinition, value);
pub(crate) const OFFSET_METHOD_DEFINITION_KIND: usize = offset_of!(MethodDefinition, kind);
pub(crate) const OFFSET_METHOD_DEFINITION_COMPUTED: usize = offset_of!(MethodDefinition, computed);
pub(crate) const OFFSET_METHOD_DEFINITION_STATIC: usize = offset_of!(MethodDefinition, r#static);
pub(crate) const OFFSET_METHOD_DEFINITION_OVERRIDE: usize =
    offset_of!(MethodDefinition, r#override);
pub(crate) const OFFSET_METHOD_DEFINITION_OPTIONAL: usize = offset_of!(MethodDefinition, optional);
pub(crate) const OFFSET_METHOD_DEFINITION_ACCESSIBILITY: usize =
    offset_of!(MethodDefinition, accessibility);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct MethodDefinitionWithoutDecorators<'a, 't>(
    pub(crate) *const MethodDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> MethodDefinitionWithoutDecorators<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Box<'a, Function<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_VALUE)
                as *const Box<'a, Function<'a>>)
        }
    }

    #[inline]
    pub fn kind(self) -> &'t MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct MethodDefinitionWithoutKey<'a, 't>(
    pub(crate) *const MethodDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> MethodDefinitionWithoutKey<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Box<'a, Function<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_VALUE)
                as *const Box<'a, Function<'a>>)
        }
    }

    #[inline]
    pub fn kind(self) -> &'t MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct MethodDefinitionWithoutValue<'a, 't>(
    pub(crate) *const MethodDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> MethodDefinitionWithoutValue<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t MethodDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_TYPE)
                as *const MethodDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn kind(self) -> &'t MethodDefinitionKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_KIND)
                as *const MethodDefinitionKind)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_METHOD_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

pub(crate) const OFFSET_PROPERTY_DEFINITION_TYPE: usize = offset_of!(PropertyDefinition, r#type);
pub(crate) const OFFSET_PROPERTY_DEFINITION_SPAN: usize = offset_of!(PropertyDefinition, span);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DECORATORS: usize =
    offset_of!(PropertyDefinition, decorators);
pub(crate) const OFFSET_PROPERTY_DEFINITION_KEY: usize = offset_of!(PropertyDefinition, key);
pub(crate) const OFFSET_PROPERTY_DEFINITION_VALUE: usize = offset_of!(PropertyDefinition, value);
pub(crate) const OFFSET_PROPERTY_DEFINITION_COMPUTED: usize =
    offset_of!(PropertyDefinition, computed);
pub(crate) const OFFSET_PROPERTY_DEFINITION_STATIC: usize =
    offset_of!(PropertyDefinition, r#static);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DECLARE: usize =
    offset_of!(PropertyDefinition, declare);
pub(crate) const OFFSET_PROPERTY_DEFINITION_OVERRIDE: usize =
    offset_of!(PropertyDefinition, r#override);
pub(crate) const OFFSET_PROPERTY_DEFINITION_OPTIONAL: usize =
    offset_of!(PropertyDefinition, optional);
pub(crate) const OFFSET_PROPERTY_DEFINITION_DEFINITE: usize =
    offset_of!(PropertyDefinition, definite);
pub(crate) const OFFSET_PROPERTY_DEFINITION_READONLY: usize =
    offset_of!(PropertyDefinition, readonly);
pub(crate) const OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION: usize =
    offset_of!(PropertyDefinition, type_annotation);
pub(crate) const OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY: usize =
    offset_of!(PropertyDefinition, accessibility);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PropertyDefinitionWithoutDecorators<'a, 't>(
    pub(crate) *const PropertyDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PropertyDefinitionWithoutDecorators<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PropertyDefinitionWithoutKey<'a, 't>(
    pub(crate) *const PropertyDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PropertyDefinitionWithoutKey<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PropertyDefinitionWithoutValue<'a, 't>(
    pub(crate) *const PropertyDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PropertyDefinitionWithoutValue<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct PropertyDefinitionWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const PropertyDefinition<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> PropertyDefinitionWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t PropertyDefinitionType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_TYPE)
                as *const PropertyDefinitionType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_STATIC) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn r#override(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OVERRIDE) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_READONLY) as *const bool) }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_PROPERTY_DEFINITION_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

pub(crate) const OFFSET_STATIC_BLOCK_SPAN: usize = offset_of!(StaticBlock, span);
pub(crate) const OFFSET_STATIC_BLOCK_BODY: usize = offset_of!(StaticBlock, body);
pub(crate) const OFFSET_STATIC_BLOCK_SCOPE_ID: usize = offset_of!(StaticBlock, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct StaticBlockWithoutBody<'a, 't>(
    pub(crate) *const StaticBlock<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> StaticBlockWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_STATIC_BLOCK_SPAN) as *const Span) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_STATIC_BLOCK_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_ACCESSOR_PROPERTY_TYPE: usize = offset_of!(AccessorProperty, r#type);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_SPAN: usize = offset_of!(AccessorProperty, span);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_DECORATORS: usize =
    offset_of!(AccessorProperty, decorators);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_KEY: usize = offset_of!(AccessorProperty, key);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_VALUE: usize = offset_of!(AccessorProperty, value);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_COMPUTED: usize = offset_of!(AccessorProperty, computed);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_STATIC: usize = offset_of!(AccessorProperty, r#static);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_DEFINITE: usize = offset_of!(AccessorProperty, definite);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_TYPE_ANNOTATION: usize =
    offset_of!(AccessorProperty, type_annotation);
pub(crate) const OFFSET_ACCESSOR_PROPERTY_ACCESSIBILITY: usize =
    offset_of!(AccessorProperty, accessibility);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AccessorPropertyWithoutDecorators<'a, 't>(
    pub(crate) *const AccessorProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AccessorPropertyWithoutDecorators<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AccessorPropertyWithoutKey<'a, 't>(
    pub(crate) *const AccessorProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AccessorPropertyWithoutKey<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AccessorPropertyWithoutValue<'a, 't>(
    pub(crate) *const AccessorProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AccessorPropertyWithoutValue<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct AccessorPropertyWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const AccessorProperty<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> AccessorPropertyWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn r#type(self) -> &'t AccessorPropertyType {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_TYPE)
                as *const AccessorPropertyType)
        }
    }

    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn decorators(self) -> &'t Vec<'a, Decorator<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DECORATORS)
                as *const Vec<'a, Decorator<'a>>)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn value(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_VALUE)
                as *const Option<Expression<'a>>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn r#static(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_STATIC) as *const bool) }
    }

    #[inline]
    pub fn definite(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_DEFINITE) as *const bool) }
    }

    #[inline]
    pub fn accessibility(self) -> &'t Option<TSAccessibility> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_ACCESSOR_PROPERTY_ACCESSIBILITY)
                as *const Option<TSAccessibility>)
        }
    }
}

pub(crate) const OFFSET_IMPORT_EXPRESSION_SPAN: usize = offset_of!(ImportExpression, span);
pub(crate) const OFFSET_IMPORT_EXPRESSION_SOURCE: usize = offset_of!(ImportExpression, source);
pub(crate) const OFFSET_IMPORT_EXPRESSION_ARGUMENTS: usize =
    offset_of!(ImportExpression, arguments);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportExpressionWithoutSource<'a, 't>(
    pub(crate) *const ImportExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportExpressionWithoutSource<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn arguments(self) -> &'t Vec<'a, Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_ARGUMENTS)
                as *const Vec<'a, Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportExpressionWithoutArguments<'a, 't>(
    pub(crate) *const ImportExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportExpressionWithoutArguments<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_EXPRESSION_SOURCE) as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_IMPORT_DECLARATION_SPAN: usize = offset_of!(ImportDeclaration, span);
pub(crate) const OFFSET_IMPORT_DECLARATION_SPECIFIERS: usize =
    offset_of!(ImportDeclaration, specifiers);
pub(crate) const OFFSET_IMPORT_DECLARATION_SOURCE: usize = offset_of!(ImportDeclaration, source);
pub(crate) const OFFSET_IMPORT_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ImportDeclaration, with_clause);
pub(crate) const OFFSET_IMPORT_DECLARATION_IMPORT_KIND: usize =
    offset_of!(ImportDeclaration, import_kind);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportDeclarationWithoutSpecifiers<'a, 't>(
    pub(crate) *const ImportDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportDeclarationWithoutSpecifiers<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(self) -> &'t StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportDeclarationWithoutSource<'a, 't>(
    pub(crate) *const ImportDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportDeclarationWithoutSource<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn specifiers(self) -> &'t Option<Vec<'a, ImportDeclarationSpecifier<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPECIFIERS)
                as *const Option<Vec<'a, ImportDeclarationSpecifier<'a>>>)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportDeclarationWithoutWithClause<'a, 't>(
    pub(crate) *const ImportDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportDeclarationWithoutWithClause<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn specifiers(self) -> &'t Option<Vec<'a, ImportDeclarationSpecifier<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SPECIFIERS)
                as *const Option<Vec<'a, ImportDeclarationSpecifier<'a>>>)
        }
    }

    #[inline]
    pub fn source(self) -> &'t StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_IMPORT_SPECIFIER_SPAN: usize = offset_of!(ImportSpecifier, span);
pub(crate) const OFFSET_IMPORT_SPECIFIER_IMPORTED: usize = offset_of!(ImportSpecifier, imported);
pub(crate) const OFFSET_IMPORT_SPECIFIER_LOCAL: usize = offset_of!(ImportSpecifier, local);
pub(crate) const OFFSET_IMPORT_SPECIFIER_IMPORT_KIND: usize =
    offset_of!(ImportSpecifier, import_kind);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportSpecifierWithoutImported<'a, 't>(
    pub(crate) *const ImportSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportSpecifierWithoutImported<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn local(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_LOCAL)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportSpecifierWithoutLocal<'a, 't>(
    pub(crate) *const ImportSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportSpecifierWithoutLocal<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn imported(self) -> &'t ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORTED)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_SPECIFIER_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_IMPORT_DEFAULT_SPECIFIER_SPAN: usize =
    offset_of!(ImportDefaultSpecifier, span);
pub(crate) const OFFSET_IMPORT_DEFAULT_SPECIFIER_LOCAL: usize =
    offset_of!(ImportDefaultSpecifier, local);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportDefaultSpecifierWithoutLocal<'a, 't>(
    pub(crate) *const ImportDefaultSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportDefaultSpecifierWithoutLocal<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_DEFAULT_SPECIFIER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_IMPORT_NAMESPACE_SPECIFIER_SPAN: usize =
    offset_of!(ImportNamespaceSpecifier, span);
pub(crate) const OFFSET_IMPORT_NAMESPACE_SPECIFIER_LOCAL: usize =
    offset_of!(ImportNamespaceSpecifier, local);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportNamespaceSpecifierWithoutLocal<'a, 't>(
    pub(crate) *const ImportNamespaceSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportNamespaceSpecifierWithoutLocal<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_NAMESPACE_SPECIFIER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_WITH_CLAUSE_SPAN: usize = offset_of!(WithClause, span);
pub(crate) const OFFSET_WITH_CLAUSE_ATTRIBUTES_KEYWORD: usize =
    offset_of!(WithClause, attributes_keyword);
pub(crate) const OFFSET_WITH_CLAUSE_WITH_ENTRIES: usize = offset_of!(WithClause, with_entries);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WithClauseWithoutAttributesKeyword<'a, 't>(
    pub(crate) *const WithClause<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WithClauseWithoutAttributesKeyword<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn with_entries(self) -> &'t Vec<'a, ImportAttribute<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_WITH_ENTRIES)
                as *const Vec<'a, ImportAttribute<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct WithClauseWithoutWithEntries<'a, 't>(
    pub(crate) *const WithClause<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> WithClauseWithoutWithEntries<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn attributes_keyword(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_WITH_CLAUSE_ATTRIBUTES_KEYWORD)
                as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_IMPORT_ATTRIBUTE_SPAN: usize = offset_of!(ImportAttribute, span);
pub(crate) const OFFSET_IMPORT_ATTRIBUTE_KEY: usize = offset_of!(ImportAttribute, key);
pub(crate) const OFFSET_IMPORT_ATTRIBUTE_VALUE: usize = offset_of!(ImportAttribute, value);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportAttributeWithoutKey<'a, 't>(
    pub(crate) *const ImportAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportAttributeWithoutKey<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(self) -> &'t StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_VALUE) as *const StringLiteral<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ImportAttributeWithoutValue<'a, 't>(
    pub(crate) *const ImportAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ImportAttributeWithoutValue<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t ImportAttributeKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_IMPORT_ATTRIBUTE_KEY)
                as *const ImportAttributeKey<'a>)
        }
    }
}

pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SPAN: usize =
    offset_of!(ExportNamedDeclaration, span);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION: usize =
    offset_of!(ExportNamedDeclaration, declaration);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS: usize =
    offset_of!(ExportNamedDeclaration, specifiers);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_SOURCE: usize =
    offset_of!(ExportNamedDeclaration, source);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND: usize =
    offset_of!(ExportNamedDeclaration, export_kind);
pub(crate) const OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ExportNamedDeclaration, with_clause);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportNamedDeclarationWithoutDeclaration<'a, 't>(
    pub(crate) *const ExportNamedDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportNamedDeclarationWithoutDeclaration<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn specifiers(self) -> &'t Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn source(self) -> &'t Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportNamedDeclarationWithoutSpecifiers<'a, 't>(
    pub(crate) *const ExportNamedDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportNamedDeclarationWithoutSpecifiers<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(self) -> &'t Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn source(self) -> &'t Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportNamedDeclarationWithoutSource<'a, 't>(
    pub(crate) *const ExportNamedDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportNamedDeclarationWithoutSource<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(self) -> &'t Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn specifiers(self) -> &'t Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportNamedDeclarationWithoutWithClause<'a, 't>(
    pub(crate) *const ExportNamedDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportNamedDeclarationWithoutWithClause<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(self) -> &'t Option<Declaration<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_DECLARATION)
                as *const Option<Declaration<'a>>)
        }
    }

    #[inline]
    pub fn specifiers(self) -> &'t Vec<'a, ExportSpecifier<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SPECIFIERS)
                as *const Vec<'a, ExportSpecifier<'a>>)
        }
    }

    #[inline]
    pub fn source(self) -> &'t Option<StringLiteral<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_SOURCE)
                as *const Option<StringLiteral<'a>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_NAMED_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN: usize =
    offset_of!(ExportDefaultDeclaration, span);
pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_DECLARATION: usize =
    offset_of!(ExportDefaultDeclaration, declaration);
pub(crate) const OFFSET_EXPORT_DEFAULT_DECLARATION_EXPORTED: usize =
    offset_of!(ExportDefaultDeclaration, exported);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportDefaultDeclarationWithoutDeclaration<'a, 't>(
    pub(crate) *const ExportDefaultDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportDefaultDeclarationWithoutDeclaration<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn exported(self) -> &'t ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_EXPORTED)
                as *const ModuleExportName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportDefaultDeclarationWithoutExported<'a, 't>(
    pub(crate) *const ExportDefaultDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportDefaultDeclarationWithoutExported<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn declaration(self) -> &'t ExportDefaultDeclarationKind<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_DEFAULT_DECLARATION_DECLARATION)
                as *const ExportDefaultDeclarationKind<'a>)
        }
    }
}

pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_SPAN: usize = offset_of!(ExportAllDeclaration, span);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_EXPORTED: usize =
    offset_of!(ExportAllDeclaration, exported);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_SOURCE: usize =
    offset_of!(ExportAllDeclaration, source);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE: usize =
    offset_of!(ExportAllDeclaration, with_clause);
pub(crate) const OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND: usize =
    offset_of!(ExportAllDeclaration, export_kind);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportAllDeclarationWithoutExported<'a, 't>(
    pub(crate) *const ExportAllDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportAllDeclarationWithoutExported<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn source(self) -> &'t StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportAllDeclarationWithoutSource<'a, 't>(
    pub(crate) *const ExportAllDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportAllDeclarationWithoutSource<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(self) -> &'t Option<ModuleExportName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORTED)
                as *const Option<ModuleExportName<'a>>)
        }
    }

    #[inline]
    pub fn with_clause(self) -> &'t Option<Box<'a, WithClause<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_WITH_CLAUSE)
                as *const Option<Box<'a, WithClause<'a>>>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportAllDeclarationWithoutWithClause<'a, 't>(
    pub(crate) *const ExportAllDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportAllDeclarationWithoutWithClause<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(self) -> &'t Option<ModuleExportName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORTED)
                as *const Option<ModuleExportName<'a>>)
        }
    }

    #[inline]
    pub fn source(self) -> &'t StringLiteral<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_SOURCE)
                as *const StringLiteral<'a>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_ALL_DECLARATION_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_EXPORT_SPECIFIER_SPAN: usize = offset_of!(ExportSpecifier, span);
pub(crate) const OFFSET_EXPORT_SPECIFIER_LOCAL: usize = offset_of!(ExportSpecifier, local);
pub(crate) const OFFSET_EXPORT_SPECIFIER_EXPORTED: usize = offset_of!(ExportSpecifier, exported);
pub(crate) const OFFSET_EXPORT_SPECIFIER_EXPORT_KIND: usize =
    offset_of!(ExportSpecifier, export_kind);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportSpecifierWithoutLocal<'a, 't>(
    pub(crate) *const ExportSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportSpecifierWithoutLocal<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn exported(self) -> &'t ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORTED)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct ExportSpecifierWithoutExported<'a, 't>(
    pub(crate) *const ExportSpecifier<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> ExportSpecifierWithoutExported<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn local(self) -> &'t ModuleExportName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_LOCAL)
                as *const ModuleExportName<'a>)
        }
    }

    #[inline]
    pub fn export_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_EXPORT_SPECIFIER_EXPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_JSX_ELEMENT_SPAN: usize = offset_of!(JSXElement, span);
pub(crate) const OFFSET_JSX_ELEMENT_OPENING_ELEMENT: usize =
    offset_of!(JSXElement, opening_element);
pub(crate) const OFFSET_JSX_ELEMENT_CLOSING_ELEMENT: usize =
    offset_of!(JSXElement, closing_element);
pub(crate) const OFFSET_JSX_ELEMENT_CHILDREN: usize = offset_of!(JSXElement, children);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXElementWithoutOpeningElement<'a, 't>(
    pub(crate) *const JSXElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXElementWithoutOpeningElement<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn closing_element(self) -> &'t Option<Box<'a, JSXClosingElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CLOSING_ELEMENT)
                as *const Option<Box<'a, JSXClosingElement<'a>>>)
        }
    }

    #[inline]
    pub fn children(self) -> &'t Vec<'a, JSXChild<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CHILDREN)
                as *const Vec<'a, JSXChild<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXElementWithoutClosingElement<'a, 't>(
    pub(crate) *const JSXElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXElementWithoutClosingElement<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_element(self) -> &'t Box<'a, JSXOpeningElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_OPENING_ELEMENT)
                as *const Box<'a, JSXOpeningElement<'a>>)
        }
    }

    #[inline]
    pub fn children(self) -> &'t Vec<'a, JSXChild<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CHILDREN)
                as *const Vec<'a, JSXChild<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXElementWithoutChildren<'a, 't>(
    pub(crate) *const JSXElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXElementWithoutChildren<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_element(self) -> &'t Box<'a, JSXOpeningElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_OPENING_ELEMENT)
                as *const Box<'a, JSXOpeningElement<'a>>)
        }
    }

    #[inline]
    pub fn closing_element(self) -> &'t Option<Box<'a, JSXClosingElement<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ELEMENT_CLOSING_ELEMENT)
                as *const Option<Box<'a, JSXClosingElement<'a>>>)
        }
    }
}

pub(crate) const OFFSET_JSX_OPENING_ELEMENT_SPAN: usize = offset_of!(JSXOpeningElement, span);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING: usize =
    offset_of!(JSXOpeningElement, self_closing);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_NAME: usize = offset_of!(JSXOpeningElement, name);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES: usize =
    offset_of!(JSXOpeningElement, attributes);
pub(crate) const OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS: usize =
    offset_of!(JSXOpeningElement, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXOpeningElementWithoutName<'a, 't>(
    pub(crate) *const JSXOpeningElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXOpeningElementWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn attributes(self) -> &'t Vec<'a, JSXAttributeItem<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES)
                as *const Vec<'a, JSXAttributeItem<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXOpeningElementWithoutAttributes<'a, 't>(
    pub(crate) *const JSXOpeningElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXOpeningElementWithoutAttributes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn name(self) -> &'t JSXElementName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_NAME)
                as *const JSXElementName<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXOpeningElementWithoutTypeParameters<'a, 't>(
    pub(crate) *const JSXOpeningElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXOpeningElementWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn self_closing(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_SELF_CLOSING) as *const bool)
        }
    }

    #[inline]
    pub fn name(self) -> &'t JSXElementName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_NAME)
                as *const JSXElementName<'a>)
        }
    }

    #[inline]
    pub fn attributes(self) -> &'t Vec<'a, JSXAttributeItem<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_OPENING_ELEMENT_ATTRIBUTES)
                as *const Vec<'a, JSXAttributeItem<'a>>)
        }
    }
}

pub(crate) const OFFSET_JSX_CLOSING_ELEMENT_SPAN: usize = offset_of!(JSXClosingElement, span);
pub(crate) const OFFSET_JSX_CLOSING_ELEMENT_NAME: usize = offset_of!(JSXClosingElement, name);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXClosingElementWithoutName<'a, 't>(
    pub(crate) *const JSXClosingElement<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXClosingElementWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_CLOSING_ELEMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_JSX_FRAGMENT_SPAN: usize = offset_of!(JSXFragment, span);
pub(crate) const OFFSET_JSX_FRAGMENT_OPENING_FRAGMENT: usize =
    offset_of!(JSXFragment, opening_fragment);
pub(crate) const OFFSET_JSX_FRAGMENT_CLOSING_FRAGMENT: usize =
    offset_of!(JSXFragment, closing_fragment);
pub(crate) const OFFSET_JSX_FRAGMENT_CHILDREN: usize = offset_of!(JSXFragment, children);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXFragmentWithoutChildren<'a, 't>(
    pub(crate) *const JSXFragment<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXFragmentWithoutChildren<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_SPAN) as *const Span) }
    }

    #[inline]
    pub fn opening_fragment(self) -> &'t JSXOpeningFragment {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_OPENING_FRAGMENT)
                as *const JSXOpeningFragment)
        }
    }

    #[inline]
    pub fn closing_fragment(self) -> &'t JSXClosingFragment {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_FRAGMENT_CLOSING_FRAGMENT)
                as *const JSXClosingFragment)
        }
    }
}

pub(crate) const OFFSET_JSX_NAMESPACED_NAME_SPAN: usize = offset_of!(JSXNamespacedName, span);
pub(crate) const OFFSET_JSX_NAMESPACED_NAME_NAMESPACE: usize =
    offset_of!(JSXNamespacedName, namespace);
pub(crate) const OFFSET_JSX_NAMESPACED_NAME_PROPERTY: usize =
    offset_of!(JSXNamespacedName, property);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXNamespacedNameWithoutNamespace<'a, 't>(
    pub(crate) *const JSXNamespacedName<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXNamespacedNameWithoutNamespace<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(self) -> &'t JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_PROPERTY)
                as *const JSXIdentifier<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXNamespacedNameWithoutProperty<'a, 't>(
    pub(crate) *const JSXNamespacedName<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXNamespacedNameWithoutProperty<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn namespace(self) -> &'t JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_NAMESPACED_NAME_NAMESPACE)
                as *const JSXIdentifier<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_SPAN: usize = offset_of!(JSXMemberExpression, span);
pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_OBJECT: usize =
    offset_of!(JSXMemberExpression, object);
pub(crate) const OFFSET_JSX_MEMBER_EXPRESSION_PROPERTY: usize =
    offset_of!(JSXMemberExpression, property);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXMemberExpressionWithoutObject<'a, 't>(
    pub(crate) *const JSXMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXMemberExpressionWithoutObject<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn property(self) -> &'t JSXIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_PROPERTY)
                as *const JSXIdentifier<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXMemberExpressionWithoutProperty<'a, 't>(
    pub(crate) *const JSXMemberExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXMemberExpressionWithoutProperty<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object(self) -> &'t JSXMemberExpressionObject<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_MEMBER_EXPRESSION_OBJECT)
                as *const JSXMemberExpressionObject<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_EXPRESSION_CONTAINER_SPAN: usize =
    offset_of!(JSXExpressionContainer, span);
pub(crate) const OFFSET_JSX_EXPRESSION_CONTAINER_EXPRESSION: usize =
    offset_of!(JSXExpressionContainer, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXExpressionContainerWithoutExpression<'a, 't>(
    pub(crate) *const JSXExpressionContainer<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXExpressionContainerWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_EXPRESSION_CONTAINER_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_JSX_ATTRIBUTE_SPAN: usize = offset_of!(JSXAttribute, span);
pub(crate) const OFFSET_JSX_ATTRIBUTE_NAME: usize = offset_of!(JSXAttribute, name);
pub(crate) const OFFSET_JSX_ATTRIBUTE_VALUE: usize = offset_of!(JSXAttribute, value);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXAttributeWithoutName<'a, 't>(
    pub(crate) *const JSXAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXAttributeWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(self) -> &'t Option<JSXAttributeValue<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_VALUE)
                as *const Option<JSXAttributeValue<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXAttributeWithoutValue<'a, 't>(
    pub(crate) *const JSXAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXAttributeWithoutValue<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(self) -> &'t JSXAttributeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JSX_ATTRIBUTE_NAME) as *const JSXAttributeName<'a>)
        }
    }
}

pub(crate) const OFFSET_JSX_SPREAD_ATTRIBUTE_SPAN: usize = offset_of!(JSXSpreadAttribute, span);
pub(crate) const OFFSET_JSX_SPREAD_ATTRIBUTE_ARGUMENT: usize =
    offset_of!(JSXSpreadAttribute, argument);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXSpreadAttributeWithoutArgument<'a, 't>(
    pub(crate) *const JSXSpreadAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXSpreadAttributeWithoutArgument<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_SPREAD_ATTRIBUTE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_JSX_SPREAD_CHILD_SPAN: usize = offset_of!(JSXSpreadChild, span);
pub(crate) const OFFSET_JSX_SPREAD_CHILD_EXPRESSION: usize = offset_of!(JSXSpreadChild, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSXSpreadChildWithoutExpression<'a, 't>(
    pub(crate) *const JSXSpreadChild<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSXSpreadChildWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JSX_SPREAD_CHILD_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_THIS_PARAMETER_SPAN: usize = offset_of!(TSThisParameter, span);
pub(crate) const OFFSET_TS_THIS_PARAMETER_THIS_SPAN: usize = offset_of!(TSThisParameter, this_span);
pub(crate) const OFFSET_TS_THIS_PARAMETER_TYPE_ANNOTATION: usize =
    offset_of!(TSThisParameter, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSThisParameterWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSThisParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSThisParameterWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this_span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_THIS_PARAMETER_THIS_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_ENUM_DECLARATION_SPAN: usize = offset_of!(TSEnumDeclaration, span);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_ID: usize = offset_of!(TSEnumDeclaration, id);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_MEMBERS: usize = offset_of!(TSEnumDeclaration, members);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_CONST: usize = offset_of!(TSEnumDeclaration, r#const);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_DECLARE: usize = offset_of!(TSEnumDeclaration, declare);
pub(crate) const OFFSET_TS_ENUM_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSEnumDeclaration, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSEnumDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSEnumDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSEnumDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn members(self) -> &'t Vec<'a, TSEnumMember<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_MEMBERS)
                as *const Vec<'a, TSEnumMember<'a>>)
        }
    }

    #[inline]
    pub fn r#const(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_CONST) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSEnumDeclarationWithoutMembers<'a, 't>(
    pub(crate) *const TSEnumDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSEnumDeclarationWithoutMembers<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn r#const(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_CONST) as *const bool) }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_DECLARE) as *const bool) }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_ENUM_MEMBER_SPAN: usize = offset_of!(TSEnumMember, span);
pub(crate) const OFFSET_TS_ENUM_MEMBER_ID: usize = offset_of!(TSEnumMember, id);
pub(crate) const OFFSET_TS_ENUM_MEMBER_INITIALIZER: usize = offset_of!(TSEnumMember, initializer);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSEnumMemberWithoutId<'a, 't>(
    pub(crate) *const TSEnumMember<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSEnumMemberWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn initializer(self) -> &'t Option<Expression<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_INITIALIZER)
                as *const Option<Expression<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSEnumMemberWithoutInitializer<'a, 't>(
    pub(crate) *const TSEnumMember<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSEnumMemberWithoutInitializer<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t TSEnumMemberName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_ENUM_MEMBER_ID) as *const TSEnumMemberName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ANNOTATION_SPAN: usize = offset_of!(TSTypeAnnotation, span);
pub(crate) const OFFSET_TS_TYPE_ANNOTATION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAnnotation, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAnnotationWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSTypeAnnotation<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAnnotationWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ANNOTATION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_LITERAL_TYPE_SPAN: usize = offset_of!(TSLiteralType, span);
pub(crate) const OFFSET_TS_LITERAL_TYPE_LITERAL: usize = offset_of!(TSLiteralType, literal);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSLiteralTypeWithoutLiteral<'a, 't>(
    pub(crate) *const TSLiteralType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSLiteralTypeWithoutLiteral<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_LITERAL_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_SPAN: usize = offset_of!(TSConditionalType, span);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE: usize =
    offset_of!(TSConditionalType, check_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE: usize =
    offset_of!(TSConditionalType, extends_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE: usize =
    offset_of!(TSConditionalType, true_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE: usize =
    offset_of!(TSConditionalType, false_type);
pub(crate) const OFFSET_TS_CONDITIONAL_TYPE_SCOPE_ID: usize =
    offset_of!(TSConditionalType, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConditionalTypeWithoutCheckType<'a, 't>(
    pub(crate) *const TSConditionalType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConditionalTypeWithoutCheckType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn extends_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConditionalTypeWithoutExtendsType<'a, 't>(
    pub(crate) *const TSConditionalType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConditionalTypeWithoutExtendsType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConditionalTypeWithoutTrueType<'a, 't>(
    pub(crate) *const TSConditionalType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConditionalTypeWithoutTrueType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn extends_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn false_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_FALSE_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConditionalTypeWithoutFalseType<'a, 't>(
    pub(crate) *const TSConditionalType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConditionalTypeWithoutFalseType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn check_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_CHECK_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn extends_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_EXTENDS_TYPE)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn true_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_TRUE_TYPE) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONDITIONAL_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_UNION_TYPE_SPAN: usize = offset_of!(TSUnionType, span);
pub(crate) const OFFSET_TS_UNION_TYPE_TYPES: usize = offset_of!(TSUnionType, types);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSUnionTypeWithoutTypes<'a, 't>(
    pub(crate) *const TSUnionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSUnionTypeWithoutTypes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_UNION_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INTERSECTION_TYPE_SPAN: usize = offset_of!(TSIntersectionType, span);
pub(crate) const OFFSET_TS_INTERSECTION_TYPE_TYPES: usize = offset_of!(TSIntersectionType, types);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIntersectionTypeWithoutTypes<'a, 't>(
    pub(crate) *const TSIntersectionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIntersectionTypeWithoutTypes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERSECTION_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_PARENTHESIZED_TYPE_SPAN: usize = offset_of!(TSParenthesizedType, span);
pub(crate) const OFFSET_TS_PARENTHESIZED_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSParenthesizedType, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSParenthesizedTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSParenthesizedType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSParenthesizedTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_PARENTHESIZED_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_OPERATOR_SPAN: usize = offset_of!(TSTypeOperator, span);
pub(crate) const OFFSET_TS_TYPE_OPERATOR_OPERATOR: usize = offset_of!(TSTypeOperator, operator);
pub(crate) const OFFSET_TS_TYPE_OPERATOR_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeOperator, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeOperatorWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSTypeOperator<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeOperatorWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_OPERATOR_SPAN) as *const Span) }
    }

    #[inline]
    pub fn operator(self) -> &'t TSTypeOperatorOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_OPERATOR_OPERATOR)
                as *const TSTypeOperatorOperator)
        }
    }
}

pub(crate) const OFFSET_TS_ARRAY_TYPE_SPAN: usize = offset_of!(TSArrayType, span);
pub(crate) const OFFSET_TS_ARRAY_TYPE_ELEMENT_TYPE: usize = offset_of!(TSArrayType, element_type);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSArrayTypeWithoutElementType<'a, 't>(
    pub(crate) *const TSArrayType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSArrayTypeWithoutElementType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_ARRAY_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN: usize = offset_of!(TSIndexedAccessType, span);
pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_OBJECT_TYPE: usize =
    offset_of!(TSIndexedAccessType, object_type);
pub(crate) const OFFSET_TS_INDEXED_ACCESS_TYPE_INDEX_TYPE: usize =
    offset_of!(TSIndexedAccessType, index_type);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIndexedAccessTypeWithoutObjectType<'a, 't>(
    pub(crate) *const TSIndexedAccessType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIndexedAccessTypeWithoutObjectType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn index_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_INDEX_TYPE)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIndexedAccessTypeWithoutIndexType<'a, 't>(
    pub(crate) *const TSIndexedAccessType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIndexedAccessTypeWithoutIndexType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn object_type(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEXED_ACCESS_TYPE_OBJECT_TYPE)
                as *const TSType<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TUPLE_TYPE_SPAN: usize = offset_of!(TSTupleType, span);
pub(crate) const OFFSET_TS_TUPLE_TYPE_ELEMENT_TYPES: usize = offset_of!(TSTupleType, element_types);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTupleTypeWithoutElementTypes<'a, 't>(
    pub(crate) *const TSTupleType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTupleTypeWithoutElementTypes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TUPLE_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN: usize = offset_of!(TSNamedTupleMember, span);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_ELEMENT_TYPE: usize =
    offset_of!(TSNamedTupleMember, element_type);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_LABEL: usize = offset_of!(TSNamedTupleMember, label);
pub(crate) const OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL: usize =
    offset_of!(TSNamedTupleMember, optional);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSNamedTupleMemberWithoutElementType<'a, 't>(
    pub(crate) *const TSNamedTupleMember<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSNamedTupleMemberWithoutElementType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn label(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_LABEL)
                as *const IdentifierName<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL) as *const bool)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSNamedTupleMemberWithoutLabel<'a, 't>(
    pub(crate) *const TSNamedTupleMember<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSNamedTupleMemberWithoutLabel<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn element_type(self) -> &'t TSTupleElement<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_ELEMENT_TYPE)
                as *const TSTupleElement<'a>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMED_TUPLE_MEMBER_OPTIONAL) as *const bool)
        }
    }
}

pub(crate) const OFFSET_TS_OPTIONAL_TYPE_SPAN: usize = offset_of!(TSOptionalType, span);
pub(crate) const OFFSET_TS_OPTIONAL_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSOptionalType, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSOptionalTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSOptionalType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSOptionalTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_OPTIONAL_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_REST_TYPE_SPAN: usize = offset_of!(TSRestType, span);
pub(crate) const OFFSET_TS_REST_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSRestType, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSRestTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSRestType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSRestTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_REST_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_REFERENCE_SPAN: usize = offset_of!(TSTypeReference, span);
pub(crate) const OFFSET_TS_TYPE_REFERENCE_TYPE_NAME: usize = offset_of!(TSTypeReference, type_name);
pub(crate) const OFFSET_TS_TYPE_REFERENCE_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeReference, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeReferenceWithoutTypeName<'a, 't>(
    pub(crate) *const TSTypeReference<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeReferenceWithoutTypeName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeReferenceWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSTypeReference<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeReferenceWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_name(self) -> &'t TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_REFERENCE_TYPE_NAME)
                as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_QUALIFIED_NAME_SPAN: usize = offset_of!(TSQualifiedName, span);
pub(crate) const OFFSET_TS_QUALIFIED_NAME_LEFT: usize = offset_of!(TSQualifiedName, left);
pub(crate) const OFFSET_TS_QUALIFIED_NAME_RIGHT: usize = offset_of!(TSQualifiedName, right);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSQualifiedNameWithoutLeft<'a, 't>(
    pub(crate) *const TSQualifiedName<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSQualifiedNameWithoutLeft<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn right(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_RIGHT)
                as *const IdentifierName<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSQualifiedNameWithoutRight<'a, 't>(
    pub(crate) *const TSQualifiedName<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSQualifiedNameWithoutRight<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn left(self) -> &'t TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_QUALIFIED_NAME_LEFT) as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_SPAN: usize =
    offset_of!(TSTypeParameterInstantiation, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_PARAMS: usize =
    offset_of!(TSTypeParameterInstantiation, params);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeParameterInstantiationWithoutParams<'a, 't>(
    pub(crate) *const TSTypeParameterInstantiation<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeParameterInstantiationWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_INSTANTIATION_SPAN)
                as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_SPAN: usize = offset_of!(TSTypeParameter, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_NAME: usize = offset_of!(TSTypeParameter, name);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_CONSTRAINT: usize =
    offset_of!(TSTypeParameter, constraint);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_DEFAULT: usize = offset_of!(TSTypeParameter, default);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_IN: usize = offset_of!(TSTypeParameter, r#in);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_OUT: usize = offset_of!(TSTypeParameter, out);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_CONST: usize = offset_of!(TSTypeParameter, r#const);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeParameterWithoutName<'a, 't>(
    pub(crate) *const TSTypeParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeParameterWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn constraint(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONSTRAINT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn default(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DEFAULT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeParameterWithoutConstraint<'a, 't>(
    pub(crate) *const TSTypeParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeParameterWithoutConstraint<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_NAME)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn default(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DEFAULT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeParameterWithoutDefault<'a, 't>(
    pub(crate) *const TSTypeParameter<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeParameterWithoutDefault<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_NAME)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn constraint(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONSTRAINT)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn r#in(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_IN) as *const bool) }
    }

    #[inline]
    pub fn out(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_OUT) as *const bool) }
    }

    #[inline]
    pub fn r#const(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_CONST) as *const bool) }
    }
}

pub(crate) const OFFSET_TS_TYPE_PARAMETER_DECLARATION_SPAN: usize =
    offset_of!(TSTypeParameterDeclaration, span);
pub(crate) const OFFSET_TS_TYPE_PARAMETER_DECLARATION_PARAMS: usize =
    offset_of!(TSTypeParameterDeclaration, params);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeParameterDeclarationWithoutParams<'a, 't>(
    pub(crate) *const TSTypeParameterDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeParameterDeclarationWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PARAMETER_DECLARATION_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN: usize =
    offset_of!(TSTypeAliasDeclaration, span);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_ID: usize =
    offset_of!(TSTypeAliasDeclaration, id);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeAliasDeclaration, type_parameters);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAliasDeclaration, type_annotation);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_DECLARE: usize =
    offset_of!(TSTypeAliasDeclaration, declare);
pub(crate) const OFFSET_TS_TYPE_ALIAS_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSTypeAliasDeclaration, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAliasDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSTypeAliasDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAliasDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAliasDeclarationWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSTypeAliasDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAliasDeclarationWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAliasDeclarationWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSTypeAliasDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAliasDeclarationWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ALIAS_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_SPAN: usize = offset_of!(TSClassImplements, span);
pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_EXPRESSION: usize =
    offset_of!(TSClassImplements, expression);
pub(crate) const OFFSET_TS_CLASS_IMPLEMENTS_TYPE_PARAMETERS: usize =
    offset_of!(TSClassImplements, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSClassImplementsWithoutExpression<'a, 't>(
    pub(crate) *const TSClassImplements<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSClassImplementsWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSClassImplementsWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSClassImplements<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSClassImplementsWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(self) -> &'t TSTypeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CLASS_IMPLEMENTS_EXPRESSION)
                as *const TSTypeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_SPAN: usize =
    offset_of!(TSInterfaceDeclaration, span);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_ID: usize = offset_of!(TSInterfaceDeclaration, id);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_EXTENDS: usize =
    offset_of!(TSInterfaceDeclaration, extends);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSInterfaceDeclaration, type_parameters);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_BODY: usize =
    offset_of!(TSInterfaceDeclaration, body);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_DECLARE: usize =
    offset_of!(TSInterfaceDeclaration, declare);
pub(crate) const OFFSET_TS_INTERFACE_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSInterfaceDeclaration, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSInterfaceDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn extends(self) -> &'t Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceDeclarationWithoutExtends<'a, 't>(
    pub(crate) *const TSInterfaceDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceDeclarationWithoutExtends<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceDeclarationWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSInterfaceDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceDeclarationWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn extends(self) -> &'t Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn body(self) -> &'t Box<'a, TSInterfaceBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_BODY)
                as *const Box<'a, TSInterfaceBody<'a>>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceDeclarationWithoutBody<'a, 't>(
    pub(crate) *const TSInterfaceDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceDeclarationWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn extends(self) -> &'t Option<Vec<'a, TSInterfaceHeritage<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_EXTENDS)
                as *const Option<Vec<'a, TSInterfaceHeritage<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_BODY_SPAN: usize = offset_of!(TSInterfaceBody, span);
pub(crate) const OFFSET_TS_INTERFACE_BODY_BODY: usize = offset_of!(TSInterfaceBody, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceBodyWithoutBody<'a, 't>(
    pub(crate) *const TSInterfaceBody<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceBodyWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_BODY_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_SPAN: usize = offset_of!(TSPropertySignature, span);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED: usize =
    offset_of!(TSPropertySignature, computed);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL: usize =
    offset_of!(TSPropertySignature, optional);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_READONLY: usize =
    offset_of!(TSPropertySignature, readonly);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_KEY: usize = offset_of!(TSPropertySignature, key);
pub(crate) const OFFSET_TS_PROPERTY_SIGNATURE_TYPE_ANNOTATION: usize =
    offset_of!(TSPropertySignature, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSPropertySignatureWithoutKey<'a, 't>(
    pub(crate) *const TSPropertySignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSPropertySignatureWithoutKey<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED) as *const bool)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL) as *const bool)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_READONLY) as *const bool)
        }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSPropertySignatureWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSPropertySignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSPropertySignatureWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_COMPUTED) as *const bool)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_OPTIONAL) as *const bool)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_READONLY) as *const bool)
        }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_PROPERTY_SIGNATURE_KEY)
                as *const PropertyKey<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INDEX_SIGNATURE_SPAN: usize = offset_of!(TSIndexSignature, span);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_PARAMETERS: usize =
    offset_of!(TSIndexSignature, parameters);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_TYPE_ANNOTATION: usize =
    offset_of!(TSIndexSignature, type_annotation);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_READONLY: usize = offset_of!(TSIndexSignature, readonly);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIndexSignatureWithoutParameters<'a, 't>(
    pub(crate) *const TSIndexSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIndexSignatureWithoutParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_TYPE_ANNOTATION)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_READONLY) as *const bool) }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIndexSignatureWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSIndexSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIndexSignatureWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn parameters(self) -> &'t Vec<'a, TSIndexSignatureName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_PARAMETERS)
                as *const Vec<'a, TSIndexSignatureName<'a>>)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_READONLY) as *const bool) }
    }
}

pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN: usize =
    offset_of!(TSCallSignatureDeclaration, span);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSCallSignatureDeclaration, type_parameters);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM: usize =
    offset_of!(TSCallSignatureDeclaration, this_param);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS: usize =
    offset_of!(TSCallSignatureDeclaration, params);
pub(crate) const OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE: usize =
    offset_of!(TSCallSignatureDeclaration, return_type);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSCallSignatureDeclarationWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSCallSignatureDeclarationWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSCallSignatureDeclarationWithoutThisParam<'a, 't>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSCallSignatureDeclarationWithoutThisParam<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSCallSignatureDeclarationWithoutParams<'a, 't>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSCallSignatureDeclarationWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSCallSignatureDeclarationWithoutReturnType<'a, 't>(
    pub(crate) *const TSCallSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSCallSignatureDeclarationWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<TSThisParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_THIS_PARAM)
                as *const Option<TSThisParameter<'a>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CALL_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_METHOD_SIGNATURE_SPAN: usize = offset_of!(TSMethodSignature, span);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_KEY: usize = offset_of!(TSMethodSignature, key);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_COMPUTED: usize =
    offset_of!(TSMethodSignature, computed);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_OPTIONAL: usize =
    offset_of!(TSMethodSignature, optional);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_KIND: usize = offset_of!(TSMethodSignature, kind);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS: usize =
    offset_of!(TSMethodSignature, type_parameters);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM: usize =
    offset_of!(TSMethodSignature, this_param);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_PARAMS: usize = offset_of!(TSMethodSignature, params);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE: usize =
    offset_of!(TSMethodSignature, return_type);
pub(crate) const OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID: usize =
    offset_of!(TSMethodSignature, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMethodSignatureWithoutKey<'a, 't>(
    pub(crate) *const TSMethodSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMethodSignatureWithoutKey<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(self) -> &'t TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMethodSignatureWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSMethodSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMethodSignatureWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(self) -> &'t TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMethodSignatureWithoutThisParam<'a, 't>(
    pub(crate) *const TSMethodSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMethodSignatureWithoutThisParam<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(self) -> &'t TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMethodSignatureWithoutParams<'a, 't>(
    pub(crate) *const TSMethodSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMethodSignatureWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(self) -> &'t TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMethodSignatureWithoutReturnType<'a, 't>(
    pub(crate) *const TSMethodSignature<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMethodSignatureWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn key(self) -> &'t PropertyKey<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KEY) as *const PropertyKey<'a>)
        }
    }

    #[inline]
    pub fn computed(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_COMPUTED) as *const bool) }
    }

    #[inline]
    pub fn optional(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_OPTIONAL) as *const bool) }
    }

    #[inline]
    pub fn kind(self) -> &'t TSMethodSignatureKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_KIND)
                as *const TSMethodSignatureKind)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_METHOD_SIGNATURE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN: usize =
    offset_of!(TSConstructSignatureDeclaration, span);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS: usize =
    offset_of!(TSConstructSignatureDeclaration, type_parameters);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS: usize =
    offset_of!(TSConstructSignatureDeclaration, params);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE: usize =
    offset_of!(TSConstructSignatureDeclaration, return_type);
pub(crate) const OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSConstructSignatureDeclaration, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructSignatureDeclarationWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructSignatureDeclarationWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructSignatureDeclarationWithoutParams<'a, 't>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructSignatureDeclarationWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_RETURN_TYPE)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructSignatureDeclarationWithoutReturnType<'a, 't>(
    pub(crate) *const TSConstructSignatureDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructSignatureDeclarationWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SPAN)
                as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCT_SIGNATURE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_SPAN: usize =
    offset_of!(TSIndexSignatureName, span);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_NAME: usize =
    offset_of!(TSIndexSignatureName, name);
pub(crate) const OFFSET_TS_INDEX_SIGNATURE_NAME_TYPE_ANNOTATION: usize =
    offset_of!(TSIndexSignatureName, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSIndexSignatureNameWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSIndexSignatureName<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSIndexSignatureNameWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_NAME_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(self) -> &'t Atom<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INDEX_SIGNATURE_NAME_NAME) as *const Atom<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_SPAN: usize = offset_of!(TSInterfaceHeritage, span);
pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_EXPRESSION: usize =
    offset_of!(TSInterfaceHeritage, expression);
pub(crate) const OFFSET_TS_INTERFACE_HERITAGE_TYPE_PARAMETERS: usize =
    offset_of!(TSInterfaceHeritage, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceHeritageWithoutExpression<'a, 't>(
    pub(crate) *const TSInterfaceHeritage<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceHeritageWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInterfaceHeritageWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSInterfaceHeritage<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInterfaceHeritageWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INTERFACE_HERITAGE_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_PREDICATE_SPAN: usize = offset_of!(TSTypePredicate, span);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_PARAMETER_NAME: usize =
    offset_of!(TSTypePredicate, parameter_name);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_ASSERTS: usize = offset_of!(TSTypePredicate, asserts);
pub(crate) const OFFSET_TS_TYPE_PREDICATE_TYPE_ANNOTATION: usize =
    offset_of!(TSTypePredicate, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypePredicateWithoutParameterName<'a, 't>(
    pub(crate) *const TSTypePredicate<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypePredicateWithoutParameterName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn asserts(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_ASSERTS) as *const bool) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<Box<'a, TSTypeAnnotation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_TYPE_ANNOTATION)
                as *const Option<Box<'a, TSTypeAnnotation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypePredicateWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSTypePredicate<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypePredicateWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn parameter_name(self) -> &'t TSTypePredicateName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_PARAMETER_NAME)
                as *const TSTypePredicateName<'a>)
        }
    }

    #[inline]
    pub fn asserts(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_PREDICATE_ASSERTS) as *const bool) }
    }
}

pub(crate) const OFFSET_TS_MODULE_DECLARATION_SPAN: usize = offset_of!(TSModuleDeclaration, span);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_ID: usize = offset_of!(TSModuleDeclaration, id);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_BODY: usize = offset_of!(TSModuleDeclaration, body);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_KIND: usize = offset_of!(TSModuleDeclaration, kind);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_DECLARE: usize =
    offset_of!(TSModuleDeclaration, declare);
pub(crate) const OFFSET_TS_MODULE_DECLARATION_SCOPE_ID: usize =
    offset_of!(TSModuleDeclaration, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSModuleDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSModuleDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSModuleDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Option<TSModuleDeclarationBody<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_BODY)
                as *const Option<TSModuleDeclarationBody<'a>>)
        }
    }

    #[inline]
    pub fn kind(self) -> &'t TSModuleDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_KIND)
                as *const TSModuleDeclarationKind)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSModuleDeclarationWithoutBody<'a, 't>(
    pub(crate) *const TSModuleDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSModuleDeclarationWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn id(self) -> &'t TSModuleDeclarationName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_ID)
                as *const TSModuleDeclarationName<'a>)
        }
    }

    #[inline]
    pub fn kind(self) -> &'t TSModuleDeclarationKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_KIND)
                as *const TSModuleDeclarationKind)
        }
    }

    #[inline]
    pub fn declare(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_DECLARE) as *const bool)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_DECLARATION_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_MODULE_BLOCK_SPAN: usize = offset_of!(TSModuleBlock, span);
pub(crate) const OFFSET_TS_MODULE_BLOCK_DIRECTIVES: usize = offset_of!(TSModuleBlock, directives);
pub(crate) const OFFSET_TS_MODULE_BLOCK_BODY: usize = offset_of!(TSModuleBlock, body);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSModuleBlockWithoutDirectives<'a, 't>(
    pub(crate) *const TSModuleBlock<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSModuleBlockWithoutDirectives<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_BLOCK_SPAN) as *const Span) }
    }

    #[inline]
    pub fn body(self) -> &'t Vec<'a, Statement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_BLOCK_BODY)
                as *const Vec<'a, Statement<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSModuleBlockWithoutBody<'a, 't>(
    pub(crate) *const TSModuleBlock<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSModuleBlockWithoutBody<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MODULE_BLOCK_SPAN) as *const Span) }
    }

    #[inline]
    pub fn directives(self) -> &'t Vec<'a, Directive<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MODULE_BLOCK_DIRECTIVES)
                as *const Vec<'a, Directive<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_LITERAL_SPAN: usize = offset_of!(TSTypeLiteral, span);
pub(crate) const OFFSET_TS_TYPE_LITERAL_MEMBERS: usize = offset_of!(TSTypeLiteral, members);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeLiteralWithoutMembers<'a, 't>(
    pub(crate) *const TSTypeLiteral<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeLiteralWithoutMembers<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_LITERAL_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_INFER_TYPE_SPAN: usize = offset_of!(TSInferType, span);
pub(crate) const OFFSET_TS_INFER_TYPE_TYPE_PARAMETER: usize =
    offset_of!(TSInferType, type_parameter);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInferTypeWithoutTypeParameter<'a, 't>(
    pub(crate) *const TSInferType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInferTypeWithoutTypeParameter<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_INFER_TYPE_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_TYPE_QUERY_SPAN: usize = offset_of!(TSTypeQuery, span);
pub(crate) const OFFSET_TS_TYPE_QUERY_EXPR_NAME: usize = offset_of!(TSTypeQuery, expr_name);
pub(crate) const OFFSET_TS_TYPE_QUERY_TYPE_PARAMETERS: usize =
    offset_of!(TSTypeQuery, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeQueryWithoutExprName<'a, 't>(
    pub(crate) *const TSTypeQuery<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeQueryWithoutExprName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeQueryWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSTypeQuery<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeQueryWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expr_name(self) -> &'t TSTypeQueryExprName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_QUERY_EXPR_NAME)
                as *const TSTypeQueryExprName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_TYPE_SPAN: usize = offset_of!(TSImportType, span);
pub(crate) const OFFSET_TS_IMPORT_TYPE_IS_TYPE_OF: usize = offset_of!(TSImportType, is_type_of);
pub(crate) const OFFSET_TS_IMPORT_TYPE_PARAMETER: usize = offset_of!(TSImportType, parameter);
pub(crate) const OFFSET_TS_IMPORT_TYPE_QUALIFIER: usize = offset_of!(TSImportType, qualifier);
pub(crate) const OFFSET_TS_IMPORT_TYPE_ATTRIBUTES: usize = offset_of!(TSImportType, attributes);
pub(crate) const OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSImportType, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportTypeWithoutParameter<'a, 't>(
    pub(crate) *const TSImportType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportTypeWithoutParameter<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn is_type_of(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_IS_TYPE_OF) as *const bool) }
    }

    #[inline]
    pub fn qualifier(self) -> &'t Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn attributes(self) -> &'t Option<Box<'a, TSImportAttributes<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<Box<'a, TSImportAttributes<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportTypeWithoutQualifier<'a, 't>(
    pub(crate) *const TSImportType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportTypeWithoutQualifier<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn is_type_of(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_IS_TYPE_OF) as *const bool) }
    }

    #[inline]
    pub fn parameter(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_PARAMETER) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn attributes(self) -> &'t Option<Box<'a, TSImportAttributes<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<Box<'a, TSImportAttributes<'a>>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportTypeWithoutAttributes<'a, 't>(
    pub(crate) *const TSImportType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportTypeWithoutAttributes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn is_type_of(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_IS_TYPE_OF) as *const bool) }
    }

    #[inline]
    pub fn parameter(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_PARAMETER) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn qualifier(self) -> &'t Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterInstantiation<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterInstantiation<'a>>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportTypeWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSImportType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportTypeWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn is_type_of(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_IS_TYPE_OF) as *const bool) }
    }

    #[inline]
    pub fn parameter(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_PARAMETER) as *const TSType<'a>)
        }
    }

    #[inline]
    pub fn qualifier(self) -> &'t Option<TSTypeName<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_QUALIFIER)
                as *const Option<TSTypeName<'a>>)
        }
    }

    #[inline]
    pub fn attributes(self) -> &'t Option<Box<'a, TSImportAttributes<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_TYPE_ATTRIBUTES)
                as *const Option<Box<'a, TSImportAttributes<'a>>>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTES_SPAN: usize = offset_of!(TSImportAttributes, span);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTES_ATTRIBUTES_KEYWORD: usize =
    offset_of!(TSImportAttributes, attributes_keyword);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTES_ELEMENTS: usize =
    offset_of!(TSImportAttributes, elements);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportAttributesWithoutAttributesKeyword<'a, 't>(
    pub(crate) *const TSImportAttributes<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportAttributesWithoutAttributesKeyword<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTES_SPAN) as *const Span) }
    }

    #[inline]
    pub fn elements(self) -> &'t Vec<'a, TSImportAttribute<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTES_ELEMENTS)
                as *const Vec<'a, TSImportAttribute<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportAttributesWithoutElements<'a, 't>(
    pub(crate) *const TSImportAttributes<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportAttributesWithoutElements<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTES_SPAN) as *const Span) }
    }

    #[inline]
    pub fn attributes_keyword(self) -> &'t IdentifierName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTES_ATTRIBUTES_KEYWORD)
                as *const IdentifierName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_SPAN: usize = offset_of!(TSImportAttribute, span);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_NAME: usize = offset_of!(TSImportAttribute, name);
pub(crate) const OFFSET_TS_IMPORT_ATTRIBUTE_VALUE: usize = offset_of!(TSImportAttribute, value);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportAttributeWithoutName<'a, 't>(
    pub(crate) *const TSImportAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportAttributeWithoutName<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn value(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_VALUE) as *const Expression<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportAttributeWithoutValue<'a, 't>(
    pub(crate) *const TSImportAttribute<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportAttributeWithoutValue<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name(self) -> &'t TSImportAttributeName<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_ATTRIBUTE_NAME)
                as *const TSImportAttributeName<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_FUNCTION_TYPE_SPAN: usize = offset_of!(TSFunctionType, span);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSFunctionType, type_parameters);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_THIS_PARAM: usize = offset_of!(TSFunctionType, this_param);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_PARAMS: usize = offset_of!(TSFunctionType, params);
pub(crate) const OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE: usize =
    offset_of!(TSFunctionType, return_type);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSFunctionTypeWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSFunctionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSFunctionTypeWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSFunctionTypeWithoutThisParam<'a, 't>(
    pub(crate) *const TSFunctionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSFunctionTypeWithoutThisParam<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSFunctionTypeWithoutParams<'a, 't>(
    pub(crate) *const TSFunctionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSFunctionTypeWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSFunctionTypeWithoutReturnType<'a, 't>(
    pub(crate) *const TSFunctionType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSFunctionTypeWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn this_param(self) -> &'t Option<Box<'a, TSThisParameter<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_THIS_PARAM)
                as *const Option<Box<'a, TSThisParameter<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_FUNCTION_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_SPAN: usize = offset_of!(TSConstructorType, span);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT: usize =
    offset_of!(TSConstructorType, r#abstract);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS: usize =
    offset_of!(TSConstructorType, type_parameters);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS: usize = offset_of!(TSConstructorType, params);
pub(crate) const OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE: usize =
    offset_of!(TSConstructorType, return_type);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructorTypeWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSConstructorType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructorTypeWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructorTypeWithoutParams<'a, 't>(
    pub(crate) *const TSConstructorType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructorTypeWithoutParams<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn return_type(self) -> &'t Box<'a, TSTypeAnnotation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_RETURN_TYPE)
                as *const Box<'a, TSTypeAnnotation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSConstructorTypeWithoutReturnType<'a, 't>(
    pub(crate) *const TSConstructorType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSConstructorTypeWithoutReturnType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn r#abstract(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_ABSTRACT) as *const bool) }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Option<Box<'a, TSTypeParameterDeclaration<'a>>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_TYPE_PARAMETERS)
                as *const Option<Box<'a, TSTypeParameterDeclaration<'a>>>)
        }
    }

    #[inline]
    pub fn params(self) -> &'t Box<'a, FormalParameters<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_CONSTRUCTOR_TYPE_PARAMS)
                as *const Box<'a, FormalParameters<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_MAPPED_TYPE_SPAN: usize = offset_of!(TSMappedType, span);
pub(crate) const OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER: usize =
    offset_of!(TSMappedType, type_parameter);
pub(crate) const OFFSET_TS_MAPPED_TYPE_NAME_TYPE: usize = offset_of!(TSMappedType, name_type);
pub(crate) const OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(TSMappedType, type_annotation);
pub(crate) const OFFSET_TS_MAPPED_TYPE_OPTIONAL: usize = offset_of!(TSMappedType, optional);
pub(crate) const OFFSET_TS_MAPPED_TYPE_READONLY: usize = offset_of!(TSMappedType, readonly);
pub(crate) const OFFSET_TS_MAPPED_TYPE_SCOPE_ID: usize = offset_of!(TSMappedType, scope_id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMappedTypeWithoutTypeParameter<'a, 't>(
    pub(crate) *const TSMappedType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMappedTypeWithoutTypeParameter<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn name_type(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_NAME_TYPE)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMappedTypeWithoutNameType<'a, 't>(
    pub(crate) *const TSMappedType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMappedTypeWithoutNameType<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameter(self) -> &'t Box<'a, TSTypeParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER)
                as *const Box<'a, TSTypeParameter<'a>>)
        }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_ANNOTATION)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSMappedTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSMappedType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSMappedTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_parameter(self) -> &'t Box<'a, TSTypeParameter<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_TYPE_PARAMETER)
                as *const Box<'a, TSTypeParameter<'a>>)
        }
    }

    #[inline]
    pub fn name_type(self) -> &'t Option<TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_NAME_TYPE)
                as *const Option<TSType<'a>>)
        }
    }

    #[inline]
    pub fn optional(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_OPTIONAL)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn readonly(self) -> &'t TSMappedTypeModifierOperator {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_READONLY)
                as *const TSMappedTypeModifierOperator)
        }
    }

    #[inline]
    pub fn scope_id(self) -> &'t Cell<Option<ScopeId>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_MAPPED_TYPE_SCOPE_ID)
                as *const Cell<Option<ScopeId>>)
        }
    }
}

pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN: usize =
    offset_of!(TSTemplateLiteralType, span);
pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_QUASIS: usize =
    offset_of!(TSTemplateLiteralType, quasis);
pub(crate) const OFFSET_TS_TEMPLATE_LITERAL_TYPE_TYPES: usize =
    offset_of!(TSTemplateLiteralType, types);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTemplateLiteralTypeWithoutQuasis<'a, 't>(
    pub(crate) *const TSTemplateLiteralType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTemplateLiteralTypeWithoutQuasis<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn types(self) -> &'t Vec<'a, TSType<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_TYPES)
                as *const Vec<'a, TSType<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTemplateLiteralTypeWithoutTypes<'a, 't>(
    pub(crate) *const TSTemplateLiteralType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTemplateLiteralTypeWithoutTypes<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn quasis(self) -> &'t Vec<'a, TemplateElement<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TEMPLATE_LITERAL_TYPE_QUASIS)
                as *const Vec<'a, TemplateElement<'a>>)
        }
    }
}

pub(crate) const OFFSET_TS_AS_EXPRESSION_SPAN: usize = offset_of!(TSAsExpression, span);
pub(crate) const OFFSET_TS_AS_EXPRESSION_EXPRESSION: usize = offset_of!(TSAsExpression, expression);
pub(crate) const OFFSET_TS_AS_EXPRESSION_TYPE_ANNOTATION: usize =
    offset_of!(TSAsExpression, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSAsExpressionWithoutExpression<'a, 't>(
    pub(crate) *const TSAsExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSAsExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSAsExpressionWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSAsExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSAsExpressionWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_AS_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_SPAN: usize =
    offset_of!(TSSatisfiesExpression, span);
pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSSatisfiesExpression, expression);
pub(crate) const OFFSET_TS_SATISFIES_EXPRESSION_TYPE_ANNOTATION: usize =
    offset_of!(TSSatisfiesExpression, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSSatisfiesExpressionWithoutExpression<'a, 't>(
    pub(crate) *const TSSatisfiesExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSSatisfiesExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSSatisfiesExpressionWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSSatisfiesExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSSatisfiesExpressionWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_SATISFIES_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_TYPE_ASSERTION_SPAN: usize = offset_of!(TSTypeAssertion, span);
pub(crate) const OFFSET_TS_TYPE_ASSERTION_EXPRESSION: usize =
    offset_of!(TSTypeAssertion, expression);
pub(crate) const OFFSET_TS_TYPE_ASSERTION_TYPE_ANNOTATION: usize =
    offset_of!(TSTypeAssertion, type_annotation);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAssertionWithoutExpression<'a, 't>(
    pub(crate) *const TSTypeAssertion<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAssertionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn type_annotation(self) -> &'t TSType<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_TYPE_ANNOTATION)
                as *const TSType<'a>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSTypeAssertionWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const TSTypeAssertion<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSTypeAssertionWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_SPAN) as *const Span) }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_TYPE_ASSERTION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN: usize =
    offset_of!(TSImportEqualsDeclaration, span);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_ID: usize =
    offset_of!(TSImportEqualsDeclaration, id);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_MODULE_REFERENCE: usize =
    offset_of!(TSImportEqualsDeclaration, module_reference);
pub(crate) const OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND: usize =
    offset_of!(TSImportEqualsDeclaration, import_kind);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportEqualsDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSImportEqualsDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportEqualsDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn module_reference(self) -> &'t TSModuleReference<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_MODULE_REFERENCE)
                as *const TSModuleReference<'a>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSImportEqualsDeclarationWithoutModuleReference<'a, 't>(
    pub(crate) *const TSImportEqualsDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSImportEqualsDeclarationWithoutModuleReference<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn id(self) -> &'t BindingIdentifier<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_ID)
                as *const BindingIdentifier<'a>)
        }
    }

    #[inline]
    pub fn import_kind(self) -> &'t ImportOrExportKind {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_IMPORT_EQUALS_DECLARATION_IMPORT_KIND)
                as *const ImportOrExportKind)
        }
    }
}

pub(crate) const OFFSET_TS_EXTERNAL_MODULE_REFERENCE_SPAN: usize =
    offset_of!(TSExternalModuleReference, span);
pub(crate) const OFFSET_TS_EXTERNAL_MODULE_REFERENCE_EXPRESSION: usize =
    offset_of!(TSExternalModuleReference, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSExternalModuleReferenceWithoutExpression<'a, 't>(
    pub(crate) *const TSExternalModuleReference<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSExternalModuleReferenceWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_EXTERNAL_MODULE_REFERENCE_SPAN) as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_NON_NULL_EXPRESSION_SPAN: usize = offset_of!(TSNonNullExpression, span);
pub(crate) const OFFSET_TS_NON_NULL_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSNonNullExpression, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSNonNullExpressionWithoutExpression<'a, 't>(
    pub(crate) *const TSNonNullExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSNonNullExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_NON_NULL_EXPRESSION_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_DECORATOR_SPAN: usize = offset_of!(Decorator, span);
pub(crate) const OFFSET_DECORATOR_EXPRESSION: usize = offset_of!(Decorator, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct DecoratorWithoutExpression<'a, 't>(
    pub(crate) *const Decorator<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> DecoratorWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_DECORATOR_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_EXPORT_ASSIGNMENT_SPAN: usize = offset_of!(TSExportAssignment, span);
pub(crate) const OFFSET_TS_EXPORT_ASSIGNMENT_EXPRESSION: usize =
    offset_of!(TSExportAssignment, expression);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSExportAssignmentWithoutExpression<'a, 't>(
    pub(crate) *const TSExportAssignment<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSExportAssignmentWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_TS_EXPORT_ASSIGNMENT_SPAN) as *const Span) }
    }
}

pub(crate) const OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_SPAN: usize =
    offset_of!(TSNamespaceExportDeclaration, span);
pub(crate) const OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_ID: usize =
    offset_of!(TSNamespaceExportDeclaration, id);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSNamespaceExportDeclarationWithoutId<'a, 't>(
    pub(crate) *const TSNamespaceExportDeclaration<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSNamespaceExportDeclarationWithoutId<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_NAMESPACE_EXPORT_DECLARATION_SPAN)
                as *const Span)
        }
    }
}

pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN: usize =
    offset_of!(TSInstantiationExpression, span);
pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_EXPRESSION: usize =
    offset_of!(TSInstantiationExpression, expression);
pub(crate) const OFFSET_TS_INSTANTIATION_EXPRESSION_TYPE_PARAMETERS: usize =
    offset_of!(TSInstantiationExpression, type_parameters);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInstantiationExpressionWithoutExpression<'a, 't>(
    pub(crate) *const TSInstantiationExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInstantiationExpressionWithoutExpression<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn type_parameters(self) -> &'t Box<'a, TSTypeParameterInstantiation<'a>> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_TYPE_PARAMETERS)
                as *const Box<'a, TSTypeParameterInstantiation<'a>>)
        }
    }
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct TSInstantiationExpressionWithoutTypeParameters<'a, 't>(
    pub(crate) *const TSInstantiationExpression<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> TSInstantiationExpressionWithoutTypeParameters<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn expression(self) -> &'t Expression<'a> {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_TS_INSTANTIATION_EXPRESSION_EXPRESSION)
                as *const Expression<'a>)
        }
    }
}

pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_SPAN: usize = offset_of!(JSDocNullableType, span);
pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(JSDocNullableType, type_annotation);
pub(crate) const OFFSET_JS_DOC_NULLABLE_TYPE_POSTFIX: usize =
    offset_of!(JSDocNullableType, postfix);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSDocNullableTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const JSDocNullableType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSDocNullableTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JS_DOC_NULLABLE_TYPE_SPAN) as *const Span) }
    }

    #[inline]
    pub fn postfix(self) -> &'t bool {
        unsafe { &*((self.0 as *const u8).add(OFFSET_JS_DOC_NULLABLE_TYPE_POSTFIX) as *const bool) }
    }
}

pub(crate) const OFFSET_JS_DOC_NON_NULLABLE_TYPE_SPAN: usize =
    offset_of!(JSDocNonNullableType, span);
pub(crate) const OFFSET_JS_DOC_NON_NULLABLE_TYPE_TYPE_ANNOTATION: usize =
    offset_of!(JSDocNonNullableType, type_annotation);
pub(crate) const OFFSET_JS_DOC_NON_NULLABLE_TYPE_POSTFIX: usize =
    offset_of!(JSDocNonNullableType, postfix);

#[repr(transparent)]
#[derive(Clone, Copy, Debug)]
pub struct JSDocNonNullableTypeWithoutTypeAnnotation<'a, 't>(
    pub(crate) *const JSDocNonNullableType<'a>,
    pub(crate) PhantomData<&'t ()>,
);

impl<'a, 't> JSDocNonNullableTypeWithoutTypeAnnotation<'a, 't> {
    #[inline]
    pub fn span(self) -> &'t Span {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JS_DOC_NON_NULLABLE_TYPE_SPAN) as *const Span)
        }
    }

    #[inline]
    pub fn postfix(self) -> &'t bool {
        unsafe {
            &*((self.0 as *const u8).add(OFFSET_JS_DOC_NON_NULLABLE_TYPE_POSTFIX) as *const bool)
        }
    }
}
