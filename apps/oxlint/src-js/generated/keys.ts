// Auto-generated code, DO NOT EDIT DIRECTLY!
// To edit this generated file you have to edit `tasks/ast_tools/src/generators/estree_visit.rs`.

const { freeze } = Object;

const $EMPTY = freeze([]),
  DECORATORS__KEY__TYPE_ANNOTATION__VALUE = freeze([
    "decorators",
    "key",
    "typeAnnotation",
    "value",
  ]),
  LEFT__RIGHT = freeze(["left", "right"]),
  ARGUMENT = freeze(["argument"]),
  BODY = freeze(["body"]),
  LABEL = freeze(["label"]),
  CALLEE__TYPE_ARGUMENTS__ARGUMENTS = freeze(["callee", "typeArguments", "arguments"]),
  EXPRESSION = freeze(["expression"]),
  DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY = freeze([
    "decorators",
    "id",
    "typeParameters",
    "superClass",
    "superTypeArguments",
    "implements",
    "body",
  ]),
  TEST__CONSEQUENT__ALTERNATE = freeze(["test", "consequent", "alternate"]),
  LEFT__RIGHT__BODY = freeze(["left", "right", "body"]),
  ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY = freeze([
    "id",
    "typeParameters",
    "params",
    "returnType",
    "body",
  ]),
  KEY__VALUE = freeze(["key", "value"]),
  LOCAL = freeze(["local"]),
  OBJECT__PROPERTY = freeze(["object", "property"]),
  DECORATORS__KEY__TYPE_ANNOTATION = freeze(["decorators", "key", "typeAnnotation"]),
  EXPRESSION__TYPE_ANNOTATION = freeze(["expression", "typeAnnotation"]),
  TYPE_PARAMETERS__PARAMS__RETURN_TYPE = freeze(["typeParameters", "params", "returnType"]),
  EXPRESSION__TYPE_ARGUMENTS = freeze(["expression", "typeArguments"]),
  MEMBERS = freeze(["members"]),
  ID__BODY = freeze(["id", "body"]),
  TYPES = freeze(["types"]),
  TYPE_ANNOTATION = freeze(["typeAnnotation"]),
  PARAMS = freeze(["params"]);

export default freeze({
  // Leaf nodes
  DebuggerStatement: $EMPTY,
  EmptyStatement: $EMPTY,
  Literal: $EMPTY,
  PrivateIdentifier: $EMPTY,
  Super: $EMPTY,
  TemplateElement: $EMPTY,
  ThisExpression: $EMPTY,
  JSXClosingFragment: $EMPTY,
  JSXEmptyExpression: $EMPTY,
  JSXIdentifier: $EMPTY,
  JSXOpeningFragment: $EMPTY,
  JSXText: $EMPTY,
  TSAnyKeyword: $EMPTY,
  TSBigIntKeyword: $EMPTY,
  TSBooleanKeyword: $EMPTY,
  TSIntrinsicKeyword: $EMPTY,
  TSJSDocUnknownType: $EMPTY,
  TSNeverKeyword: $EMPTY,
  TSNullKeyword: $EMPTY,
  TSNumberKeyword: $EMPTY,
  TSObjectKeyword: $EMPTY,
  TSStringKeyword: $EMPTY,
  TSSymbolKeyword: $EMPTY,
  TSThisType: $EMPTY,
  TSUndefinedKeyword: $EMPTY,
  TSUnknownKeyword: $EMPTY,
  TSVoidKeyword: $EMPTY,
  // Non-leaf nodes
  AccessorProperty: DECORATORS__KEY__TYPE_ANNOTATION__VALUE,
  ArrayExpression: freeze(["elements"]),
  ArrayPattern: freeze(["decorators", "elements", "typeAnnotation"]),
  ArrowFunctionExpression: freeze(["typeParameters", "params", "returnType", "body"]),
  AssignmentExpression: LEFT__RIGHT,
  AssignmentPattern: freeze(["decorators", "left", "right", "typeAnnotation"]),
  AwaitExpression: ARGUMENT,
  BinaryExpression: LEFT__RIGHT,
  BlockStatement: BODY,
  BreakStatement: LABEL,
  CallExpression: CALLEE__TYPE_ARGUMENTS__ARGUMENTS,
  CatchClause: freeze(["param", "body"]),
  ChainExpression: EXPRESSION,
  ClassBody: BODY,
  ClassDeclaration:
    DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY,
  ClassExpression:
    DECORATORS__ID__TYPE_PARAMETERS__SUPER_CLASS__SUPER_TYPE_ARGUMENTS__IMPLEMENTS__BODY,
  ConditionalExpression: TEST__CONSEQUENT__ALTERNATE,
  ContinueStatement: LABEL,
  Decorator: EXPRESSION,
  DoWhileStatement: freeze(["body", "test"]),
  ExportAllDeclaration: freeze(["exported", "source", "attributes"]),
  ExportDefaultDeclaration: freeze(["declaration"]),
  ExportNamedDeclaration: freeze(["declaration", "specifiers", "source", "attributes"]),
  ExportSpecifier: freeze(["local", "exported"]),
  ExpressionStatement: EXPRESSION,
  ForInStatement: LEFT__RIGHT__BODY,
  ForOfStatement: LEFT__RIGHT__BODY,
  ForStatement: freeze(["init", "test", "update", "body"]),
  FunctionDeclaration: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
  FunctionExpression: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
  Identifier: freeze(["decorators", "typeAnnotation"]),
  IfStatement: TEST__CONSEQUENT__ALTERNATE,
  ImportAttribute: KEY__VALUE,
  ImportDeclaration: freeze(["specifiers", "source", "attributes"]),
  ImportDefaultSpecifier: LOCAL,
  ImportExpression: freeze(["source", "options"]),
  ImportNamespaceSpecifier: LOCAL,
  ImportSpecifier: freeze(["imported", "local"]),
  LabeledStatement: freeze(["label", "body"]),
  LogicalExpression: LEFT__RIGHT,
  MemberExpression: OBJECT__PROPERTY,
  MetaProperty: freeze(["meta", "property"]),
  MethodDefinition: freeze(["decorators", "key", "value"]),
  NewExpression: CALLEE__TYPE_ARGUMENTS__ARGUMENTS,
  ObjectExpression: freeze(["properties"]),
  ObjectPattern: freeze(["decorators", "properties", "typeAnnotation"]),
  ParenthesizedExpression: EXPRESSION,
  Program: BODY,
  Property: KEY__VALUE,
  PropertyDefinition: DECORATORS__KEY__TYPE_ANNOTATION__VALUE,
  RestElement: freeze(["decorators", "argument", "typeAnnotation"]),
  ReturnStatement: ARGUMENT,
  SequenceExpression: freeze(["expressions"]),
  SpreadElement: ARGUMENT,
  StaticBlock: BODY,
  SwitchCase: freeze(["test", "consequent"]),
  SwitchStatement: freeze(["discriminant", "cases"]),
  TaggedTemplateExpression: freeze(["tag", "typeArguments", "quasi"]),
  TemplateLiteral: freeze(["quasis", "expressions"]),
  ThrowStatement: ARGUMENT,
  TryStatement: freeze(["block", "handler", "finalizer"]),
  UnaryExpression: ARGUMENT,
  UpdateExpression: ARGUMENT,
  V8IntrinsicExpression: freeze(["name", "arguments"]),
  VariableDeclaration: freeze(["declarations"]),
  VariableDeclarator: freeze(["id", "init"]),
  WhileStatement: freeze(["test", "body"]),
  WithStatement: freeze(["object", "body"]),
  YieldExpression: ARGUMENT,
  JSXAttribute: freeze(["name", "value"]),
  JSXClosingElement: freeze(["name"]),
  JSXElement: freeze(["openingElement", "children", "closingElement"]),
  JSXExpressionContainer: EXPRESSION,
  JSXFragment: freeze(["openingFragment", "children", "closingFragment"]),
  JSXMemberExpression: OBJECT__PROPERTY,
  JSXNamespacedName: freeze(["namespace", "name"]),
  JSXOpeningElement: freeze(["name", "typeArguments", "attributes"]),
  JSXSpreadAttribute: ARGUMENT,
  JSXSpreadChild: EXPRESSION,
  TSAbstractAccessorProperty: DECORATORS__KEY__TYPE_ANNOTATION,
  TSAbstractMethodDefinition: KEY__VALUE,
  TSAbstractPropertyDefinition: DECORATORS__KEY__TYPE_ANNOTATION,
  TSArrayType: freeze(["elementType"]),
  TSAsExpression: EXPRESSION__TYPE_ANNOTATION,
  TSCallSignatureDeclaration: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
  TSClassImplements: EXPRESSION__TYPE_ARGUMENTS,
  TSConditionalType: freeze(["checkType", "extendsType", "trueType", "falseType"]),
  TSConstructSignatureDeclaration: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
  TSConstructorType: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
  TSDeclareFunction: ID__TYPE_PARAMETERS__PARAMS__RETURN_TYPE__BODY,
  TSEmptyBodyFunctionExpression: freeze(["id", "typeParameters", "params", "returnType"]),
  TSEnumBody: MEMBERS,
  TSEnumDeclaration: ID__BODY,
  TSEnumMember: freeze(["id", "initializer"]),
  TSExportAssignment: EXPRESSION,
  TSExternalModuleReference: EXPRESSION,
  TSFunctionType: TYPE_PARAMETERS__PARAMS__RETURN_TYPE,
  TSImportEqualsDeclaration: freeze(["id", "moduleReference"]),
  TSImportType: freeze(["argument", "options", "qualifier", "typeArguments"]),
  TSIndexSignature: freeze(["parameters", "typeAnnotation"]),
  TSIndexedAccessType: freeze(["objectType", "indexType"]),
  TSInferType: freeze(["typeParameter"]),
  TSInstantiationExpression: EXPRESSION__TYPE_ARGUMENTS,
  TSInterfaceBody: BODY,
  TSInterfaceDeclaration: freeze(["id", "typeParameters", "extends", "body"]),
  TSInterfaceHeritage: EXPRESSION__TYPE_ARGUMENTS,
  TSIntersectionType: TYPES,
  TSJSDocNonNullableType: TYPE_ANNOTATION,
  TSJSDocNullableType: TYPE_ANNOTATION,
  TSLiteralType: freeze(["literal"]),
  TSMappedType: freeze(["key", "constraint", "nameType", "typeAnnotation"]),
  TSMethodSignature: freeze(["key", "typeParameters", "params", "returnType"]),
  TSModuleBlock: BODY,
  TSModuleDeclaration: ID__BODY,
  TSNamedTupleMember: freeze(["label", "elementType"]),
  TSNamespaceExportDeclaration: freeze(["id"]),
  TSNonNullExpression: EXPRESSION,
  TSOptionalType: TYPE_ANNOTATION,
  TSParameterProperty: freeze(["decorators", "parameter"]),
  TSParenthesizedType: TYPE_ANNOTATION,
  TSPropertySignature: freeze(["key", "typeAnnotation"]),
  TSQualifiedName: LEFT__RIGHT,
  TSRestType: TYPE_ANNOTATION,
  TSSatisfiesExpression: EXPRESSION__TYPE_ANNOTATION,
  TSTemplateLiteralType: freeze(["quasis", "types"]),
  TSTupleType: freeze(["elementTypes"]),
  TSTypeAliasDeclaration: freeze(["id", "typeParameters", "typeAnnotation"]),
  TSTypeAnnotation: TYPE_ANNOTATION,
  TSTypeAssertion: freeze(["typeAnnotation", "expression"]),
  TSTypeLiteral: MEMBERS,
  TSTypeOperator: TYPE_ANNOTATION,
  TSTypeParameter: freeze(["name", "constraint", "default"]),
  TSTypeParameterDeclaration: PARAMS,
  TSTypeParameterInstantiation: PARAMS,
  TSTypePredicate: freeze(["parameterName", "typeAnnotation"]),
  TSTypeQuery: freeze(["exprName", "typeArguments"]),
  TSTypeReference: freeze(["typeName", "typeArguments"]),
  TSUnionType: TYPES,
});
