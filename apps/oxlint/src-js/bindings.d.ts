/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Get offset within a `Uint8Array` which is aligned on `BUFFER_ALIGN`.
 *
 * Does not check that the offset is within bounds of `buffer`.
 * To ensure it always is, provide a `Uint8Array` of at least `BUFFER_SIZE + BUFFER_ALIGN` bytes.
 */
export declare function getBufferOffset(buffer: Uint8Array): number

/** JS callback to lint a file. */
export type JsLintFileCb =
  ((arg0: string, arg1: number, arg2: Uint8Array | undefined | null, arg3: Array<number>, arg4: Array<number>, arg5: string) => string)

/** JS callback to load a JS plugin. */
export type JsLoadPluginCb =
  ((arg0: string, arg1?: string | undefined | null) => Promise<string>)

/** JS callback to setup configs. */
export type JsSetupConfigsCb =
  ((arg: string) => void)

/**
 * NAPI entry point.
 *
 * JS side passes in:
 * 1. `args`: Command line arguments (process.argv.slice(2))
 * 2. `load_plugin`: Load a JS plugin from a file path.
 * 3. `setup_configs`: Setup configuration options.
 * 4. `lint_file`: Lint a file.
 *
 * Returns `true` if linting succeeded without errors, `false` otherwise.
 */
export declare function lint(args: Array<string>, loadPlugin: JsLoadPluginCb, setupConfigs: JsSetupConfigsCb, lintFile: JsLintFileCb): Promise<boolean>

/**
 * Parse AST into provided `Uint8Array` buffer, synchronously.
 *
 * Source text must be written into the start of the buffer, and its length (in UTF-8 bytes)
 * provided as `source_len`.
 *
 * This function will parse the source, and write the AST into the buffer, starting at the end.
 *
 * It also writes to the very end of the buffer the offset of `Program` within the buffer.
 *
 * Caller can deserialize data from the buffer on JS side.
 *
 * # SAFETY
 *
 * Caller must ensure:
 * * Source text is written into start of the buffer.
 * * Source text's UTF-8 byte length is `source_len`.
 * * The 1st `source_len` bytes of the buffer comprises a valid UTF-8 string.
 *
 * If source text is originally a JS string on JS side, and converted to a buffer with
 * `Buffer.from(str)` or `new TextEncoder().encode(str)`, this guarantees it's valid UTF-8.
 *
 * # Panics
 *
 * Panics if source text is too long, or AST takes more memory than is available in the buffer.
 */
export declare function parseRawSync(filename: string, buffer: Uint8Array, sourceLen: number): void

/** Returns `true` if raw transfer is supported on this platform. */
export declare function rawTransferSupported(): boolean
