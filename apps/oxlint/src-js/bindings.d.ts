/* auto-generated by NAPI-RS */
/* eslint-disable */
export interface Comment {
  type: 'Line' | 'Block'
  value: string
  start: number
  end: number
}

export interface ErrorLabel {
  message: string | null
  start: number
  end: number
}

export interface OxcError {
  severity: Severity
  message: string
  labels: Array<ErrorLabel>
  helpMessage: string | null
  codeframe: string | null
}

export declare const enum Severity {
  Error = 'Error',
  Warning = 'Warning',
  Advice = 'Advice'
}
/**
 * Apply fixes to source text and return the fixed code.
 *
 * - `source_text` is the original source code.
 * - `fixes_json` is a JSON string containing `Vec<Vec<JsFix>>` â€” an array of fix groups,
 *    one group per diagnostic which provides fixes.
 *    Each inner array should have length of 1 at minimum.
 *
 * If source text starts with a BOM, `JSFix`es must have offsets relative to the start
 * of the source text *without* the BOM.
 *
 * Each group's fixes are merged, then all merged fixes are applied to `source_text`.
 *
 * Fix ranges are converted from UTF-16 code units to UTF-8 bytes.
 */
export declare function applyFixes(sourceText: string, fixesJson: string, eslintCompat: boolean): string | null

/**
 * Get offset within a `Uint8Array` which is aligned on `BUFFER_ALIGN`.
 *
 * Does not check that the offset is within bounds of `buffer`.
 * To ensure it always is, provide a `Uint8Array` of at least `BUFFER_SIZE + BUFFER_ALIGN` bytes.
 */
export declare function getBufferOffset(buffer: Uint8Array): number

/** JS callback to create a workspace. */
export type JsCreateWorkspaceCb =
  ((arg: string) => Promise<undefined>)

/** JS callback to destroy a workspace. */
export type JsDestroyWorkspaceCb =
  ((arg: string) => void)

/** JS callback to lint a file. */
export type JsLintFileCb =
  ((arg0: string, arg1: number, arg2: Uint8Array | undefined | null, arg3: Array<number>, arg4: Array<number>, arg5: string, arg6: string, arg7?: string | undefined | null) => string | null)

/** JS callback to load JavaScript config files. */
export type JsLoadJsConfigsCb =
  ((arg: Array<string>) => Promise<string>)

/** JS callback to load a JS plugin. */
export type JsLoadPluginCb =
  ((arg0: string, arg1: string | undefined | null, arg2: boolean, arg3?: string | undefined | null) => Promise<string>)

/** JS callback to setup configs. */
export type JsSetupRuleConfigsCb =
  ((arg: string) => string | null)

/**
 * NAPI entry point.
 *
 * JS side passes in:
 * 1. `args`: Command line arguments (process.argv.slice(2))
 * 2. `load_plugin`: Load a JS plugin from a file path.
 * 3. `setup_rule_configs`: Setup configuration options.
 * 4. `lint_file`: Lint a file.
 * 5. `create_workspace`: Create a workspace.
 * 6. `destroy_workspace`: Destroy a workspace.
 * 7. `load_js_configs`: Load JavaScript config files.
 *
 * Returns `true` if linting succeeded without errors, `false` otherwise.
 */
export declare function lint(args: Array<string>, loadPlugin: JsLoadPluginCb, setupRuleConfigs: JsSetupRuleConfigsCb, lintFile: JsLintFileCb, createWorkspace: JsCreateWorkspaceCb, destroyWorkspace: JsDestroyWorkspaceCb, loadJsConfigs: JsLoadJsConfigsCb): Promise<boolean>

/**
 * Parse AST into provided `Uint8Array` buffer, synchronously.
 *
 * Source text must be written into somewhere towards end of the buffer.
 * - `source_start` is position of first byte of source text in buffer
 * - `source_len` is length of source text (in UTF-8 bytes)
 *
 * This function will parse the source, and write the AST into the buffer, starting at the end (before the source text).
 *
 * It also writes to the very end of the buffer the offset of `Program` within the buffer.
 *
 * Caller can deserialize data from the buffer on JS side.
 *
 * # SAFETY
 *
 * Caller must ensure:
 * * Source text is written into the buffer.
 * * Start of source text is at `source_start` bytes from the start of the buffer.
 * * Source text's UTF-8 byte length is `source_len`.
 * * This section of bytes in the buffer comprises a valid UTF-8 string.
 *
 * If source text is originally a JS string on JS side, and converted to a buffer with
 * `Buffer.from(str)` or `new TextEncoder().encode(str)`, this guarantees it's valid UTF-8.
 *
 * # Panics
 *
 * Panics if source text is too long, or AST takes more memory than is available in the buffer.
 */
export declare function parseRawSync(filename: string, buffer: Uint8Array, sourceStart: number, sourceLen: number, options?: ParserOptions | undefined | null): void

export interface ParserOptions {
  /** Treat the source text as `js`, `jsx`, `ts`, `tsx` or `dts`. */
  lang?: 'js' | 'jsx' | 'ts' | 'tsx' | 'dts'
  /** Treat the source text as `script` or `module` code. */
  sourceType?: 'script' | 'module' | 'commonjs' | 'unambiguous' | undefined
  /** Ignore non-fatal parsing errors */
  ignoreNonFatalErrors?: boolean
}

/** Returns `true` if raw transfer is supported on this platform. */
export declare function rawTransferSupported(): boolean
