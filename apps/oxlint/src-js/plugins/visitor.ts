// Functions to compile 1 or more visitor objects into a single compiled visitor.
//
// # Visitor objects
//
// Visitor objects which are generated by rules' `create` functions have keys being either:
// * Name of an AST type, or selector. or
// * Name of an AST type or selector, postfixed with `:exit`.
//
// Each property value must be a function that handles that AST node / selector target.
//
// e.g.:
//
// ```
// {
//   BinaryExpression(node) {
//     // Called when entering a `BinaryExpression` node
//   },
//   'BinaryExpression:exit'(node) {
//     // Called when exiting a `BinaryExpression` node
//   },
//   ':matches(BinaryExpression, LogicalExpression)'(node) {
//     // Called when entering a `BinaryExpression` or `LogicalExpression` node
//   },
//   '*:exit'(node) {
//     // Called when exiting any node
//   },
// }
// ```
//
// # Compiled visitor
//
// Compiled visitor is an array with `NODE_TYPES_COUNT` length, keyed by the ID of the node type.
// `NODE_TYPE_IDS_MAP` maps from type name to ID.
//
// Each element of compiled array is one of:
// * No visitor for this type = `null`.
// * Visitor for leaf node = visit function.
// * Visitor for non-leaf node = object of form `{ enter, exit }`,
//   where each property is either a visitor function or `null`.
//
// e.g.:
//
// ```
// [
//   // Leaf nodes
//   function(node) { /* do stuff */ },
//   // ...
//
//   // Non-leaf nodes
//   {
//     enter: function(node) { /* do stuff */ },
//     exit: null,
//   },
//   // ...
// ]
// ```
//
// # Object reuse
//
// No more than 1 compiled visitor exists at any time, so we reuse a single array `compiledVisitor`,
// rather than creating a new array for each file being linted.
//
// To compile visitors, call:
// * `initCompiledVisitor` once.
// * `addVisitorToCompiled` with each visitor object.
// * `finalizeCompiledVisitor` once.
//
// After this sequence of calls, `compiledVisitor` is ready to be used to walk the AST.
//
// We also recycle:
//
// * `{ enter, exit }` objects which are stored in compiled visitor.
// * `VisitProp` objects which are used while compiling visitor.
// * Temporary array used to store multiple visit functions in `mergeVisitFns`.
//
// The aim is to reduce pressure on the garbage collector. All these recycled objects are long-lived
// and will graduate to "old space", which leaves as much capacity as possible in "new space"
// for objects created by user code in visitors. If ephemeral user-created objects all fit in new space,
// it will avoid full GC runs, which should greatly improve performance.

import {
  LEAF_NODE_TYPES_COUNT,
  NODE_TYPE_IDS_MAP,
  NODE_TYPES_COUNT,
} from "../generated/type_ids.ts";
import {
  parseSelector,
  wrapVisitFnWithSelectorMatch,
  EXIT_FLAG,
  IDENTIFIER_COUNT_INCREMENT,
} from "./selector.ts";
import { debugAssert, debugAssertIsNonNull } from "../utils/asserts.ts";

import type { Node, Visitor } from "./types.ts";

const ObjectKeys = Object.keys;

// Visit function for a specific AST node type.
export type VisitFn = (node: Node) => void;

// Enter+exit pair, for non-leaf nodes in compiled visitor.
export interface EnterExit {
  enter: VisitFn | null;
  exit: VisitFn | null;
}

// Visitor function and details of its specificity.
interface VisitProp {
  // Visit function.
  // Only `null` in between compilations - this field is only nullable to allow `VisitProp` objects to be reused,
  // while allowing the `VisitFn` to be garbage collected.
  fn: VisitFn | null;
  // Specificity of visitor function.
  specificity: number;
  // Selector string e.g. `Program`, `Program > ExpressionStatement`, `*`.
  // Does not include trailing `:exit`.
  // Used as tie-breaker for specificity.
  // Only `null` in between compilations - this field is only nullable to allow `VisitProp` objects to be reused,
  // while allowing the string to be garbage collected.
  selectorStr: string | null;
}

// Entry and exit visitors for a non-leaf node.
interface CompilingNonLeafVisitorEntry {
  // Visitor props for entry
  enter: VisitProp[];
  // Visitor props for exit
  exit: VisitProp[];
}

// During compilation, arrays of visitor props are stored in these arrays.
// These arrays are initialized with empty arrays, and never modified thereafter.
// Only the arrays they contain are modified - they're filled up during compilation,
// and emptied at the end in `finalizeCompiledVisitor`, so can be reused for next compilation.
const compilingLeafVisitor: VisitProp[][] = [];
const compilingNonLeafVisitor: CompilingNonLeafVisitorEntry[] = [];

for (let i = LEAF_NODE_TYPES_COUNT; i !== 0; i--) {
  compilingLeafVisitor.push([]);
}

for (let i = NODE_TYPES_COUNT - LEAF_NODE_TYPES_COUNT; i !== 0; i--) {
  compilingNonLeafVisitor.push({ enter: [], exit: [] });
}

// Compiled visitor used for visiting each file.
//
// * `VisitFn | null` for leaf nodes.
// * `EnterExit | null` for non-leaf nodes.
//
// Same array is reused for each file.
//
// Initialized with `.push()` to ensure V8 treats the array as "packed" (linear array),
// not "holey" (hash map). This is critical, as looking up elements in this array is a very hot path
// during AST visitation, and holey arrays are much slower.
// https://v8.dev/blog/elements-kinds
export const compiledVisitor: (VisitFn | EnterExit | null)[] = [];

for (let i = NODE_TYPES_COUNT; i !== 0; i--) {
  compiledVisitor.push(null);
}

// Arrays containing type IDs of types which have visit functions defined for them.
//
// Fill with zeros initially up to maximum size they could ever need to be so that:
// 1. These arrays never need to grow.
// 2. V8 treats these arrays as "PACKED_SMI_ELEMENTS".
const activeLeafVisitorTypeIds: number[] = [],
  activeNonLeafVisitorTypeIds: number[] = [];

for (let i = LEAF_NODE_TYPES_COUNT; i !== 0; i--) {
  activeLeafVisitorTypeIds.push(0);
}

for (let i = NODE_TYPES_COUNT - LEAF_NODE_TYPES_COUNT; i !== 0; i--) {
  activeNonLeafVisitorTypeIds.push(0);
}

activeLeafVisitorTypeIds.length = 0;
activeNonLeafVisitorTypeIds.length = 0;

// `true` if `addVisitor` has been called with a visitor which visits at least one AST type
let hasActiveVisitors = false;

// Enter+exit object cache.
//
// `compiledVisitor` may contain many `{ enter, exit }` objects.
// Use this cache to reuse those objects across all visitor compilations.
//
// `enterExitObjectCacheNextIndex` is the index of first object in cache which is currently unused.
// It may point to the end of the cache array.
const enterExitObjectCache: EnterExit[] = [];
let enterExitObjectCacheNextIndex = 0;

// `VisitProp` object cache.
//
// During compilation, many such objects may be required, and then they're discarded in `finalizeCompiledVisitor`.
// Use this cache to reuse those objects across all visitor compilations.
//
// `visitPropsCacheNextIndex` is the index of first object in cache which is currently unused.
// It may point to the end of the cache array.
const visitPropsCache: VisitProp[] = [];
let visitPropsCacheNextIndex = 0;

/**
 * Initialize compiled visitor, ready for calls to `addVisitor`.
 */
export function initCompiledVisitor(): void {
  // Reset `compiledVisitor` array after previous compilation
  for (let i = 0; i < NODE_TYPES_COUNT; i++) {
    compiledVisitor[i] = null;
  }

  // Reset enter+exit objects which were used in previous compilation
  for (let i = 0; i < enterExitObjectCacheNextIndex; i++) {
    const enterExit = enterExitObjectCache[i];
    enterExit.enter = null;
    enterExit.exit = null;
  }
  enterExitObjectCacheNextIndex = 0;
}

/**
 * Add a visitor to compiled visitor.
 *
 * @param visitor - Visitor object
 */
export function addVisitorToCompiled(visitor: Visitor): void {
  if (visitor === null || typeof visitor !== "object") {
    throw new TypeError("Visitor returned from `create` method must be an object");
  }

  // Exit if is empty visitor
  const keys = ObjectKeys(visitor),
    keysLen = keys.length;
  if (keysLen === 0) return;

  hasActiveVisitors = true;

  // Populate visitors array from provided object
  for (let i = 0; i < keysLen; i++) {
    let name = keys[i];

    const visitFn = visitor[name];
    if (typeof visitFn !== "function") {
      throw new TypeError(`'${name}' property of visitor object is not a function`);
    }

    // If this is an exit visit fn, set `specificity` initially to `EXIT_FLAG`, otherwise 0.
    // Visit fns are sorted in ascending order of `specificity`.
    // For leaf nodes, the high `specificity` ensures that exit visit fns are sorted after enter visit fns,
    // and therefore `exit` fns are called after `enter` fns.
    let specificity = 0;

    const isExit = name.endsWith(":exit");
    if (isExit) {
      name = name.slice(0, -5);
      specificity = EXIT_FLAG;
    }

    // Create `VisitProp` object.
    // Use an existing object from cache if available, otherwise create a new one.
    let visitProp: VisitProp;
    if (visitPropsCacheNextIndex < visitPropsCache.length) {
      visitProp = visitPropsCache[visitPropsCacheNextIndex];
      visitProp.fn = visitFn;
      visitProp.specificity = specificity;
      visitProp.selectorStr = name;
    } else {
      visitProp = { fn: visitFn, specificity, selectorStr: name };
      visitPropsCache.push(visitProp);
    }
    visitPropsCacheNextIndex++;

    // TODO: Combine the two hashmaps `NODE_TYPE_IDS_MAP` and selectors cache into one `Map`
    // to avoid 2 hashmap lookups for selectors?
    let typeId = NODE_TYPE_IDS_MAP.get(name);
    if (typeId !== undefined) {
      // Single type visit function e.g. `Program`.
      // Add a single identifier to `specificity`. Use `|=` to keep exit flag.
      visitProp.specificity |= IDENTIFIER_COUNT_INCREMENT;
      addVisitFn(typeId, visitProp, isExit);
      continue;
    }

    // `*` matches any node without any filtering, so no need to wrap it
    if (name !== "*") {
      // Selector.
      // Parse selector.
      // Wrap `visitFn` so it only executes if the selector matches.
      // If selector is simple (unconditionally matches certain types e.g. `:matches(X, Y)`), skip wrapping.
      const selector = parseSelector(name);

      // Update specificity. Use `|=` to keep exit flag.
      visitProp.specificity |= selector.specificity;

      if (selector.isComplex) {
        visitProp.fn = wrapVisitFnWithSelectorMatch(visitFn, selector.esquerySelector);
      }

      const { typeIds } = selector;
      if (typeIds !== null) {
        // Selector matches a specific set of node types.
        // Note: If `typeIds` is empty, `visitProp` will not be used.
        // We could return it to the cache, but this should be a very rare case, so don't bother.
        for (let i = 0, len = typeIds.length; i < len; i++) {
          addVisitFn(typeIds[i], visitProp, isExit);
        }
        continue;
      }
    }

    // `*` selector or some other selector that matches all node types
    for (typeId = 0; typeId < LEAF_NODE_TYPES_COUNT; typeId++) {
      addLeafVisitFn(typeId, visitProp);
    }
    for (; typeId < NODE_TYPES_COUNT; typeId++) {
      addNonLeafVisitFn(typeId, visitProp, isExit);
    }
  }
}

/**
 * Add visit function to compiled visitor.
 * @param typeId - Node type ID
 * @param visitProp - Visitor property
 * @param isExit - `true` if is an exit visit fn
 */
function addVisitFn(typeId: number, visitProp: VisitProp, isExit: boolean): void {
  if (typeId < LEAF_NODE_TYPES_COUNT) {
    addLeafVisitFn(typeId, visitProp);
  } else {
    addNonLeafVisitFn(typeId, visitProp, isExit);
  }
}

/**
 * Add visit function for a leaf node to compiled visitor.
 *
 * Stored as just 1 function, not enter+exit pair.
 *
 * @param typeId - Node type ID
 * @param visitProp - Visitor property
 */
function addLeafVisitFn(typeId: number, visitProp: VisitProp): void {
  const visitProps = compilingLeafVisitor[typeId]!;
  if (visitProps.length === 0) activeLeafVisitorTypeIds.push(typeId);
  visitProps.push(visitProp);
}

/**
 * Add visit function for a non-leaf node to compiled visitor.
 *
 * Stored as enter+exit pair.
 *
 * @param typeId - Node type ID
 * @param visitProp - Visitor property
 * @param isExit - `true` if is an exit visit fn
 */
function addNonLeafVisitFn(typeId: number, visitProp: VisitProp, isExit: boolean): void {
  const { enter, exit } = compilingNonLeafVisitor[typeId - LEAF_NODE_TYPES_COUNT]!;
  if (enter.length === 0 && exit.length === 0) {
    activeNonLeafVisitorTypeIds.push(typeId);
  }

  if (isExit) {
    exit.push(visitProp);
  } else {
    enter.push(visitProp);
  }
}

/**
 * Finalize compiled visitor.
 *
 * After calling this function, `compiledVisitor` is ready to be used to walk the AST.
 *
 * @returns - `true` if compiled visitor visits at least 1 AST type
 */
export function finalizeCompiledVisitor(): boolean {
  if (hasActiveVisitors === false) return false;

  // Merge visitors for leaf nodes
  for (let i = activeLeafVisitorTypeIds.length - 1; i >= 0; i--) {
    const typeId = activeLeafVisitorTypeIds[i]!;
    compiledVisitor[typeId] = mergeVisitFns(compilingLeafVisitor[typeId]!);
  }

  // Merge visitors for non-leaf nodes
  for (let i = activeNonLeafVisitorTypeIds.length - 1; i >= 0; i--) {
    const typeId = activeNonLeafVisitorTypeIds[i]!;
    const entry = compilingNonLeafVisitor[typeId - LEAF_NODE_TYPES_COUNT]!;

    // Get or create enter-exit object.
    // Use an existing object from cache if available, otherwise create a new one.
    let enterExit: EnterExit;
    if (enterExitObjectCacheNextIndex < enterExitObjectCache.length) {
      enterExit = enterExitObjectCache[enterExitObjectCacheNextIndex];
    } else {
      enterExit = { enter: null, exit: null };
      enterExitObjectCache.push(enterExit);
    }
    enterExitObjectCacheNextIndex++;

    // Merge enter and exit visitors
    const enterArr = entry.enter;
    if (enterArr.length !== 0) enterExit.enter = mergeVisitFns(enterArr);

    const exitArr = entry.exit;
    if (exitArr.length !== 0) enterExit.exit = mergeVisitFns(exitArr);

    // Store merged enter-exit object in compiled visitor
    compiledVisitor[typeId] = enterExit;
  }

  // Reset `visitPropsCache`.
  // Setting these properties to `null` is not necessary for correctness, but it allows them to be garbage collected.
  for (let i = visitPropsCacheNextIndex - 1; i >= 0; i--) {
    visitPropsCache[i].fn = null;
    visitPropsCache[i].selectorStr = null;
  }
  visitPropsCacheNextIndex = 0;

  // Reset state, ready for next time
  activeLeafVisitorTypeIds.length = 0;
  activeNonLeafVisitorTypeIds.length = 0;

  hasActiveVisitors = false;

  return true;
}

// Array used by `mergeVisitFns` to store visit functions extracted from an array of `VisitProp`s.
// This array is used ephemerally, so we re-use same array for each merge.
const visitFns: VisitFn[] = [];

/**
 * Merge array of visit functions into a single function, which calls each of input functions in turn.
 *
 * The array passed is cleared (length set to 0), so the array can be reused.
 *
 * The merged function is statically defined and does not contain a loop, to hopefully allow
 * JS engine to heavily optimize it.
 *
 * `mergers` contains pre-defined functions to merge up to 5 visit functions.
 * Merger functions for merging more than 5 visit functions are created dynamically on demand.
 *
 * @param visitProps - Array of `VisitProp` objects
 * @returns Function which calls all visit functions in turn
 */
function mergeVisitFns(visitProps: VisitProp[]): VisitFn {
  const numVisitFns = visitProps.length;

  debugAssert(numVisitFns > 0);

  let mergedFn: VisitFn;
  if (numVisitFns === 1) {
    // Only 1 visit function, so no need to merge
    debugAssertIsNonNull(visitProps[0].fn);
    mergedFn = visitProps[0].fn;
  } else {
    // Sort in ascending order of specificity.
    // Selector string as tie-breaker.
    visitProps.sort((a, b) => {
      const diff = a.specificity - b.specificity;
      if (diff !== 0) return diff;

      const strA = a.selectorStr,
        strB = b.selectorStr;
      debugAssertIsNonNull(strA);
      debugAssertIsNonNull(strB);
      // Note: It's possible for different rules to use the same selector,
      // so we need to handle equality here, as well as less than / greater than
      return strA === strB ? 0 : strA < strB ? -1 : 1;
    });

    // Get or create merger for merging `numVisitFns` functions
    let merger: Merger | null;
    if (mergers.length <= numVisitFns) {
      while (mergers.length < numVisitFns) {
        mergers.push(null);
      }
      merger = createMerger(numVisitFns);
      mergers.push(merger);
    } else {
      merger = mergers[numVisitFns];
      if (merger === null) merger = mergers[numVisitFns] = createMerger(numVisitFns);
    }

    // Merge functions.
    // Reuse a temporary array to avoid creating a new array for each merge.
    // TODO: Make merger functions take an array of `VisitProp`s to avoid this operation?
    debugAssert(visitFns.length === 0);

    for (let i = 0; i < numVisitFns; i++) {
      debugAssertIsNonNull(visitProps[i].fn);
      visitFns.push(visitProps[i].fn!);
    }
    mergedFn = merger(...visitFns);

    visitFns.length = 0;
  }

  // Empty `visitProps` array, so it can be reused
  visitProps.length = 0;

  return mergedFn;
}

type Merger = (...visitFns: VisitFn[]) => VisitFn;

/**
 * Create a merger function that merges `fnCount` functions.
 *
 * @param fnCount - Number of functions to be merged
 * @returns Function to merge `fnCount` functions
 */
function createMerger(fnCount: number): Merger {
  const args = [];
  let body = "return node=>{";
  for (let i = 1; i <= fnCount; i++) {
    args.push(`visit${i}`);
    body += `visit${i}(node);`;
  }
  body += "}";
  args.push(body);
  // oxlint-disable-next-line typescript-eslint/no-implied-eval
  return new Function(...args) as Merger;
}

// Pre-defined mergers for merging up to 5 functions
const mergers: (Merger | null)[] = [
  null, // No merger for 0 functions
  null, // No merger for 1 function
  (visit1: VisitFn, visit2: VisitFn) => (node: Node) => {
    visit1(node);
    visit2(node);
  },
  (visit1: VisitFn, visit2: VisitFn, visit3: VisitFn) => (node: Node) => {
    visit1(node);
    visit2(node);
    visit3(node);
  },
  (visit1: VisitFn, visit2: VisitFn, visit3: VisitFn, visit4: VisitFn) => (node: Node) => {
    visit1(node);
    visit2(node);
    visit3(node);
    visit4(node);
  },
  (visit1: VisitFn, visit2: VisitFn, visit3: VisitFn, visit4: VisitFn, visit5: VisitFn) =>
    (node: Node) => {
      visit1(node);
      visit2(node);
      visit3(node);
      visit4(node);
      visit5(node);
    },
];
