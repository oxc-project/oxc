---
source: apps/oxlint/src/tester.rs
---
########## 
arguments: --type-aware
working directory: fixtures/tsgolint
----------

  x typescript-eslint(await-thenable): Unexpected `await` of a non-Promise (non-"Thenable") value.
   ,-[await-thenable.ts:1:1]
 1 | await 12;
   : ^^^^^^^^
 2 | 
   `----

  x typescript-eslint(consistent-return): Function 'maybe' expected a return value.
   ,-[consistent-return.ts:5:3]
 4 |   }
 5 |   return;
   :   ^^^^^^^
 6 | }
   `----

  x typescript-eslint(consistent-type-exports): Type export LocalType is not a value and should be exported using `export type`.
   ,-[consistent-type-exports.ts:7:1]
 6 | 
 7 | export { LocalType, localValue };
   : ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   `----

  x typescript-eslint(dot-notation): ["bar"] is better written in dot notation.
   ,-[dot-notation.ts:4:5]
 3 | declare const foo: { bar: number };
 4 | foo['bar'];
   :     ^^^^^
 5 | 
   `----

  x typescript-eslint(no-array-delete): Using the `delete` operator with an array expression is unsafe.
   ,-[no-array-delete.ts:2:1]
 1 | declare const arr: number[];
 2 | delete arr[0];
   : ^^^^^^^^^^^^^
   `----

  x typescript-eslint(no-base-to-string): '({})' will use Object's default stringification format ('[object Object]') when stringified.
   ,-[no-base-to-string.ts:1:1]
 1 | ({}).toString();
   : ^^^^
   `----
  help: Consider picking a property (e.g. `user.name`), using a formatter (or `JSON.stringify`), or implementing a custom `toString()`/`toLocaleString()` on the type.

  x typescript-eslint(no-meaningless-void-operator): void operator shouldn't be used on void; it should convey that a return value is being ignored
   ,-[no-confusing-void-expression.ts:2:19]
 1 | declare function bar(): void;
 2 | const foo = () => void bar();
   :                   ^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-confusing-void-expression): Placing a void expression inside another expression is forbidden.
   ,-[no-confusing-void-expression.ts:2:24]
 1 | declare function bar(): void;
 2 | const foo = () => void bar();
   :                        ^^^^^
 3 | 
   `----
  help: Move it to its own statement instead.

  x typescript-eslint(no-deprecated): `getVersion` is deprecated. Use apiV2 instead.
   ,-[no-deprecated.ts:8:1]
 7 | 
 8 | getVersion();
   : ^^^^^^^^^^
   `----

  x typescript-eslint(no-duplicate-type-constituents): Union type constituent is duplicated with  'A'.
   ,-[no-duplicate-type-constituents.ts:1:17]
 1 | type T1 = 'A' | 'A';
   :                 ^^^
 2 | 
   `----

  x typescript-eslint(no-confusing-void-expression): Returning a void expression from an arrow function shorthand is forbidden.
   ,-[no-floating-promises.ts:1:51]
 1 | const promise = new Promise((resolve, _reject) => resolve("value"));
   :                                                   ^^^^^^^^^^^^^^^^
 2 | promise;
   `----
  help: Add braces to the arrow function.

  x typescript-eslint(no-floating-promises): Promises must be awaited, add void operator to ignore.
   ,-[no-floating-promises.ts:2:1]
 1 | const promise = new Promise((resolve, _reject) => resolve("value"));
 2 | promise;
   : ^^^^^^^^
 3 | 
   `----
  help: The promise must end with a call to .catch, or end with a call to .then with a rejection handler, or be explicitly marked as ignored with the `void` operator.

  x typescript-eslint(no-for-in-array): For-in loops over arrays skips holes, returns indices as strings, and may visit the prototype chain or other enumerable properties.
   ,-[no-for-in-array.ts:2:1]
 1 | const arr = [1, 2, 3];
 2 | for (const i in arr) {
   : ^^^^^^^^^^^^^^^^^^^^
 3 |   console.log(arr[i]);
   `----
  help: Use a more robust iteration method such as for-of or array.forEach instead.

  x typescript-eslint(no-implied-eval): Implied eval. Consider passing a function.
   ,-[no-implied-eval.ts:1:12]
 1 | setTimeout('alert("Hi!");', 100);
   :            ^^^^^^^^^^^^^^^
   `----

  x typescript-eslint(no-meaningless-void-operator): void operator shouldn't be used on void; it should convey that a return value is being ignored
   ,-[no-meaningless-void-operator.ts:4:1]
 3 | }
 4 | void foo();
   : ^^^^^^^^^^
 5 | 
   `----

  x typescript-eslint(no-confusing-void-expression): Placing a void expression inside another expression is forbidden.
   ,-[no-meaningless-void-operator.ts:4:6]
 3 | }
 4 | void foo();
   :      ^^^^^
 5 | 
   `----
  help: Move it to its own statement instead.

  x typescript-eslint(no-misused-spread): Using the spread operator on Promise in an object can cause unexpected behavior.
   ,-[no-misused-spread.ts:2:25]
 1 | declare const promise: Promise<number>;
 2 | const spreadPromise = { ...promise };
   :                         ^^^^^^^^^^
   `----
  help: Did you forget to await the promise before spreading it?

  x typescript-eslint(no-mixed-enums): Mixing number and string enums can be confusing.
   ,-[no-mixed-enums.ts:3:12]
 2 |   Open = 1,
 3 |   Closed = 'closed',
   :            ^^^^^^^^
 4 | }
   `----

  x typescript-eslint(no-redundant-type-constituents): 'unknown' overrides all other types in this union type.
   ,-[no-redundant-type-constituents.ts:1:20]
 1 | type T1 = string | unknown;
   :                    ^^^^^^^
   `----

  x typescript-eslint(no-unnecessary-boolean-literal-compare): This expression unnecessarily compares a boolean value to a boolean instead of using it directly.
   ,-[no-unnecessary-boolean-literal-compare.ts:2:5]
 1 | declare const someCondition: boolean;
 2 | if (someCondition === true) {
   :     ^^^^^^^^^^^^^^^^^^^^^^
 3 | }
   `----

  x typescript-eslint(no-unnecessary-condition): Unnecessary conditional, value is always truthy.
   ,-[no-unnecessary-condition.ts:3:19]
 2 | declare const b2: boolean;
 3 | export const t1 = b1 && b2;
   :                   ^^
 4 | 
   `----

  x typescript-eslint(strict-boolean-expressions): Unexpected object value in conditional. An object is always truthy.
   ,-[no-unnecessary-condition.ts:3:19]
 2 | declare const b2: boolean;
 3 | export const t1 = b1 && b2;
   :                   ^^
 4 | 
   `----

  x typescript-eslint(no-unnecessary-qualifier): Qualifier is unnecessary since 'B' is in scope.
   ,-[no-unnecessary-qualifier.ts:5:12]
 4 |   export type B = number;
 5 |   const x: A.B = 3;
   :            ^
 6 | }
   `----

  x typescript-eslint(no-unnecessary-template-expression): Template literal expression is unnecessary and can be simplified.
   ,-[no-unnecessary-template-expression.ts:2:18]
 1 | const text = 'hello';
 2 | const wrapped = `${text}`;
   :                  ^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-unnecessary-type-arguments): This is the default value for this type parameter, so it can be omitted.
   ,-[no-unnecessary-type-arguments.ts:4:25]
 3 | }
 4 | const result = identity<string>('hello');
   :                         ^^^^^^
   `----

  x typescript-eslint(no-unnecessary-type-assertion): This assertion is unnecessary since it does not change the type of the expression.
   ,-[no-unnecessary-type-assertion.ts:2:23]
 1 | const str: string = 'hello';
 2 | const redundant = str as string;
   :                  ^^|^ ^^^^^^^^^
   :                    `-- This expression already has the type 'string'
 3 | 
   `----

  x typescript-eslint(no-unnecessary-type-parameters): Type parameter T is used only once in the function signature.
   ,-[no-unnecessary-type-parameters.ts:3:20]
 2 | 
 3 | function parseYAML<T>(input: string): T {
   :                    ^                  |
   :                    |                  `-- This is the only usage of type parameter T in the signature.
 4 |   return input as any as T;
   `----

  x typescript-eslint(no-unsafe-type-assertion): Unsafe assertion to `any` detected: consider using a more specific type to ensure safety.
   ,-[no-unnecessary-type-parameters.ts:4:10]
 3 | function parseYAML<T>(input: string): T {
 4 |   return input as any as T;
   :          ^^^^^^^^^^^^
 5 | }
   `----

  x typescript-eslint(no-unsafe-type-assertion): Unsafe assertion from `any` detected: consider using type guards or a safer assertion.
   ,-[no-unnecessary-type-parameters.ts:4:10]
 3 | function parseYAML<T>(input: string): T {
 4 |   return input as any as T;
   :          ^^^^^^^^^^^^^^^^^
 5 | }
   `----

  x typescript-eslint(no-unsafe-argument): Unsafe argument of type any assigned to a parameter of type string.
   ,-[no-unsafe-argument.ts:3:13]
 2 | function takesString(str: string): void {}
 3 | takesString(anyValue);
   :             ^^^^^^^^
 4 | 
   `----

  x typescript-eslint(no-unsafe-assignment): Unsafe assignment of an any value.
   ,-[no-unsafe-assignment.ts:2:7]
 1 | declare const anyValue: any;
 2 | const str: string = anyValue;
   :       ^^^^^^^^^^^^^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-unsafe-call): Unsafe call of a(n) `any` typed value.
   ,-[no-unsafe-call.ts:2:1]
 1 | declare const anyValue: any;
 2 | anyValue();
   : ^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-unnecessary-condition): Unnecessary comparison between literal values.
    ,-[no-unsafe-enum-comparison.ts:9:20]
  8 | }
  9 | const comparison = Status.Open === Color.Red;
    :                    ^^^^^^^^^^^^^^^^^^^^^^^^^
 10 | 
    `----

  x typescript-eslint(no-unsafe-enum-comparison): The two values in this comparison do not have a shared enum type.
    ,-[no-unsafe-enum-comparison.ts:9:20]
  8 | }
  9 | const comparison = Status.Open === Color.Red;
    :                    ^^^^^^^^^^^^^^^^^^^^^^^^^
 10 | 
    `----

  x typescript-eslint(no-unsafe-member-access): Unsafe member access .foo on an `any` value.
   ,-[no-unsafe-member-access.ts:2:10]
 1 | declare const anyValue: any;
 2 | anyValue.foo;
   :          ^^^
 3 | 
   `----

  x typescript-eslint(no-unsafe-return): Unsafe return of a value of type `any`.
   ,-[no-unsafe-return.ts:3:3]
 2 | function getString(): string {
 3 |   return anyValue;
   :   ^^^^^^^^^^^^^^^^
 4 | }
   `----

  x typescript-eslint(no-unsafe-assignment): Unsafe assignment of an any value.
   ,-[no-unsafe-type-assertion.ts:2:7]
 1 | declare const value: unknown;
 2 | const str = value as any;
   :       ^^^^^^^^^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-unsafe-type-assertion): Unsafe assertion to `any` detected: consider using a more specific type to ensure safety.
   ,-[no-unsafe-type-assertion.ts:2:13]
 1 | declare const value: unknown;
 2 | const str = value as any;
   :             ^^^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-useless-default-assignment): Default value is useless because the parameter has type `number` (not nullish). This default assignment will never be used.
   ,-[no-useless-default-assignment.ts:1:20]
 1 | [1, 2, 3].map((a = 42) => a + 1);
   :                |   ^|^
   :                |    `-- Default value
   :                `-- parameter type `number` is not nullish
 2 | 
   `----
  help: Remove the default assignment

  x typescript-eslint(no-unsafe-type-assertion): Unsafe type assertion: type 'string' is more narrow than the original type.
   ,-[non-nullable-type-assertion-style.ts:2:17]
 1 | declare const value: string | null;
 2 | const result1 = value as string;
   :                 ^^^^^^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(non-nullable-type-assertion-style): Use a ! assertion to more succinctly remove null and undefined from the type.
   ,-[non-nullable-type-assertion-style.ts:2:17]
 1 | declare const value: string | null;
 2 | const result1 = value as string;
   :                 ^^^^^^^^^^^^^^^
 3 | 
   `----

  x eslint(no-debugger): `debugger` statement is not allowed
   ,-[non-tsgolint.ts:1:1]
 1 | debugger;
   : ^^^^^^^^^
 2 | 
   `----
  help: Remove the debugger statement

  x typescript-eslint(only-throw-error): Expected an error object to be thrown.
   ,-[only-throw-error.ts:1:7]
 1 | throw 'error';
   :       ^^^^^^^
 2 | 
   `----

  x typescript-eslint(prefer-find): Prefer .find(...) instead of .filter(...)[0].
   ,-[prefer-find.ts:1:13]
 1 | const two = [1, 2, 3].filter(item => item === 2)[0];
   :             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 2 | console.log(two);
   `----

  x typescript-eslint(prefer-includes): Use 'includes()' method instead.
   ,-[prefer-includes.ts:2:5]
 1 | const text = 'hello';
 2 | if (text.indexOf('h') !== -1) {
   :     ^^^^^^^^^^^^^^^^^^^^^^^^
 3 | }
   `----

  x typescript-eslint(prefer-includes): Use 'includes()' method instead.
   ,-[prefer-includes.ts:6:5]
 5 | const items = [1, 2];
 6 | if (items.indexOf(1) !== -1) {
   :     ^^^^^^^^^^^^^^^^^^^^^^^
 7 | }
   `----

  x typescript-eslint(prefer-includes): Use `String#includes()` method with a string instead.
    ,-[prefer-includes.ts:9:5]
  8 | 
  9 | if (/test/.test(text)) {
    :     ^^^^^^^^^^^^^^^^^
 10 | }
    `----

  x typescript-eslint(prefer-nullish-coalescing): Prefer using nullish coalescing operator (`??`) instead of a ternary expression, as it is simpler to read.
   ,-[prefer-nullish-coalescing.ts:2:23]
 1 | declare const nullableString: string | null;
 2 | const nullishResult = nullableString !== null && nullableString !== undefined ? nullableString : 'default';
   :                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   `----

  x typescript-eslint(no-unnecessary-condition): This condition will always return the same value since the types have no overlap.
   ,-[prefer-nullish-coalescing.ts:2:49]
 1 | declare const nullableString: string | null;
 2 | const nullishResult = nullableString !== null && nullableString !== undefined ? nullableString : 'default';
   :                                                 ^^^^^^^|^^^^^^^    ^^^^^|^^^^
   :                                                        |                `-- Type: undefined
   :                                                        `-- Type: string
   `----

  x typescript-eslint(prefer-optional-chain): Prefer using an optional chain expression instead, as it's more concise and easier to read.
   ,-[prefer-optional-chain.ts:3:1]
 2 | declare const fooOptC: { bar: number } | null | undefined;
 3 | fooOptC && fooOptC.bar;
   : ^^^^^^^^^^^^^^^^^^^^^^
   `----

  x typescript-eslint(prefer-promise-reject-errors): Expected the Promise rejection reason to be an Error.
   ,-[prefer-promise-reject-errors.ts:1:1]
 1 | Promise.reject('error');
   : ^^^^^^^^^^^^^^^^^^^^^^^
   `----

  x typescript-eslint(no-floating-promises): Promises must be awaited, add void operator to ignore.
   ,-[prefer-promise-reject-errors.ts:1:1]
 1 | Promise.reject('error');
   : ^^^^^^^^^^^^^^^^^^^^^^^^
   `----
  help: The promise must end with a call to .catch, or end with a call to .then with a rejection handler, or be explicitly marked as ignored with the `void` operator.

  x typescript-eslint(prefer-readonly-parameter-types): Parameter should be a readonly type.
   ,-[prefer-readonly-parameter-types.ts:5:18]
 4 | 
 5 | function consume(input: MutableInput): void {
   :                  ^^^^^^^^^^^^^^^^^^^
 6 |   input.value = input.value.trim();
   `----

  x typescript-eslint(prefer-readonly): Member 'value' is never reassigned; mark it as `readonly`.
   ,-[prefer-readonly.ts:2:3]
 1 | class Example {
 2 |   private value = 1;
   :   ^^^^^^^^^^^^^
 3 |   private readonly ok = 2;
   `----

  x typescript-eslint(no-unnecessary-type-assertion): This assertion is unnecessary since it does not change the type of the expression.
   ,-[prefer-reduce-type-parameter.ts:2:56]
 1 | const numbers = [1, 2, 3];
 2 | const sum = numbers.reduce((acc, val) => acc + val, 0) as number;
   :            ^^^^^^^^^^^^^^^^^^^^^|^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^
   :                                 `-- This expression already has the type 'number'
 3 | 
   `----

  x typescript-eslint(prefer-regexp-exec): Use the `RegExp#exec()` method instead.
   ,-[prefer-regexp-exec.ts:4:6]
 3 | const text = 'something';
 4 | text.match(/thing/); // should prefer RegExp#exec
   :      ^^^^^
 5 | 
   `----

  x typescript-eslint(prefer-regexp-exec): Use the `RegExp#exec()` method instead.
   ,-[prefer-regexp-exec.ts:7:6]
 6 | const search = 'thing';
 7 | text.match(search); // should prefer RegExp#exec
   :      ^^^^^
 8 | 
   `----

  x typescript-eslint(prefer-readonly-parameter-types): Parameter should be a readonly type.
    ,-[prefer-regexp-exec.ts:9:36]
  8 | 
  9 | function countMatches(str: string, re: RegExp): number {
    :                                    ^^^^^^^^^^
 10 |   return str.match(re)?.length ?? 0; // valid: unknown global flag
    `----

  x typescript-eslint(prefer-return-this-type): Use `this` type instead.
   ,-[prefer-return-this-type.ts:3:28]
 2 |   private value: string = '';
 3 |   setValue(value: string): Builder {
   :                            ^^^^^^^
 4 |     this.value = value;
   `----

  x typescript-eslint(prefer-string-starts-ends-with): Use 'String#startsWith' method instead.
   ,-[prefer-string-starts-ends-with.ts:4:10]
 3 | function startsCase(s: string): boolean {
 4 |   return s[0] === 'a';
   :          ^^^^^^^^^^^^
 5 | }
   `----

  x typescript-eslint(prefer-string-starts-ends-with): Use 'String#endsWith' method instead.
   ,-[prefer-string-starts-ends-with.ts:8:10]
 7 | function endsCase(s: string): boolean {
 8 |   return s.slice(-3) === 'bar';
   :          ^^^^^^^^^^^^^^^^^^^^^
 9 | }
   `----

  x typescript-eslint(promise-function-async): Functions that return promises must be async.
   ,-[promise-function-async.ts:2:1]
 1 |     declare function fetch(url: string): Promise<Response>;
 2 | ,-> function fetchData(): Promise<string> {
 3 | |     return fetch('/api/data').then(res => res.text());
 4 | `-> }
 5 |     
   `----

  x typescript-eslint(prefer-readonly-parameter-types): Parameter should be a readonly type.
   ,-[promise-function-async.ts:3:34]
 2 | function fetchData(): Promise<string> {
 3 |   return fetch('/api/data').then(res => res.text());
   :                                  ^^^
 4 | }
   `----

  x typescript-eslint(promise-function-async): Functions that return promises must be async.
   ,-[promise-function-async.ts:3:34]
 2 | function fetchData(): Promise<string> {
 3 |   return fetch('/api/data').then(res => res.text());
   :                                  ^^^^^^^^^^^^^^^^^
 4 | }
   `----

  x typescript-eslint(related-getter-setter-pairs): `get()` type should be assignable to its equivalent `set()` type.
   ,-[related-getter-setter-pairs.ts:3:16]
 2 |   private _value: number = 0;
 3 |   get value(): string {
   :                ^^^^^^
 4 |     return this._value.toString();
   `----

  x typescript-eslint(require-array-sort-compare): Require 'compare' argument.
   ,-[require-array-sort-compare.ts:2:1]
 1 | const numbers = [3, 1, 4, 1, 5];
 2 | numbers.sort();
   : ^^^^^^^^^^^^^^
 3 | 
   `----

  x typescript-eslint(no-unsafe-assignment): Unsafe assignment of an any value.
   ,-[restrict-plus-operands.ts:1:5]
 1 | let foo = 1n + 1;
   :     ^^^^^^^^^^^^
   `----

  x typescript-eslint(restrict-plus-operands): Numeric '+' operations must either be both bigints or both numbers. Got `bigint` + `number`.
   ,-[restrict-plus-operands.ts:1:11]
 1 | let foo = 1n + 1;
   :           ^^^^^^
   `----

  x typescript-eslint(no-base-to-string): 'obj' will use Object's default stringification format ('[object Object]') when stringified.
   ,-[restrict-template-expressions.ts:2:24]
 1 | declare const obj: object;
 2 | const str1 = `Value: ${obj}`;
   :                        ^^^
 3 | 
   `----
  help: Consider picking a property (e.g. `user.name`), using a formatter (or `JSON.stringify`), or implementing a custom `toString()`/`toLocaleString()` on the type.

  x typescript-eslint(restrict-template-expressions): Invalid type "object" of template literal expression.
   ,-[restrict-template-expressions.ts:2:24]
 1 | declare const obj: object;
 2 | const str1 = `Value: ${obj}`;
   :                        ^^^
 3 | 
   `----

  x typescript-eslint(no-unnecessary-condition): Unnecessary conditional, value is always truthy.
   ,-[strict-boolean-expressions.ts:2:5]
 1 | const str = 'hello';
 2 | if (str) {
   :     ^^^
 3 | }
   `----

  x typescript-eslint(strict-void-return): Value returned in a context where a void return is expected.
   ,-[strict-void-return.ts:2:11]
 1 | declare function foo(cb: () => void): void;
 2 | foo(() => null);
   :           ^^^^
 3 | 
   `----

  x typescript-eslint(consistent-return): Function 'handleStatus' expected a return value.
    ,-[switch-exhaustiveness-check.ts:2:1]
  1 |     type Status = 'pending' | 'approved' | 'rejected';
  2 | ,-> function handleStatus(status: Status) {
  3 | |     switch (status) {
  4 | |       case 'pending':
  5 | |         return 'Waiting for approval';
  6 | |       case 'approved':
  7 | |         return 'Request approved';
  8 | |     }
  9 | `-> }
 10 |     
    `----

  x typescript-eslint(switch-exhaustiveness-check): Switch is not exhaustive
   ,-[switch-exhaustiveness-check.ts:3:11]
 2 | function handleStatus(status: Status) {
 3 |   switch (status) {
   :           ^^^^^^
 4 |     case 'pending':
   `----

  x eslint(no-debugger): `debugger` statement is not allowed
   ,-[test.svelte:2:2]
 1 | <script>
 2 |     debugger;
   :     ^^^^^^^^^
 3 | 
   `----
  help: Remove the debugger statement

  x typescript-eslint(unbound-method): Avoid referencing unbound methods which may cause unintentional scoping of `this`.
   ,-[unbound-method.ts:9:19]
 8 | const calc = new Calculator();
 9 | const addMethod = calc.add;
   :                   ^^^^^^^^
   `----
  help: If your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.

Found 0 warnings and 76 errors.
Finished in <variable>ms on 59 files with 58 rules using 1 threads.
----------
CLI result: LintFoundErrors
----------
