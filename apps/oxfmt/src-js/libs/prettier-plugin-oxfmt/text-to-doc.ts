import { doc } from "prettier";
import { format } from "../../index";
import type { Parser, Doc } from "prettier";
import type { FormatOptions } from "../../index";

const { hardline, join } = doc.builders;
const LINE_BREAK_RE = /\r?\n/;

export const textToDoc: Parser<Doc>["parse"] = async (embeddedSourceText, textToDocOptions) => {
  // NOTE: For (j|t)s-in-xxx, default `parser` is either `babel` or `typescript`
  // In case of ts-in-md, `filepath` is overridden to distinguish TSX or TS
  // We need to infer `SourceType` for `oxc_formatter`
  const { parser, parentParser, filepath, _oxfmtPluginOptionsJson } = textToDocOptions;
  const filename =
    parser === "typescript"
      ? filepath.endsWith(".tsx")
        ? "dummy.tsx" // tsx-in-md
        : "dummy.ts" // ts-in-md / ts-in-xxx
      : "dummy.jsx"; // Otherwise, always enable JSX for js-in-xxx, it's safe

  // SAFETY: This is generated by Rust side and only available if plugin is used
  const oxfmtPluginOptions: FormatOptions = JSON.parse(_oxfmtPluginOptionsJson as string);

  // NOTE: Ultimately, this should be `textToDoc()` like Prettier originally does
  let { code, errors } = await format(filename, embeddedSourceText, oxfmtPluginOptions);

  if (0 < errors.length) throw new Error(errors[0].message);

  // Handle `isSingleJsxExpressionStatementInMarkdown()` with heuristics
  if (parentParser === "markdown" || parentParser === "mdx") {
    // https://github.com/prettier/prettier/blob/90983f40dce5e20beea4e5618b5e0426a6a7f4f0/src/language-js/semicolon/semicolon.js#L103
    if (code.startsWith("<") && code.endsWith(">;")) {
      code = code.slice(0, -1);
    }
    // https://github.com/prettier/prettier/blob/90983f40dce5e20beea4e5618b5e0426a6a7f4f0/src/language-js/semicolon/semicolon.js#L12
    if (code.startsWith(";<") && code.endsWith(">")) {
      code = code.slice(1);
    }
  }

  // NOTE: This is required for the parent ((j|t)s-in-xxx) printer
  // to handle line breaks correctly,
  // not only for `options.vueIndentScriptAndStyle` but also for basic printing.
  return join(hardline, code.split(LINE_BREAK_RE));
};
