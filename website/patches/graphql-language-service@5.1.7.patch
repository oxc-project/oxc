diff --git a/esm/interface/getAutocompleteSuggestions.js b/esm/interface/getAutocompleteSuggestions.js
index ac159d132d095a789b966627d315f4238c79ab60..59b43348eb0755149719e2dd2b3ba63d0d6e77a3 100644
--- a/esm/interface/getAutocompleteSuggestions.js
+++ b/esm/interface/getAutocompleteSuggestions.js
@@ -234,7 +234,12 @@ export function getAutocompleteSuggestions(schema, queryText, cursor, contextTok
         return getSuggestionsForVariableDefinition(token, schema, kind);
     }
     if (kind === RuleKinds.DIRECTIVE) {
-        return getSuggestionsForDirective(token, state, schema, kind);
+        // We should autocomplete fields on the line after we autocomplete a directive
+        if (state.needsAdvance) { // active after '@' or many other kinds of punctuation, so perfect for when we need to autocomplete directives
+            return getSuggestionsForDirective(token, state, schema, kind);
+        } else { // there has been no '@' so we should autocomplete fields
+            return getSuggestionsForFieldNames(token, typeInfo, opts);
+        }
     }
     return [];
 }
@@ -442,7 +447,11 @@ function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind)
             const possibleIfaceMap = Object.create(null);
             for (const type of possibleObjTypes) {
                 for (const iface of type.getInterfaces()) {
-                    possibleIfaceMap[iface.name] = iface;
+                    // Only allow interfaces to be autocompleted that implement
+                    // the type of the fragment.
+                    if (iface._interfaces.some(x => x === typeInfo.parentType.name)) {
+                        possibleIfaceMap[iface.name] = iface;
+                    }
                 }
             }
             possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));