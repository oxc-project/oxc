//! Generator for traverse module files.
//!
//! Generates:
//! - `traverse.rs` - Traverse trait with enter/exit methods for all AST types
//! - `ancestor.rs` - Ancestor types and utilities for AST traversal
//! - `walk.rs` - Walk functions that implement the traversal logic

use convert_case::{Case, Casing};
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::{
    Codegen, Generator, TRAVERSE_CRATE_PATH,
    output::{Output, output_path},
    schema::{
        EnumDef, Schema, StructDef, TypeDef,
    },
    utils::create_ident,
};

use super::define_generator;

/// Generator for traverse module files.
pub struct TraverseGenerator;

define_generator!(TraverseGenerator);

impl Generator for TraverseGenerator {
    fn generate_many(&self, schema: &Schema, _codegen: &Codegen) -> Vec<Output> {
        let traverse_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/traverse.rs"),
            tokens: generate_traverse_trait(schema),
        };
        
        let ancestor_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/ancestor.rs"),
            tokens: generate_ancestor_types(schema),
        };
        
        let walk_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/walk.rs"),
            tokens: generate_walk_functions(schema),
        };

        vec![traverse_output, ancestor_output, walk_output]
    }
}

/// Generate the Traverse trait with enter/exit methods for all AST types.
fn generate_traverse_trait(schema: &Schema) -> TokenStream {
    let mut traverse_methods = TokenStream::new();
    
    // Collect all AST types that have the visit attribute
    let mut types_with_visitor = Vec::new();
    
    for type_def in &schema.types {
        match type_def {
            TypeDef::Struct(struct_def) => {
                if struct_def.visit.has_visitor() {
                    let ident = create_ident(&struct_def.name);
                    types_with_visitor.push((&struct_def.name, ident));
                }
            }
            TypeDef::Enum(enum_def) => {
                if enum_def.visit.has_visitor() {
                    let ident = create_ident(&enum_def.name);
                    types_with_visitor.push((&enum_def.name, ident));
                }
            }
            _ => {}
        }
    }
    
    // Add special case for Statements - this matches what the JS script does
    let statements_string = "Statements".to_string();
    let statements_ident = quote!(Vec<'a, Statement<'a>>);
    
    for (type_name, type_ident) in &types_with_visitor {
        let snake_name = type_name.to_case(Case::Snake);
        let enter_method = format_ident!("enter_{}", snake_name);
        let exit_method = format_ident!("exit_{}", snake_name);
        
        traverse_methods.extend(quote! {
            #[inline]
            fn #enter_method(&mut self, node: &mut #type_ident, ctx: &mut TraverseCtx<'a, State>) {}
            #[inline]
            fn #exit_method(&mut self, node: &mut #type_ident, ctx: &mut TraverseCtx<'a, State>) {}
        });
    }
    
    // Add statements methods manually
    let statements_snake = statements_string.to_case(Case::Snake);
    let statements_enter = format_ident!("enter_{}", statements_snake);
    let statements_exit = format_ident!("exit_{}", statements_snake);
    
    traverse_methods.extend(quote! {
        #[inline]
        fn #statements_enter(&mut self, node: &mut #statements_ident, ctx: &mut TraverseCtx<'a, State>) {}
        #[inline]
        fn #statements_exit(&mut self, node: &mut #statements_ident, ctx: &mut TraverseCtx<'a, State>) {}
    });

    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        use oxc_allocator::Vec;
        use oxc_ast::ast::*;

        use crate::TraverseCtx;

        #[expect(unused_variables)]
        pub trait Traverse<'a, State> {
            #traverse_methods
        }
    }
}

/// Generate ancestor types and utilities.
fn generate_ancestor_types(schema: &Schema) -> TokenStream {
    let mut ancestor_type_variants = TokenStream::new();
    let mut ancestor_enum_variants = TokenStream::new();
    let mut is_functions = TokenStream::new();
    let mut address_match_arms = TokenStream::new();
    let mut ancestor_types = TokenStream::new();
    let mut discriminant = 1u16;
    
    // Generate variants for all struct types with visitors
    for type_def in &schema.types {
        if let TypeDef::Struct(struct_def) = type_def {
            if struct_def.visit.has_visitor() {
                let type_name = &struct_def.name;
                let _type_snake_name = type_name.to_case(Case::Snake);
                let type_screaming_name = type_name.to_case(Case::UpperSnake);
                
                // Generate variants for each field that contains visited types
                for field in &struct_def.fields {
                    // For now, generate a variant for every field
                    // TODO: Only generate for fields that contain visited types
                    let field_name_camel = field.name.to_case(Case::Pascal);
                    let variant_name = format_ident!("{}{}", type_name, field_name_camel);
                    let variant_ident = format_ident!("{}", variant_name);
                    
                    ancestor_type_variants.extend(quote! {
                        #variant_ident = #discriminant,
                    });
                    
                    // For now, use a simple placeholder struct type
                    ancestor_enum_variants.extend(quote! {
                        #variant_ident(*const u8) = AncestorType::#variant_ident as u16,
                    });
                    
                    address_match_arms.extend(quote! {
                        Self::#variant_ident(ptr) => Address::from_ptr(*ptr as *const u8),
                    });
                    
                    discriminant += 1;
                }
                
                // Generate is_* function for this type
                let is_fn_name = format_ident!("is_{}", type_name.to_case(Case::Snake));
                is_functions.extend(quote! {
                    #[inline]
                    pub fn #is_fn_name(self) -> bool {
                        // TODO: Implement proper variant matching
                        false
                    }
                });
            }
        }
    }

    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        #![allow(unused_imports)]
        #![expect(
            clippy::cast_ptr_alignment,
            clippy::elidable_lifetime_names,
            clippy::ptr_as_ptr,
            clippy::ref_option,
            clippy::undocumented_unsafe_blocks,
        )]

        use std::{cell::Cell, marker::PhantomData, mem::offset_of};

        use oxc_allocator::{Address, Box, GetAddress, Vec};
        use oxc_ast::ast::*;
        use oxc_syntax::{comment_node::CommentNodeId, scope::ScopeId};

        /// Type of [`Ancestor`].
        /// Used in [`crate::TraverseCtx::retag_stack`].
        #[repr(u16)]
        #[derive(Clone, Copy)]
        pub(crate) enum AncestorType {
            None = 0,
            #ancestor_type_variants
        }

        /// Ancestor type used in AST traversal.
        #[repr(C, u16)]
        #[derive(Clone, Copy, Debug)]
        pub enum Ancestor<'a, 't> {
            None = AncestorType::None as u16,
            #ancestor_enum_variants
        }

        impl<'a, 't> Ancestor<'a, 't> {
            #is_functions
        }

        impl<'a, 't> GetAddress for Ancestor<'a, 't> {
            #[inline]
            fn address(&self) -> Address {
                match self {
                    Self::None => Address::DUMMY,
                    #address_match_arms
                }
            }
        }

        #ancestor_types
    }
}

/// Generate walk functions that implement the traversal logic.
fn generate_walk_functions(schema: &Schema) -> TokenStream {
    let mut walk_methods = TokenStream::new();
    
    // Generate walk functions for each AST type with visitors
    for type_def in &schema.types {
        match type_def {
            TypeDef::Struct(struct_def) => {
                if struct_def.visit.has_visitor() {
                    walk_methods.extend(generate_walk_for_struct(struct_def, schema));
                }
            }
            TypeDef::Enum(enum_def) => {
                if enum_def.visit.has_visitor() {
                    walk_methods.extend(generate_walk_for_enum(enum_def, schema));
                }
            }
            _ => {}
        }
    }

    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        #![expect(
            clippy::semicolon_if_nothing_returned,
            clippy::ptr_as_ptr,
            clippy::ref_as_ptr,
            clippy::cast_ptr_alignment,
            clippy::borrow_as_ptr,
            clippy::match_same_arms,
            unsafe_op_in_unsafe_fn
        )]

        use std::{cell::Cell, marker::PhantomData};

        use oxc_allocator::Vec;
        use oxc_ast::ast::*;
        use oxc_syntax::scope::ScopeId;

        use crate::{ancestor::{self, AncestorType}, Ancestor, Traverse, TraverseCtx};

        /// Walk AST with `Traverse` impl.
        ///
        /// SAFETY:
        /// * `program` must be a pointer to a valid `Program` which has lifetime `'a`
        ///   (`Program<'a>`).
        /// * `ctx` must contain a `TraverseAncestry<'a>` with single `Ancestor::None` on its stack.
        #[inline]
        pub unsafe fn walk_ast<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            program: *mut Program<'a>,
            ctx: &mut TraverseCtx<'a, State>,
        ) {
            walk_program(traverser, program, ctx);
        }

        #walk_methods

        unsafe fn walk_statements<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            stmts: *mut Vec<'a, Statement<'a>>,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.enter_statements(&mut *stmts, ctx);
            for stmt in &mut *stmts {
                walk_statement(traverser, stmt, ctx);
            }
            traverser.exit_statements(&mut *stmts, ctx);
        }
    }
}

/// Generate a walk function for a struct.
fn generate_walk_for_struct(struct_def: &StructDef, _schema: &Schema) -> TokenStream {
    let struct_name = create_ident(&struct_def.name);
    let snake_name = struct_def.name.to_case(Case::Snake);
    let walk_fn_name = format_ident!("walk_{}", snake_name);
    let enter_method = format_ident!("enter_{}", snake_name);
    let exit_method = format_ident!("exit_{}", snake_name);
    
    // TODO: Generate field traversal logic based on struct fields
    // For now, just the basic structure
    
    quote! {
        unsafe fn #walk_fn_name<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            node: *mut #struct_name,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.#enter_method(&mut *node, ctx);
            // TODO: Generate field traversal
            traverser.#exit_method(&mut *node, ctx);
        }
    }
}

/// Generate a walk function for an enum.
fn generate_walk_for_enum(enum_def: &EnumDef, _schema: &Schema) -> TokenStream {
    let enum_name = create_ident(&enum_def.name);
    let snake_name = enum_def.name.to_case(Case::Snake);
    let walk_fn_name = format_ident!("walk_{}", snake_name);
    let enter_method = format_ident!("enter_{}", snake_name);
    let exit_method = format_ident!("exit_{}", snake_name);
    
    // TODO: Generate variant match arms
    
    quote! {
        unsafe fn #walk_fn_name<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            node: *mut #enum_name,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.#enter_method(&mut *node, ctx);
            match &mut *node {
                // TODO: Generate variant match arms
                _ => {}
            }
            traverser.#exit_method(&mut *node, ctx);
        }
    }
}