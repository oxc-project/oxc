//! Generator for traverse module files.
//!
//! Generates:
//! - `traverse.rs` - Traverse trait with enter/exit methods for all AST types
//! - `ancestor.rs` - Ancestor types and utilities for AST traversal
//! - `walk.rs` - Walk functions that implement the traversal logic

use cow_utils::CowUtils;
use convert_case::{Case, Casing};
use proc_macro2::TokenStream;
use quote::{ToTokens, format_ident, quote};

use crate::{
    Codegen, Generator, TRAVERSE_CRATE_PATH,
    output::{Output, output_path},
    schema::{
        Def, EnumDef, FieldDef, Schema, StructDef, TypeDef,
        extensions::visit::Scope,
    },
    utils::{create_ident, create_ident_tokens},
};

use super::{define_generator};

/// Generator for traverse module files.
pub struct TraverseGenerator;

define_generator!(TraverseGenerator);

impl Generator for TraverseGenerator {
    fn generate_many(&self, schema: &Schema, _codegen: &Codegen) -> Vec<Output> {
        let traverse_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/traverse.rs"),
            tokens: generate_traverse_trait(schema),
        };
        
        let ancestor_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/ancestor.rs"),
            tokens: generate_ancestor_types(schema),
        };
        
        let walk_output = Output::Rust {
            path: output_path(TRAVERSE_CRATE_PATH, "generated/walk.rs"),
            tokens: generate_walk_functions(schema),
        };

        vec![traverse_output, ancestor_output, walk_output]
    }
}

/// Generate the Traverse trait with enter/exit methods for all AST types.
fn generate_traverse_trait(schema: &Schema) -> TokenStream {
    let mut traverse_methods = TokenStream::new();
    
    // Collect all AST types that have the visit attribute
    let mut types_with_visitor = Vec::new();
    
    for type_def in schema.types.values() {
        match type_def {
            TypeDef::Struct(struct_def) => {
                if struct_def.visit.has_visitor() {
                    types_with_visitor.push((&struct_def.name, &struct_def.ident));
                }
            }
            TypeDef::Enum(enum_def) => {
                if enum_def.visit.has_visitor() {
                    types_with_visitor.push((&enum_def.name, &enum_def.ident));
                }
            }
            _ => {}
        }
    }
    
    // Add special case for Statements
    types_with_visitor.push(("Statements", &format_ident!("Vec<'a, Statement<'a>>")));
    
    for (type_name, type_ident) in types_with_visitor {
        let snake_name = type_name.to_case(Case::Snake);
        let enter_method = format_ident!("enter_{}", snake_name);
        let exit_method = format_ident!("exit_{}", snake_name);
        
        traverse_methods.extend(quote! {
            #[inline]
            fn #enter_method(&mut self, node: &mut #type_ident, ctx: &mut TraverseCtx<'a, State>) {}
            #[inline]
            fn #exit_method(&mut self, node: &mut #type_ident, ctx: &mut TraverseCtx<'a, State>) {}
        });
    }

    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        use oxc_allocator::Vec;
        use oxc_ast::ast::*;

        use crate::TraverseCtx;

        #[expect(unused_variables)]
        pub trait Traverse<'a, State> {
            #traverse_methods
        }
    }
}

/// Generate ancestor types and utilities.
fn generate_ancestor_types(schema: &Schema) -> TokenStream {
    // This is a complex generation - for now, return a placeholder
    // that matches the expected structure
    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        #![allow(unused_imports)]
        #![expect(
            clippy::cast_ptr_alignment,
            clippy::elidable_lifetime_names,
            clippy::ptr_as_ptr,
            clippy::ref_option,
            clippy::undocumented_unsafe_blocks,
        )]

        use std::{cell::Cell, marker::PhantomData, mem::offset_of};

        use oxc_allocator::{Address, Box, GetAddress, Vec};
        use oxc_ast::ast::*;
        use oxc_syntax::{comment_node::CommentNodeId, scope::ScopeId};

        /// Type of [`Ancestor`].
        /// Used in [`crate::TraverseCtx::retag_stack`].
        #[repr(u16)]
        #[derive(Clone, Copy)]
        pub(crate) enum AncestorType {
            None = 0,
            // TODO: Generate actual variants based on schema
        }

        /// Ancestor type used in AST traversal.
        #[repr(C, u16)]
        #[derive(Clone, Copy, Debug)]
        pub enum Ancestor<'a, 't> {
            None = AncestorType::None as u16,
            // TODO: Generate actual variants based on schema
        }

        impl<'a, 't> Ancestor<'a, 't> {
            // TODO: Generate is_* methods
        }

        impl<'a, 't> GetAddress for Ancestor<'a, 't> {
            #[inline]
            fn address(&self) -> Address {
                match self {
                    Self::None => Address::DUMMY,
                    // TODO: Generate actual match arms
                }
            }
        }

        // TODO: Generate offset constants and without structs
    }
}

/// Generate walk functions that implement the traversal logic.
fn generate_walk_functions(schema: &Schema) -> TokenStream {
    let mut walk_methods = TokenStream::new();
    
    // Generate walk functions for each AST type with visitors
    for type_def in schema.types.values() {
        match type_def {
            TypeDef::Struct(struct_def) => {
                if struct_def.visit.has_visitor() {
                    walk_methods.extend(generate_walk_for_struct(struct_def, schema));
                }
            }
            TypeDef::Enum(enum_def) => {
                if enum_def.visit.has_visitor() {
                    walk_methods.extend(generate_walk_for_enum(enum_def, schema));
                }
            }
            _ => {}
        }
    }

    quote! {
        // Auto-generated code, DO NOT EDIT DIRECTLY!
        // Generated by `tasks/ast_tools`.
        // To alter this generated file you have to edit the codegen.

        #![expect(
            clippy::semicolon_if_nothing_returned,
            clippy::ptr_as_ptr,
            clippy::ref_as_ptr,
            clippy::cast_ptr_alignment,
            clippy::borrow_as_ptr,
            clippy::match_same_arms,
            unsafe_op_in_unsafe_fn
        )]

        use std::{cell::Cell, marker::PhantomData};

        use oxc_allocator::Vec;
        use oxc_ast::ast::*;
        use oxc_syntax::scope::ScopeId;

        use crate::{ancestor::{self, AncestorType}, Ancestor, Traverse, TraverseCtx};

        /// Walk AST with `Traverse` impl.
        ///
        /// SAFETY:
        /// * `program` must be a pointer to a valid `Program` which has lifetime `'a`
        ///   (`Program<'a>`).
        /// * `ctx` must contain a `TraverseAncestry<'a>` with single `Ancestor::None` on its stack.
        #[inline]
        pub unsafe fn walk_ast<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            program: *mut Program<'a>,
            ctx: &mut TraverseCtx<'a, State>,
        ) {
            walk_program(traverser, program, ctx);
        }

        #walk_methods

        unsafe fn walk_statements<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            stmts: *mut Vec<'a, Statement<'a>>,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.enter_statements(&mut *stmts, ctx);
            for stmt in &mut *stmts {
                walk_statement(traverser, stmt, ctx);
            }
            traverser.exit_statements(&mut *stmts, ctx);
        }
    }
}

/// Generate a walk function for a struct.
fn generate_walk_for_struct(struct_def: &StructDef, schema: &Schema) -> TokenStream {
    let struct_name = &struct_def.ident;
    let snake_name = struct_def.name.to_case(Case::Snake);
    let walk_fn_name = format_ident!("walk_{}", snake_name);
    let enter_method = format_ident!("enter_{}", snake_name);
    let exit_method = format_ident!("exit_{}", snake_name);
    
    // TODO: Generate field traversal logic based on struct fields
    // For now, just the basic structure
    
    quote! {
        unsafe fn #walk_fn_name<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            node: *mut #struct_name,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.#enter_method(&mut *node, ctx);
            // TODO: Generate field traversal
            traverser.#exit_method(&mut *node, ctx);
        }
    }
}

/// Generate a walk function for an enum.
fn generate_walk_for_enum(enum_def: &EnumDef, schema: &Schema) -> TokenStream {
    let enum_name = &enum_def.ident;
    let snake_name = enum_def.name.to_case(Case::Snake);
    let walk_fn_name = format_ident!("walk_{}", snake_name);
    let enter_method = format_ident!("enter_{}", snake_name);
    let exit_method = format_ident!("exit_{}", snake_name);
    
    // TODO: Generate variant match arms
    
    quote! {
        unsafe fn #walk_fn_name<'a, State, Tr: Traverse<'a, State>>(
            traverser: &mut Tr,
            node: *mut #enum_name,
            ctx: &mut TraverseCtx<'a, State>
        ) {
            traverser.#enter_method(&mut *node, ctx);
            match &mut *node {
                // TODO: Generate variant match arms
                _ => {}
            }
            traverser.#exit_method(&mut *node, ctx);
        }
    }
}