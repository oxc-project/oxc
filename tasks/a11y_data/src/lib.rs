use std::{fs, path::Path};

use oxc_tasks_common::project_root;

use proc_macro2::{Literal, TokenStream};
use quote::quote;
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
pub struct Attribute {
    pub name: String,
    pub value: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
pub struct SchemaEntry {
    pub name: String,
    pub attributes: Vec<Attribute>,
}

fn generate_string_literals_from_json_array<P: AsRef<Path>>(path: P) -> Vec<TokenStream> {
    let content = fs::read_to_string(path).unwrap();
    let elements = serde_json::from_str::<Vec<String>>(&content).unwrap();

    elements
        .into_iter()
        .map(|s| {
            let lit = Literal::string(&s);
            quote! { #lit, }
        })
        .collect()
}

fn generate_schema_literals_from_json<P: AsRef<Path>>(path: P) -> Vec<TokenStream> {
    let schema_content: String = fs::read_to_string(path).unwrap();
    let schema = serde_json::from_str::<Vec<SchemaEntry>>(&schema_content).unwrap();

    schema.iter().map(|entry| {
        let name_lit = Literal::string(&entry.name);

        // attributes: &[Attribute { name: "...", value: Some("...") }, ...]
        let attr_items = entry.attributes.iter().map(|attr| {
            let aname = Literal::string(&attr.name);
            match &attr.value {
                Some(v) => {
                    let vlit = Literal::string(v);
                    quote! { Attr { name: #aname, value: Some(#vlit) } }
                }
                None => {
                    quote! { Attr { name: #aname, value: None } }
                }
            }
        });
        let attributes_ts = if entry.attributes.is_empty() {
            quote! { &[] }
        } else {
            quote! { &[ #(#attr_items),* ] }
        };

        quote! {
            ElementSchema {
                name: #name_lit,
                attributes: #attributes_ts,
            },
        }
    })
    .collect()
}

pub fn generate() {
    let abstract_roles_path = project_root().join("tasks/a11y_data/abstractRoles.json");
    let interactive_roles_path = project_root().join("tasks/a11y_data/interactiveRoles.json");
    let noninteractive_roles_path = project_root().join("tasks/a11y_data/noninteractiveRoles.json");

    let abstract_role_literals = generate_string_literals_from_json_array(abstract_roles_path);
    let interactive_role_literals = generate_string_literals_from_json_array(interactive_roles_path);
    let noninteractive_role_literals = generate_string_literals_from_json_array(noninteractive_roles_path);

    let interactive_schema_path = project_root().join("tasks/a11y_data/interactiveElementRoleSchemas.json");
    let interactive_schema_entries = generate_schema_literals_from_json(interactive_schema_path);

    let noninteractive_schema_path = project_root().join("tasks/a11y_data/noninteractiveElementRoleSchemas.json");
    let noninteractive_schema_entries = generate_schema_literals_from_json(noninteractive_schema_path);

    let noninteractive_axobject_schema_path = project_root().join("tasks/a11y_data/noninteractiveAxObjectSchema.json");
    let noninteractive_axobject_schema_entries = generate_schema_literals_from_json(noninteractive_axobject_schema_path);

    let code = quote! {
        use phf::phf_set;

        #[derive(Copy, Clone, Eq, PartialEq, Debug)]
        pub struct Attr {
            pub name: &'static str,
            pub value: Option<&'static str>,
        }

        #[derive(Copy, Clone, Eq, PartialEq, Debug)]
        pub struct ElementSchema {
            pub name: &'static str,
            pub attributes: &'static [Attr],
        }

        pub static ABSTRACT_ROLES: phf::Set<&'static str> = phf_set! {
            #(#abstract_role_literals)*
        };

        pub static INTERACTIVE_ROLES: phf::Set<&'static str> = phf_set! {
            #(#interactive_role_literals)*
        };

        pub static NONINTERACTIVE_ROLES: phf::Set<&'static str> = phf_set! {
            #(#noninteractive_role_literals)*
        };

        pub static INTERACTIVE_ELEMENT_SCHEMA: &[ElementSchema] = &[
            #(#interactive_schema_entries)*
        ];

        pub static NONINTERACTIVE_ELEMENT_SCHEMA: &[ElementSchema] = &[
            #(#noninteractive_schema_entries)*
        ];

        pub static NONINTERACTIVE_AXOBJECT_ELEMENT_SCHEMA: &[ElementSchema] = &[
            #(#noninteractive_axobject_schema_entries)*
        ];
    };

    generate_file("crates/oxc_aria_query/src/lib.rs", code);
}

fn generate_file(file: &str, token_stream: proc_macro2::TokenStream) {
    let syntax_tree = syn::parse2(token_stream).unwrap();
    let code = format!(
        "/// Auto generated by `tasks/a11y_data/src/lib.rs`.\n{}",
        prettyplease::unparse(&syntax_tree)
            .replace("};", "};\n")
        .replace("];", "];\n")
    );
    fs::write(project_root().join(file), code).unwrap();
}
