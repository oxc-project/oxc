//! Create documentation pages for each rule. Pages are printed as Markdown and
//! get added to the website.
//! You can test/run this task with `just website ../oxc-project.github.io`,
//! assuming you have cloned the oxc website repo next to the oxc repo.

use std::{
    fmt::{self, Write},
    path::PathBuf,
};

use itertools::Itertools;
use oxc_linter::{LintPlugins, table::RuleTableRow};
use schemars::{
    JsonSchema, SchemaGenerator,
    schema::{InstanceType, Schema, SchemaObject, SingleOrVec},
};

use website_common::Renderer;

use super::HtmlWriter;

#[derive(Debug)]
pub(super) struct Context {
    page: HtmlWriter,
    schemas: SchemaGenerator,
    renderer: Renderer,
}

impl Context {
    pub fn new<T: JsonSchema + ?Sized>(mut schemas: SchemaGenerator) -> Self {
        let renderer = Renderer::new(schemas.root_schema_for::<T>());
        Self { page: HtmlWriter::with_capacity(1024), schemas, renderer }
    }

    pub fn render_rule_docs_page(&mut self, rule: &RuleTableRow) -> Result<String, fmt::Error> {
        const APPROX_FIX_CATEGORY_AND_PLUGIN_LEN: usize = 512;
        let RuleTableRow {
            name,
            documentation,
            schema,
            plugin,
            turned_on_by_default,
            autofix,
            category,
            is_tsgolint_rule,
        } = rule;
        let resolved =
            schema.as_ref().map(|schema| self.schemas.dereference(schema).unwrap_or(schema));

        self.page.reserve(
            documentation.map_or(0, str::len) + name.len() + APPROX_FIX_CATEGORY_AND_PLUGIN_LEN,
        );

        writeln!(
            self.page,
            "<!-- This file is auto-generated by {}. Do not edit it manually. -->\n",
            file!()
        )?;

        // If it's a tsgolint rule, provide the additional source link in the script tag. Otherwise, set tsgolint_source to a blank string.
        let tsgolint_source = if *is_tsgolint_rule {
            format!("\nconst tsgolintSource = `{}`;", tsgolint_rule_source(rule))
        } else {
            String::new()
        };

        writeln!(
            self.page,
            "<script setup>
import {{ data }} from '../version.data.js';
const source = `{}`;{}
</script>",
            rule_source(rule),
            // Will be empty string if not a tsgolint rule
            tsgolint_source
        )?;

        writeln!(self.page, r#"# {plugin}/{name} <Badge type="info" text="{category}" />"#)?;

        // rule metadata
        self.page.div(r#"class="rule-meta""#, |p| {
            if *turned_on_by_default {
                p.Alert(r#"class="default-on" type="success""#, |p| {
                    if *is_tsgolint_rule {
                        p.writeln(r#"<span class="emoji">âœ…</span> This rule is turned on by default when type-aware linting is enabled."#)
                    } else {
                        p.writeln(r#"<span class="emoji">âœ…</span> This rule is turned on by default."#)
                    }
                })?;
            }
            if *is_tsgolint_rule {
                p.Alert(r#"type="info""#, |p| {
                    p.writeln(
                        r#"<span class="emoji">ðŸ’­</span> This rule requires <a href="https://oxc.rs/docs/guide/usage/linter/type-aware.html" target="_blank" rel="noreferrer">type information</a>."#
                    )
                })?;
            }

            if let Some(emoji) = autofix.emoji() {
                p.Alert(r#"class="fix" type="info""#, |p| {
                    p.writeln(format!(
                        r#"<span class="emoji">{}</span> {}"#,
                        emoji,
                        autofix.description()
                    ))
                })?;
            }

            Ok(())
        })?;

        // rule documentation
        if let Some(docs) = documentation {
            writeln!(self.page, "\n{}", *docs)?;
        }

        // rule configuration
        if let Some(Schema::Object(schema)) = resolved {
            let config_section = self.rule_config(schema);
            // Pull rule configuration description from the schema metadata, if present.
            // The schemars `SchemaObject` may contain a `metadata` block with an
            // optional `description` field. If present, include it above the
            // configuration listing so readers see the intent for the config.
            let section_description = schema
                .metadata
                .as_ref()
                .and_then(|m| m.description.as_ref())
                .map(|desc| format!("\n{desc}\n"))
                .unwrap_or_default();
            if !config_section.trim().is_empty() {
                writeln!(self.page, "\n## Configuration\n{section_description}{config_section}")?;
            }
        }

        // how to use
        writeln!(self.page, "\n## How to use\n{}", how_to_use(rule))?;
        writeln!(self.page, "\n## References\n")?;

        // rule source link(s)
        writeln!(
            self.page,
            r#"- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>"#
        )?;
        if *is_tsgolint_rule {
            writeln!(
                self.page,
                r#"- <a v-bind:href="tsgolintSource" target="_blank" rel="noreferrer">Rule Source (tsgolint)</a>"#
            )?;
        }

        Ok(self.page.take())
    }

    fn rule_config(&self, schema: &SchemaObject) -> String {
        if let Some(array) = &schema.array
            && let Some(SingleOrVec::Vec(options)) = &array.items
        {
            // multiple options
            return options
                .iter()
                .enumerate()
                .map(|(i, schema)| match schema {
                    Schema::Object(schema_object) => {
                        let section = self.renderer.render_schema(3, "", schema_object);
                        let title = format!("\n### The {} option\n", ordinal(i + 1));
                        let instance_type = section.instance_type.as_ref().map_or_else(
                            String::new,
                            |instance_type| {
                                if instance_type == "object" {
                                    "\nThis option is an object with the following properties:\n"
                                        .to_string()
                                } else {
                                    format!("\ntype: `{instance_type}`\n")
                                }
                            },
                        );
                        let rendered = section.to_md(&self.renderer);
                        let description = if section.description.is_empty() {
                            section.description
                        } else {
                            format!("\n{}\n", section.description)
                        };
                        format!("{title}{instance_type}{description}{rendered}")
                    }
                    Schema::Bool(_) => panic!(),
                })
                .join("");
        }
        let mut section = self.renderer.render_schema(2, "", schema);
        if section.default.is_none()
            && let Some(SingleOrVec::Single(ty)) = &schema.instance_type
        {
            match &**ty {
                InstanceType::Boolean => {
                    section.default = Some(format!("{}", <bool>::default()));
                }
                InstanceType::Array => {
                    section.default = Some("[]".to_string());
                }
                _ => {}
            }
        }
        let mut rendered = section.to_md(&self.renderer);
        if rendered.trim().is_empty() {
            return rendered;
        }

        // Check if this is an enum-based config (oneOf with single-value enums)
        let is_enum_config =
            schema.subschemas.as_ref().and_then(|s| s.one_of.as_ref()).is_some_and(|variants| {
                variants.iter().all(|variant| {
                    if let Schema::Object(obj) = variant {
                        obj.enum_values.as_ref().is_some_and(|vals| vals.len() == 1)
                    } else {
                        false
                    }
                })
            });

        if schema.instance_type.as_ref().is_some_and(|it| it.contains(&InstanceType::Object)) {
            rendered = format!(
                "\nThis rule accepts a configuration object with the following properties:\n{rendered}\n"
            );
        } else if is_enum_config
            || (schema.instance_type.as_ref().is_some_and(|it| it.contains(&InstanceType::String))
                && schema.enum_values.is_some())
        {
            // Handle enum-based configurations (either direct enum or oneOf variants)
            rendered =
                format!("\nThis rule accepts one of the following string values:\n{rendered}\n");
        }

        rendered
    }
}

#[expect(clippy::disallowed_methods)]
fn rule_source(rule: &RuleTableRow) -> String {
    use project_root::get_project_root;
    use std::sync::OnceLock;
    const LINT_RULES_DIR: &str = "crates/oxc_linter/src/rules";
    static ROOT: OnceLock<PathBuf> = OnceLock::new();
    let root = ROOT.get_or_init(|| get_project_root().unwrap());

    // Some rules are folders with a mod.rs file, others are just a rust file
    let rule_name = rule.name.replace('-', "_");
    let mut rule_path = format!("{}/{}", rule.plugin, rule_name);
    if root.join(LINT_RULES_DIR).join(&rule.plugin).join(rule_name).is_dir() {
        rule_path.push_str("/mod.rs");
    } else {
        rule_path.push_str(".rs");
    }

    format!(
        "https://github.com/oxc-project/oxc/blob/${{ data }}/crates/oxc_linter/src/rules/{rule_path}"
    )
}

/// Returns the URL to the source code of a tsgolint rule.
/// Only applicable for tsgolint rules.
// TODO: Provide a way to link to a specific git ref? We'd need to update the justfile to pass it in correctly.
#[expect(clippy::disallowed_methods)]
fn tsgolint_rule_source(rule: &RuleTableRow) -> String {
    let rule_name = rule.name.replace('-', "_");
    let rule_path = format!("{rule_name}/{rule_name}.go");
    // Result: https://github.com/oxc-project/tsgolint/blob/main/internal/rules/prefer_reduce_type_parameter/prefer_reduce_type_parameter.go
    format!("https://github.com/oxc-project/tsgolint/blob/main/internal/rules/{rule_path}")
}

/// Returns `true` if the given plugin is a default plugin.
/// - Example: `eslint` => true
/// - Example: `jest` => false
fn is_default_plugin(plugin: &str) -> bool {
    LintPlugins::try_from(plugin).is_ok_and(|plugin| LintPlugins::default().contains(plugin))
}

/// Returns the normalized plugin name.
/// - Example: `react_perf` -> `react-perf`
/// - Example: `eslint` -> `eslint`
/// - Example: `jsx_a11y` -> `jsx-a11y`
fn get_normalized_plugin_name(plugin: &str) -> &str {
    LintPlugins::try_from(plugin).unwrap_or(LintPlugins::empty()).into()
}

fn how_to_use(rule: &RuleTableRow) -> String {
    let plugin = &rule.plugin;
    let normalized_plugin_name = get_normalized_plugin_name(plugin);
    let rule_full_name = if normalized_plugin_name.is_empty() {
        rule.name.to_string()
    } else {
        format!("{}/{}", normalized_plugin_name, rule.name)
    };
    let is_default_plugin = is_default_plugin(plugin);
    let is_tsgolint_rule = rule.is_tsgolint_rule;

    let type_aware_flag = if is_tsgolint_rule { "--type-aware " } else { "" };

    let enable_bash_example = if is_default_plugin {
        format!(r"oxlint {type_aware_flag}--deny {rule_full_name}")
    } else {
        format!(
            r"oxlint {type_aware_flag}--deny {rule_full_name} --{normalized_plugin_name}-plugin"
        )
    };
    let enable_config_example = if is_default_plugin {
        format!(
            r#"{{
    "rules": {{
        "{rule_full_name}": "error"
    }}
}}"#
        )
    } else {
        format!(
            r#"{{
    "plugins": ["{normalized_plugin_name}"],
    "rules": {{
        "{rule_full_name}": "error"
    }}
}}"#
        )
    };
    format!(
        r"
To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{enable_config_example}
```

```bash [CLI]
{enable_bash_example}
```

:::
"
    )
}

fn ordinal(n: usize) -> String {
    let suffix = match n % 100 {
        11..=13 => "th",
        _ => match n % 10 {
            1 => "st",
            2 => "nd", // spellchecker:disable-line
            3 => "rd",
            _ => "th",
        },
    };
    format!("{n}{suffix}")
}
