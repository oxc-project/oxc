---
source: tasks/website_linter/src/rules/mod.rs
expression: snapshot
---
--- eslint/no-unused-vars.md ---
---
title: "eslint/no-unused-vars"
category: "Correctness"
default: true
type_aware: false
fix: "fixable_dangerous_suggestion"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/eslint/no_unused_vars/mod.rs`;
</script>

<RuleHeader />


### What it does

Disallows variable declarations, imports, or type declarations that are
not used in code.

### Why is this bad?

Variables that are declared and not used anywhere in the code are most
likely an error due to incomplete refactoring. Such variables take up
space in the code and can lead to confusion by readers.

```ts
// `b` is unused; this indicates a bug.
function add(a: number, b: number) {
    return a;
}
console.log(add(1, 2));
```

A variable `foo` is considered to be used if any of the following are
true:

* It is called (`foo()`) or constructed (`new foo()`)
* It is read (`var bar = foo`)
* It is passed into a function or constructor as an argument (`doSomething(foo)`)
* It is read inside of a function that is passed to another function
  (`doSomething(function() { foo(); })`)
* It is exported (`export const foo = 42`)
* It is used as an operand to TypeScript's `typeof` operator (`const bar:
  typeof foo = 4`)

A variable is _not_ considered to be used if it is only ever declared
(`var foo = 5`) or assigned to (`foo = 7`).

#### Types
This rule has full support for TypeScript types, interfaces, enums, and
namespaces.

A type or interface `Foo` is considered to be used if it is used in any
of the following ways:
- It is used in the definition of another type or interface.
- It is used as a type annotation or as part of a function signature.
- It is used in a cast or `satisfies` expression.

A type or interface is _not_ considered to be used if it is only ever
used in its own definition, e.g. `type Foo = Array<Foo>`.

Enums and namespaces are treated the same as variables, classes,
functions, etc.

#### Ignored Files
This rule ignores `.d.ts`, `.astro`, `.svelte` and `.vue` files entirely. Variables,
classes, interfaces, and types declared in `.d.ts` files are generally
used by other files, which are not checked by Oxlint. Since Oxlint does
not support parsing template syntax, this rule cannot tell if a variable
is used or unused in a Vue / Svelte / Astro file.

#### Exported

The original ESLint rule recognizes `/* exported variableName */`
comments as a way to indicate that a variable is used in another script
and should not be considered unused. Since ES modules are now a TC39
standard, Oxlint does not support this feature.

### Examples

Examples of **incorrect** code for this rule:

```javascript
/* no-unused-vars: "error" */
/* if you have `some_unused_var` defined as a global in .oxlintrc.json */

// It checks variables you have defined as global
some_unused_var = 42;

var x;

// Write-only variables are not considered as used.
var y = 10;
y = 5;

// A read for a modification of itself is not considered as used.
var z = 0;
z = z + 1;

// By default, unused arguments cause warnings.
(function(foo) {
    return 5;
})();

// Unused recursive functions also cause warnings.
function fact(n) {
    if (n < 2) return 1;
    return n * fact(n - 1);
}

// When a function definition destructures an array, unused entries from
// the array also cause warnings.
function getY([x, y]) {
    return y;
}
```

```ts
type A = Array<A>;

enum Color {
    Red,
    Green,
    Blue
}
```

Examples of **correct** code for this rule:
```js
/* no-unused-vars: "error" */

var x = 10;
alert(x);

// foo is considered used here
myFunc(function foo() {
    // ...
}.bind(this));

(function(foo) {
    return foo;
})();

var myFunc;
myFunc = setTimeout(function() {
    // myFunc is considered used
    myFunc();
}, 50);

// Only the second argument from the destructured array is used.
function getY([, y]) {
    return y;
}
```

```ts
export const x = 1;
const y = 1;
export { y };

type A = Record<string, unknown>;
type B<T> = T extends Record<infer K, any> ? K : never;
const x = 'foo' as B<A>;
console.log(x);
```

Examples of **incorrect** code for `/* exported variableName */` operation:
```js
/* exported global_var */

// Not respected, use ES modules instead.
var global_var = 42;
```


## Configuration

This rule accepts a configuration object with the following properties:

### args

type: `"after-used" | "all" | "none"`

default: `"after-used"`

Controls how unused arguments are checked.


#### `"after-used"`



Unused positional arguments that occur before the last used argument
will not be checked, but all named arguments and all positional
arguments after the last used argument will be checked.


#### `"all"`



All named arguments must be used


#### `"none"`



Do not check arguments


### argsIgnorePattern



Specifies exceptions to this rule for unused arguments. Arguments whose
names match this pattern will be ignored.

By default, this pattern is `^_` unless options are configured with an
object. In this case it will default to [`None`]. Note that this
behavior deviates from both ESLint and TypeScript-ESLint, which never
provide a default pattern.

#### Example

Examples of **correct** code for this option when the pattern is `^_`:

```javascript
function foo(_a, b) {
console.log(b);
}
foo(1, 2);
```


### caughtErrors

type: `"all" | "none"`


Used for `catch` block validation.


#### `"all"`



All named arguments must be used.


#### `"none"`



Do not check error objects.


### caughtErrorsIgnorePattern



Specifies exceptions to this rule for errors caught within a `catch` block.
Variables declared within a `catch` block whose names match this pattern
will be ignored.

#### Example

Examples of **correct** code when the pattern is `^ignore`:

```javascript
try {
// ...
} catch (ignoreErr) {
console.error("Error caught in catch block");
}
```


### destructuredArrayIgnorePattern



This option specifies exceptions within destructuring patterns that will
not be checked for usage. Variables declared within array destructuring
whose names match this pattern will be ignored.

By default this pattern is unset.

#### Example

Examples of **correct** code for this option, when the pattern is `^_`:
```javascript
const [a, _b, c] = ["a", "b", "c"];
console.log(a + c);

const { x: [_a, foo] } = bar;
console.log(foo);

let _m, n;
foo.forEach(item => {
[_m, n] = item;
console.log(n);
});
```


### ignoreClassWithStaticInitBlock

type: `boolean`

default: `false`

The `ignoreClassWithStaticInitBlock` option is a boolean. Static
initialization blocks allow you to initialize static variables and
execute code during the evaluation of a class definition, meaning
the static block code is executed without creating a new instance
of the class. When set to `true`, this option ignores classes
containing static initialization blocks.

#### Example

Examples of **incorrect** code for the `{ "ignoreClassWithStaticInitBlock": true }` option

```javascript
/* no-unused-vars: ["error", { "ignoreClassWithStaticInitBlock": true }]*/

class Foo {
static myProperty = "some string";
static mymethod() {
return "some string";
}
}

class Bar {
static {
let baz; // unused variable
}
}
```

Examples of **correct** code for the `{ "ignoreClassWithStaticInitBlock": true }` option

```javascript
/* no-unused-vars: ["error", { "ignoreClassWithStaticInitBlock": true }]*/

class Foo {
static {
let bar = "some string";

console.log(bar);
}
}
```


### ignoreRestSiblings

type: `boolean`

default: `false`

Using a Rest property it is possible to "omit" properties from an
object, but by default the sibling properties are marked as "unused".
With this option enabled the rest property's siblings are ignored.


#### Example
Examples of **correct** code when this option is set to `true`:
```js
// 'foo' and 'bar' were ignored because they have a rest property sibling.
var { foo, ...coords } = data;

var bar;
({ bar, ...coords } = data);
```


### ignoreUsingDeclarations

type: `boolean`

default: `false`

When set to `true`, the rule will ignore variables declared with
`using` or `await using` declarations, even if they are unused.

This is useful when working with resources that need to be disposed
via the explicit resource management proposal, where the primary
purpose is the disposal side effect rather than using the resource.

#### Example

Examples of **correct** code for the `{ "ignoreUsingDeclarations": true }` option:

```javascript
/* no-unused-vars: ["error", { "ignoreUsingDeclarations": true }]*/

using resource = getResource();
await using anotherResource = getAnotherResource();
```


### reportUsedIgnorePattern

type: `boolean`

default: `false`

The `reportUsedIgnorePattern` option is a boolean.
Using this option will report variables that match any of the valid
ignore pattern options (`varsIgnorePattern`, `argsIgnorePattern`,
`caughtErrorsIgnorePattern`, or `destructuredArrayIgnorePattern`) if
they have been used.

#### Example

Examples of **incorrect** code for the `{ "reportUsedIgnorePattern": true }` option:

```javascript
/* no-unused-vars: ["error", { "reportUsedIgnorePattern": true, "varsIgnorePattern": "[iI]gnored" }]*/

var firstVarIgnored = 1;
var secondVar = 2;
console.log(firstVarIgnored, secondVar);
```

Examples of **correct** code for the `{ "reportUsedIgnorePattern": true }` option:

```javascript
/* no-unused-vars: ["error", { "reportUsedIgnorePattern": true, "varsIgnorePattern": "[iI]gnored" }]*/

var firstVar = 1;
var secondVar = 2;
console.log(firstVar, secondVar);
```


### reportVarsOnlyUsedAsTypes

type: `boolean`

default: `false`

The `reportVarsOnlyUsedAsTypes` option is a boolean.

If `true`, the rule will also report variables that are only used as types.

#### Examples

Examples of **incorrect** code for the `{ "reportVarsOnlyUsedAsTypes": true }` option:

```javascript
/*  no-unused-vars: ["error", { "reportVarsOnlyUsedAsTypes": true }] */

const myNumber: number = 4;
export type MyNumber = typeof myNumber
```

Examples of **correct** code for the `{ "reportVarsOnlyUsedAsTypes": true }` option:

```javascript
export type MyNumber = number;
```

Note: even with `{ "reportVarsOnlyUsedAsTypes": false }`, cases where the value is
only used a type within itself will still be reported:
```javascript
function foo(): typeof foo {}
```


### vars

type: `"all" | "local"`

default: `"all"`

Controls how usage of a variable in the global scope is checked.


#### `"all"`



All variables are checked for usage, including those in the global scope.


#### `"local"`



Checks only that locally-declared variables are used but will allow
global variables to be unused.


### varsIgnorePattern



Specifies exceptions to this rule for unused variables. Variables whose
names match this pattern will be ignored.

By default, this pattern is `^_` unless options are configured with an
object. In this case it will default to [`None`]. Note that this
behavior deviates from both ESLint and TypeScript-ESLint, which never
provide a default pattern.

#### Example

Examples of **correct** code for this option when the pattern is `^_`:
```javascript
var _a = 10;
var b = 10;
console.log(b);
```





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "rules": {
        "no-unused-vars": "error"
    }
}
```

```bash [CLI]
oxlint --deny no-unused-vars
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- import/namespace.md ---
---
title: "import/namespace"
category: "Correctness"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/import/namespace.rs`;
</script>

<RuleHeader />


### What it does

Enforces names exist at the time they are dereferenced, when imported as
a full namespace (i.e. `import * as foo from './foo'; foo.bar();` will
report if bar is not exported by `./foo.`).  Will report at the import
declaration if there are no exported names found.  Also, will report for
computed references (i.e. `foo["bar"]()`).  Reports on assignment to a
member of an imported namespace.

### Why is this bad?

Dereferencing a name that does not exist can lead to runtime errors and
unexpected behavior in your code. It makes the code less reliable and
harder to maintain, as it may not be clear which names are valid. This
rule helps ensure that all referenced names are defined, improving
the clarity and robustness of your code.

### Examples

Given
```javascript
// ./foo.js
export const bar = "I'm bar";
```

Examples of **incorrect** code for this rule:
```javascript
// ./qux.js
import * as foo from './foo';
foo.notExported(); // Error: notExported is not exported

// Assignment to a member of an imported namespace
foo.bar = "new value"; // Error: bar cannot be reassigned

// Computed reference to a non-existent export
const method = "notExported";
foo[method](); // Error: notExported does not exist
```

Examples of **correct** code for this rule:
```javascript
// ./baz.js
import * as foo from './foo';
console.log(foo.bar); // Valid: bar is exported

// Computed reference
const method = "bar";
foo[method](); // Valid: method refers to an exported function
```


## Configuration

This rule accepts a configuration object with the following properties:

### allowComputed

type: `boolean`

default: `false`

Whether to allow computed references to an imported namespace.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["import"],
    "rules": {
        "import/namespace": "error"
    }
}
```

```bash [CLI]
oxlint --deny import/namespace --import-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- jest/expect-expect.md ---
---
title: "jest/expect-expect"
category: "Correctness"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/jest/expect_expect.rs`;
</script>

<RuleHeader />


### What it does

This rule triggers when there is no call made to `expect` in a test, ensure that there is at least one `expect` call made in a test.

### Why is this bad?

People may forget to add assertions.

### Examples

Examples of **incorrect** code for this rule:
```javascript
it('should be a test', () => {
    console.log('no assertion');
});
test('should assert something', () => {});
```

This rule is compatible with [eslint-plugin-vitest](https://github.com/vitest-dev/eslint-plugin-vitest/blob/v1.1.9/docs/rules/expect-expect.md),
to use it, add the following configuration to your `.oxlintrc.json`:

```json
{
  "rules": {
     "vitest/expect-expect": "error"
  }
}
```


## Configuration

This rule accepts a configuration object with the following properties:

### additionalTestBlockFunctions

type: `string[]`

default: `[]`

An array of function names that should also be treated as test blocks.


### assertFunctionNames

type: `string[]`

default: `["expect"]`

A list of function names that should be treated as assertion functions.

NOTE: The default value is `["expect"]` for Jest and
`["expect", "expectTypeOf", "assert", "assertType"]` for Vitest.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["jest"],
    "rules": {
        "jest/expect-expect": "error"
    }
}
```

```bash [CLI]
oxlint --deny jest/expect-expect --jest-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- nextjs/no-duplicate-head.md ---
---
title: "nextjs/no-duplicate-head"
category: "Correctness"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/nextjs/no_duplicate_head.rs`;
</script>

<RuleHeader />


### What it does

Prevent duplicate usage of `<Head>` in `pages/_document.js`.

### Why is this bad?

This can cause unexpected behavior in your application.

### Examples

Examples of **incorrect** code for this rule:
```jsx
import Document, { Html, Head, Main, NextScript } from 'next/document'
class MyDocument extends Document {
  static async getInitialProps(ctx) {
  }
  render() {
    return (
      <Html>
        <Head />
        <Head />
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }
}
export default MyDocument
```

Examples of **correct** code for this rule:
```jsx
import Document, { Html, Head, Main, NextScript } from 'next/document'
class MyDocument extends Document {
  static async getInitialProps(ctx) {
  }
  render() {
    return (
      <Html>
        <Head />
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    )
  }
}
export default MyDocument
```


## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["nextjs"],
    "rules": {
        "nextjs/no-duplicate-head": "error"
    }
}
```

```bash [CLI]
oxlint --deny nextjs/no-duplicate-head --nextjs-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- promise/no-callback-in-promise.md ---
---
title: "promise/no-callback-in-promise"
category: "Correctness"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/promise/no_callback_in_promise.rs`;
</script>

<RuleHeader />


### What it does

Disallows calling a callback function (`cb()`) inside a `Promise.prototype.then()`
or `Promise.prototype.catch()`.

### Why is this bad?

Directly invoking a callback inside a `then()` or `catch()` method can lead to
unexpected behavior, such as the callback being called multiple times. Additionally,
mixing the callback and promise paradigms in this way can make the code confusing
and harder to maintain.

### Examples

Examples of **incorrect** code for this rule:
```js
function callback(err, data) {
    console.log('Callback got called with:', err, data)
    throw new Error('My error')
  }

Promise.resolve()
  .then(() => callback(null, 'data'))
  .catch((err) => callback(err.message, null))
```

Examples of **correct** code for this rule:
```js
Promise.resolve()
  .then((data) => { console.log(data) })
  .catch((err) => { console.error(err) })
```


## Configuration

This rule accepts a configuration object with the following properties:

### callbacks

type: `string[]`

default: `["callback", "cb", "done", "next"]`

List of callback function names to check for within Promise `then` and `catch` methods.


### exceptions

type: `string[]`

default: `[]`

List of callback function names to allow within Promise `then` and `catch` methods.


### timeoutsErr

type: `boolean`

default: `false`

Boolean as to whether callbacks in timeout functions like `setTimeout` will err.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["promise"],
    "rules": {
        "promise/no-callback-in-promise": "error"
    }
}
```

```bash [CLI]
oxlint --deny promise/no-callback-in-promise --promise-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- typescript/no-floating-promises.md ---
---
title: "typescript/no-floating-promises"
category: "Correctness"
default: true
type_aware: true
fix: "fixable_suggestion"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/typescript/no_floating_promises.rs`;
const tsgolintSource = `https://github.com/oxc-project/tsgolint/blob/main/internal/rules/no_floating_promises/no_floating_promises.go`;
</script>

<RuleHeader />


### What it does

This rule disallows "floating" Promises in TypeScript code, which is a Promise that is created without any code to handle its resolution or rejection.

This rule will report Promise-valued statements that are not treated in one of the following ways:

- Calling its `.then()` with two arguments
- Calling its `.catch()` with one argument
- `await`ing it
- `return`ing it
- `void`ing it

This rule also reports when an Array containing Promises is created and not properly handled. The main way to resolve this is by using one of the Promise concurrency methods to create a single Promise, then handling that according to the procedure above. These methods include:

- `Promise.all()`
- `Promise.allSettled()`
- `Promise.any()`
- `Promise.race()`

### Why is this bad?

Floating Promises can cause several issues, such as improperly sequenced operations, ignored Promise rejections, and more.

### Examples

Examples of **incorrect** code for this rule:
```ts
const promise = new Promise((resolve, reject) => resolve('value'));
promise;

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(() => {});

Promise.reject('value').catch();

Promise.reject('value').finally();

[1, 2, 3].map(async x => x + 1);
```

Examples of **correct** code for this rule:
```ts
const promise = new Promise((resolve, reject) => resolve('value'));
await promise;

async function returnsPromise() {
  return 'value';
}

void returnsPromise();

returnsPromise().then(
  () => {},
  () => {},
);

Promise.reject('value').catch(() => {});

await Promise.reject('value').finally(() => {});

await Promise.all([1, 2, 3].map(async x => x + 1));
```


## Configuration

This rule accepts a configuration object with the following properties:

### allowForKnownSafeCalls

type: `array`

default: `[]`

Allows specific calls to be ignored, specified as type or value specifiers.


#### allowForKnownSafeCalls[n]

type: `string`


Type or value specifier for matching specific declarations

Supports four types of specifiers:

1. **String specifier** (deprecated): Universal match by name
```json
"Promise"
```

2. **File specifier**: Match types/values declared in local files
```json
{ "from": "file", "name": "MyType" }
{ "from": "file", "name": ["Type1", "Type2"] }
{ "from": "file", "name": "MyType", "path": "./types.ts" }
```

3. **Lib specifier**: Match TypeScript built-in lib types
```json
{ "from": "lib", "name": "Promise" }
{ "from": "lib", "name": ["Promise", "PromiseLike"] }
```

4. **Package specifier**: Match types/values from npm packages
```json
{ "from": "package", "name": "Observable", "package": "rxjs" }
{ "from": "package", "name": ["Observable", "Subject"], "package": "rxjs" }
```


### allowForKnownSafePromises

type: `array`

default: `[]`

Allows specific Promise types to be ignored, specified as type or value specifiers.


#### allowForKnownSafePromises[n]

type: `string`


Type or value specifier for matching specific declarations

Supports four types of specifiers:

1. **String specifier** (deprecated): Universal match by name
```json
"Promise"
```

2. **File specifier**: Match types/values declared in local files
```json
{ "from": "file", "name": "MyType" }
{ "from": "file", "name": ["Type1", "Type2"] }
{ "from": "file", "name": "MyType", "path": "./types.ts" }
```

3. **Lib specifier**: Match TypeScript built-in lib types
```json
{ "from": "lib", "name": "Promise" }
{ "from": "lib", "name": ["Promise", "PromiseLike"] }
```

4. **Package specifier**: Match types/values from npm packages
```json
{ "from": "package", "name": "Observable", "package": "rxjs" }
{ "from": "package", "name": ["Observable", "Subject"], "package": "rxjs" }
```


### checkThenables

type: `boolean`

default: `false`

Check for thenable objects that are not necessarily Promises.


### ignoreIIFE

type: `boolean`

default: `false`

Ignore immediately invoked function expressions (IIFEs).


### ignoreVoid

type: `boolean`

default: `true`

Ignore Promises that are void expressions.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "rules": {
        "typescript/no-floating-promises": "error"
    }
}
```

```bash [CLI]
oxlint --type-aware --deny typescript/no-floating-promises
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>
- <a v-bind:href="tsgolintSource" target="_blank" rel="noreferrer">Rule Source (tsgolint)</a>


--- vue/no-lifecycle-after-await.md ---
---
title: "vue/no-lifecycle-after-await"
category: "Correctness"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/vue/no_lifecycle_after_await.rs`;
</script>

<RuleHeader />


### What it does

Disallow asynchronously registered lifecycle hooks.

### Why is this bad?

Lifecycle hooks must be registered synchronously during `setup()` execution.
If a lifecycle hook is called after an `await` statement, it may be registered
too late and might not work as expected.

### Examples

Examples of **incorrect** code for this rule:
```vue
<script>
import { onMounted } from 'vue'
export default {
  async setup() {
    await doSomething()
    onMounted(() => { /* ... */ }) // error
  }
}
</script>
```

Examples of **correct** code for this rule:
```vue
<script>
import { onMounted } from 'vue'
export default {
  async setup() {
    onMounted(() => { /* ... */ }) // ok
    await doSomething()
  }
}
</script>
```


## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["vue"],
    "rules": {
        "vue/no-lifecycle-after-await": "error"
    }
}
```

```bash [CLI]
oxlint --deny vue/no-lifecycle-after-await --vue-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- unicorn/prefer-array-find.md ---
---
title: "unicorn/prefer-array-find"
category: "Perf"
default: false
type_aware: false
fix: "pending"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/unicorn/prefer_array_find.rs`;
</script>

<RuleHeader />


### What it does

Encourages using `Array.prototype.find` instead of `filter(...)[0]` or
similar patterns when only the first matching element is needed.

### Why is this bad?

Using `filter(...)[0]` to get the first match is less efficient and more verbose
than using `find(...)`. `find` short-circuits when a match is found,
whereas `filter` evaluates the entire array.

### Examples

Examples of **incorrect** code for this rule:
```js
const match = users.filter(u => u.id === id)[0];
const match = users.filter(fn).shift();
```

Examples of **correct** code for this rule:
```js
const match = users.find(u => u.id === id);
const match = users.find(fn);
```


## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "rules": {
        "unicorn/prefer-array-find": "error"
    }
}
```

```bash [CLI]
oxlint --deny unicorn/prefer-array-find
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- oxc/no-barrel-file.md ---
---
title: "oxc/no-barrel-file"
category: "Restriction"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/oxc/no_barrel_file.rs`;
</script>

<RuleHeader />


### What it does

Disallow the use of barrel files where the file contains `export *` statements,
and the total number of modules exceed a threshold.

The default threshold is 100.

### Why is this bad?

Barrel files that re-export many modules can significantly slow down
applications and bundlers. When a barrel file exports a large number of
modules, importing from it forces the runtime or bundler to process all
the exported modules, even if only a few are actually used. This leads
to slower startup times and larger bundle sizes.

References:

* <https://github.com/thepassle/eslint-plugin-barrel-files>
* <https://marvinh.dev/blog/speeding-up-javascript-ecosystem-part-7>

### Examples

Invalid:

```javascript
export * from 'foo'; // where `foo` loads a subtree of 100 modules
import * as ns from 'foo'; // where `foo` loads a subtree of 100 modules
```

Valid:

```javascript
export { foo } from 'foo';
```


## Configuration

This rule accepts a configuration object with the following properties:

### threshold

type: `integer`

default: `100`

The maximum number of modules that can be re-exported via `export *`
before the rule is triggered.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "rules": {
        "oxc/no-barrel-file": "error"
    }
}
```

```bash [CLI]
oxlint --deny oxc/no-barrel-file
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- typescript/no-explicit-any.md ---
---
title: "typescript/no-explicit-any"
category: "Restriction"
default: false
type_aware: false
fix: "conditional_fix"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/typescript/no_explicit_any.rs`;
</script>

<RuleHeader />


### What it does

Disallows explicit use of the `any` type.

### Why is this bad?

The `any` type in TypeScript is a dangerous "escape hatch" from the type system. Using
`any` disables many type checking rules and is generally best used only as a last resort or
when prototyping code. This rule reports on explicit uses of the `any` keyword as a type
annotation.

> TypeScript's `--noImplicitAny` compiler option prevents an implied `any`, but doesn't
> prevent `any` from being explicitly used the way this rule does.

### Examples

Examples of **incorrect** code for this rule:
```typescript
const age: any = 'seventeen';
const ages: any[] = ['seventeen']
const ages: Array<any> = ['seventeen'];
function greet(): any {}
function greet(): any[] {}
function greet(): Array<any> {}
function greet(): Array<Array<any>> {}
function greet(param: Array<any>): string {}
function greet(param: Array<any>): Array<any> {}
```

Examples of **correct** code for this rule:
```typescript
const age: number = 17;
const ages: number[] = [17];
const ages: Array<number> = [17];
function greet(): string {}
function greet(): string[] {}
function greet(): Array<string> {}
function greet(): Array<Array<string>> {}
function greet(param: Array<string>): string {}
function greet(param: Array<string>): Array<string> {}
```


## Configuration

This rule accepts a configuration object with the following properties:

### fixToUnknown

type: `boolean`

default: `false`

Whether to enable auto-fixing in which the `any` type is converted to the `unknown` type.


### ignoreRestArgs

type: `boolean`

default: `false`

Whether to ignore rest parameter arrays.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "rules": {
        "typescript/no-explicit-any": "error"
    }
}
```

```bash [CLI]
oxlint --deny typescript/no-explicit-any
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- jsdoc/require-returns.md ---
---
title: "jsdoc/require-returns"
category: "Pedantic"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/jsdoc/require_returns.rs`;
</script>

<RuleHeader />


### What it does

Requires that return statements are documented.
Will also report if multiple `@returns` tags are present.

### Why is this bad?

The rule is intended to prevent the omission of `@returns` tag when necessary.

### Examples

Examples of **incorrect** code for this rule:
```javascript
/** Foo. */
function quux () { return foo; }

/**
 * @returns Foo!
 * @returns Foo?
 */
function quux () { return foo; }
```

Examples of **correct** code for this rule:
```javascript
/** @returns Foo. */
function quux () { return foo; }
```


## Configuration

This rule accepts a configuration object with the following properties:

### checkConstructors

type: `boolean`

default: `false`

Whether to check constructor methods.


### checkGetters

type: `boolean`

default: `true`

Whether to check getter methods.


### exemptedBy

type: `string[]`

default: `["inheritdoc"]`

Tags that exempt functions from requiring `@returns`.


### forceRequireReturn

type: `boolean`

default: `false`

Whether to require a `@returns` tag even if the function doesn't return a value.


### forceReturnsWithAsync

type: `boolean`

default: `false`

Whether to require a `@returns` tag for async functions.





## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["jsdoc"],
    "rules": {
        "jsdoc/require-returns": "error"
    }
}
```

```bash [CLI]
oxlint --deny jsdoc/require-returns --jsdoc-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>


--- react/rules-of-hooks.md ---
---
title: "react/rules-of-hooks"
category: "Pedantic"
default: false
type_aware: false
fix: "none"
---

<!-- This file is auto-generated by tasks/website_linter/src/rules/doc_page.rs. Do not edit it manually. -->

<script setup>
import { data } from '../version.data.js';
const source = `https://github.com/oxc-project/oxc/blob/${ data }/crates/oxc_linter/src/rules/react/rules_of_hooks.rs`;
</script>

<RuleHeader />


### What it does

Enforces the Rules of Hooks, ensuring that React Hooks are only called
in valid contexts and in the correct order.

### Why is this bad?

React Hooks must follow specific rules to ensure they work correctly:
1. Only call Hooks at the top level (never inside loops, conditions,
   or nested functions)
2. Only call Hooks from React function components or custom Hooks
3. Hooks must be called in the same order every time a component renders

Breaking these rules can lead to bugs where state gets corrupted or
component behavior becomes unpredictable.

### Examples

Examples of **incorrect** code for this rule:
```javascript
// Don't call Hooks inside loops, conditions, or nested functions
function BadComponent() {
  if (condition) {
    const [state, setState] = useState(); // ❌ Hook in condition
  }

  for (let i = 0; i < 10; i++) {
    useEffect(() => {}); // ❌ Hook in loop
  }
}

// Don't call Hooks from regular JavaScript functions
function regularFunction() {
  const [state, setState] = useState(); // ❌ Hook in regular function
}
```

Examples of **correct** code for this rule:
```javascript
// ✅ Call Hooks at the top level of a React component
function GoodComponent() {
  const [state, setState] = useState();

  useEffect(() => {
    // Effect logic here
  });

  return <div>{state}</div>;
}

// ✅ Call Hooks from custom Hooks
function useCustomHook() {
  const [state, setState] = useState();
  return state;
}
```



## How to use

To **enable** this rule using the config file or in the CLI, you can use:

::: code-group

```json [Config (.oxlintrc.json)]
{
    "plugins": ["react"],
    "rules": {
        "react/rules-of-hooks": "error"
    }
}
```

```bash [CLI]
oxlint --deny react/rules-of-hooks --react-plugin
```

:::


## References

- <a v-bind:href="source" target="_blank" rel="noreferrer">Rule Source</a>
